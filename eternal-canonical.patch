diff -ruN before/App.tsx after/App.tsx
--- before/App.tsx	2026-02-21 02:03:33.743190066 +0000
+++ after/App.tsx	1970-01-01 00:00:00.000000000 +0000
@@ -1,396 +0,0 @@
-
-import React, { useState, useRef, useMemo } from 'react';
-import { useSession } from './hooks/useSession';
-import { useArchiveStore } from './hooks/useArchiveStore';
-import { useGedcomImport } from './hooks/useGedcomImport';
-import { useProfileEditor } from './hooks/useProfileEditor';
-import { useMediaAttach } from './hooks/useMediaAttach';
-import { 
-  LogOut, Search, GitBranch, RefreshCw, PenTool, Check, ChevronLeft, ChevronRight, Upload, Calendar, Camera, Sparkles, X, FileCode, Disc, History, ScrollText, Heart, MapPin, Anchor, Map as MapIcon, Quote, CloudUpload, ExternalLink, Library, Globe, Image as ImageIcon, Settings, Trash2, User as UserIcon, Users, UserPlus
-} from 'lucide-react';
-import { User, Profile, FamilyTree, AppView, LifeEvent, MediaItem } from './types';
-import { getEventIcon, getPlaceholderImage } from './constants';
-import { parseGedcom } from './utils/gedcom';
-import { formatEventSentence, inferMediaKind } from './utils/formatters';
-import { parseGedcomMonthDayYear, parseGedcomDate, formatFullDate } from './utils/date';
-import { compressImage } from './utils/media';
-import { getFuzzyScore } from './utils/search';
-import { generateAiProfileSummary, getHistoricalContext, generateAiPortrait } from './services/gemini';
-import Auth from './components/Auth';
-import SplashView from './views/SplashView';
-import TreesView from './views/TreesView';
-import TreeView from './views/TreeView';
-import SelectHomeView from './views/SelectHomeView';
-import ProfileView from './views/ProfileView';
-import EditProfileView from './views/EditProfileView';
-import LinkRelativeView from './views/LinkRelativeView';
-import CreateMemoryView from './views/CreateMemoryView';
-import FamilyCircleView from './views/FamilyCircleView';
-
-
-const App: React.FC = () => {
-  const [toast, setToast] = useState<{ message: string } | null>(null);
-  const [isAiLoading, setIsAiLoading] = useState(false);
-  const [isResearchLoading, setIsResearchLoading] = useState(false);
-  const [isGeneratingPortrait, setIsGeneratingPortrait] = useState(false);
-  const [searchQuery, setSearchQuery] = useState('');
-  const [showSearchResults, setShowSearchResults] = useState(false);
-  const [attachingToEventId, setAttachingToEventId] = useState<string | null>(null);
-
-  const showToast = (message: string) => {
-    setToast({ message });
-    setTimeout(() => setToast(null), 3000);
-  };
-
-  const session = useSession();
-  const store = useArchiveStore(session.user);
-  const { activeProfile, selectedTreeForView } = store;
-
-  const gedcom = useGedcomImport({
-    user: session.user,
-    setView: session.setView,
-    setProfiles: store.setProfiles,
-    setFamilyTrees: store.setFamilyTrees,
-    setSelectedTreeId: store.setSelectedTreeId,
-    setActiveProfileId: store.setActiveProfileId,
-    toast: showToast
-  });
-
-  const editor = useProfileEditor({
-    activeProfile: store.activeProfile,
-    activeProfileId: store.activeProfileId,
-    setProfiles: store.setProfiles,
-    toast: showToast
-  });
-
-  const profilePhotoFileInputRef = useRef<HTMLInputElement>(null);
-  const editPhotoFileInputRef = useRef<HTMLInputElement>(null);
-  const eventFileInputRef = useRef<HTMLInputElement>(null);
-  const searchInputRef = useRef<HTMLInputElement>(null);
-
-  const media = useMediaAttach({
-    user: session.user,
-    activeProfileId: store.activeProfileId,
-    view: session.view,
-    attachingToEventId,
-    setAttachingToEventId,
-    setProfiles: store.setProfiles,
-    setEditImageUrl: editor.setEditImageUrl,
-    toast: showToast
-  });
-
-  const handleLogout = async () => {
-    store.clearAll();
-    await session.logout();
-    showToast('Signed out');
-  };
-
-  
-  
-  const handleGeneratePortrait = async () => {
-    if (!activeProfile) return;
-    setIsGeneratingPortrait(true);
-    showToast("Generating historical portrait...");
-    try {
-      const dataUrl = await generateAiPortrait(activeProfile);
-      store.setProfiles(prev =>
-        prev.map(p => p.id === store.activeProfileId ? { ...p, imageUrl: dataUrl } : p)
-      );
-      showToast("AI Portrait Created");
-    } catch (err) {
-      console.error(err);
-      showToast("Failed to generate portrait");
-    } finally {
-      setIsGeneratingPortrait(false);
-    }
-  };
-
-  const handleGenerateSummary = async () => {
-    if (!activeProfile) return;
-    setIsAiLoading(true);
-    const summary = await generateAiProfileSummary(activeProfile);
-    store.setProfiles(prev => prev.map(p => p.id === store.activeProfileId ? { ...p, summary } : p));
-    setIsAiLoading(false);
-    showToast("AI Summary Generated");
-  };
-
-  const handleResearch = async () => {
-    if (!activeProfile) return;
-    setIsResearchLoading(true);
-    showToast("Mining historical archives...");
-    const context = await getHistoricalContext(activeProfile);
-    store.setProfiles(prev => prev.map(p => p.id === store.activeProfileId ? { ...p, historicalContext: context } : p));
-    setIsResearchLoading(false);
-    showToast("Historical Research Complete");
-  };
-
-  
-  
-  
-  
-  
-  
-  const searchResults = useMemo(() => {
-    const query = searchQuery.trim();
-    if (!query) return [];
-    return store.profiles
-      .map(profile => ({ profile, score: getFuzzyScore(profile.name, query) }))
-      .filter(item => item.score > 0)
-      .sort((a, b) => b.score - a.score)
-      .slice(0, 10)
-      .map(item => item.profile);
-  }, [searchQuery, store.profiles]);
-
-  const sortedTimeline = useMemo(() => {
-    if (!activeProfile) return [];
-    return [...activeProfile.timeline].sort((a, b) => parseGedcomDate(a.date) - parseGedcomDate(b.date));
-  }, [activeProfile]);
-
-  const renderContent = () => {
-    // ── Authoritative auth gate ───────────────────────────────────────────────
-    // SPLASH and LOGIN are the only views that do not require a session.
-    // Every other view case below is only reached when session.user is non-null.
-    // This single check is the source of truth — per-case guards below are
-    // defence-in-depth against future regressions, not primary enforcement.
-    const isPublicView = session.view === AppView.SPLASH || session.view === AppView.LOGIN;
-    if (!isPublicView && !session.user) {
-      // Supabase session is absent. Show login immediately rather than an
-      // empty/broken view. This handles: cold load before getSession resolves,
-      // session expiry mid-session, and any rogue setView() call.
-      return <Auth onLogin={session.login} />;
-    }
-
-    switch (session.view) {
-      case AppView.SPLASH:
-        return <SplashView />;
-
-      case AppView.LOGIN:
-        return <Auth onLogin={session.login} />;
-
-      case AppView.SELECT_HOME:
-        return (
-          <SelectHomeView
-            pendingImport={gedcom.pendingImport}
-            onBack={() => session.setView(AppView.HOME)}
-            onChooseHome={gedcom.chooseHome}
-          />
-        );
-
-      case AppView.TREES:
-        return (
-          <TreesView
-            trees={store.familyTrees}
-            selectedTreeId={store.selectedTreeId}
-            onBack={() => session.setView(AppView.HOME)}
-            onSelectTree={(id) => store.setSelectedTreeId(id)}
-            onOpenTree={(id) => { store.setTreeViewId(id); session.setView(AppView.TREE_VIEW); }}
-          />
-        );
-
-      case AppView.TREE_VIEW:
-        if (!selectedTreeForView) return null;
-        return (
-          <TreeView
-            tree={selectedTreeForView}
-            profiles={store.profiles}
-            onBack={() => session.setView(AppView.TREES)}
-            onOpenProfile={(id) => { store.setActiveProfileId(id); session.setView(AppView.PROFILE); }}
-          />
-        );
-
-
-
-      case AppView.FAMILY_CIRCLE:
-        return (
-          <FamilyCircleView
-            user={session.user!}
-            profiles={store.profiles}
-            posts={store.circlePosts}
-            onBack={() => session.setView(AppView.HOME)}
-            onAddPost={store.addCirclePost}
-            onDeletePost={store.deleteCirclePost}
-            onProfileClick={(profileId) => {
-              store.setActiveProfileId(profileId);
-              session.setView(AppView.PROFILE);
-            }}
-          />
-        );
-
-      case AppView.HOME:
-        return (
-          <div className="flex flex-col h-full bg-[#f9f8f6]">
-            <header className="pt-16 px-8 pb-6 bg-[#f5f2eb] border-b border-stone-200">
-              <div className="flex justify-between items-start mb-6">
-                <div>
-                  <h2 className="text-3xl font-serif text-slate-800">Archive</h2>
-                  <p className="text-stone-400 text-[10px] font-bold uppercase">{session.user?.name}</p>
-                </div>
-                <button onClick={handleLogout} className="p-2 bg-white rounded-full border border-stone-200 text-stone-300 hover:text-red-500"><LogOut size={18} /></button>
-              </div>
-              <div className="relative">
-                <Search className="absolute left-4 top-1/2 -translate-y-1/2 text-stone-300" size={18} />
-                <input
-                  ref={searchInputRef}
-                  value={searchQuery}
-                  onChange={(e) => { setSearchQuery(e.target.value); setShowSearchResults(true); }}
-                  placeholder="Find a family member..."
-                  className="w-full bg-white border border-stone-100 rounded-2xl py-3 pl-12 pr-4 outline-none font-serif shadow-sm focus:ring-2 focus:ring-amber-200"
-                />
-                {showSearchResults && searchQuery.trim() && (
-                  <div className="absolute top-full left-0 right-0 mt-2 bg-white border rounded-2xl shadow-xl z-30 overflow-hidden max-h-96">
-                    {searchResults.length > 0 ? searchResults.map(p => (
-                      <button key={p.id} onClick={() => { store.setActiveProfileId(p.id); session.setView(AppView.PROFILE); setShowSearchResults(false); setSearchQuery(''); }} className="w-full text-left px-4 py-3 hover:bg-stone-50 border-b last:border-0 flex items-center space-x-3">
-                        <img src={p.imageUrl} className="w-10 h-10 rounded-xl object-cover grayscale" />
-                        <div><span className="font-serif text-sm block">{p.name}</span><span className="text-[10px] text-stone-300 uppercase">{p.birthYear} — {p.deathYear || '...'}</span></div>
-                      </button>
-                    )) : <div className="p-8 text-center text-xs font-serif text-stone-300">No records found.</div>}
-                  </div>
-                )}
-              </div>
-            </header>
-            <main className="flex-1 p-8 space-y-8 overflow-y-auto scrollbar-hide pb-20">
-              {store.profiles.length === 0 ? (
-                <div className="py-20 text-center space-y-6">
-                  <GitBranch size={48} className="mx-auto text-stone-200" />
-                  <p className="font-serif text-stone-500 italic">Archive is empty.</p>
-                  {/* Label is only rendered (and the htmlFor association only exists)
-                      when the user is authenticated. An unauthenticated user has no
-                      <input> to trigger, so the label becomes inert even if they
-                      somehow reach this view. */}
-                  {session.user && (
-                    <label htmlFor="gedcomFile" className="bg-stone-900 text-white px-8 py-4 rounded-full font-bold uppercase tracking-widest text-[11px] inline-block cursor-pointer">Import GEDCOM</label>
-                  )}
-                </div>
-              ) : (
-                <section className="space-y-4">
-                  <div className="flex justify-between items-center px-2">
-                    <h3 className="text-[10px] font-bold uppercase tracking-widest text-stone-400">Library</h3>
-                    <div className="flex items-center gap-3">
-                      <button onClick={() => session.setView(AppView.FAMILY_CIRCLE)} className="text-[10px] font-bold uppercase text-amber-600">Circle</button>
-                      <button onClick={() => session.setView(AppView.TREES)} className="text-[10px] font-bold uppercase text-amber-600">Trees</button>
-                    </div>
-                  </div>
-                  <div className="grid gap-3">
-                    {store.profiles.slice(0, 10).map(p => (
-                      <button key={p.id} onClick={() => { store.setActiveProfileId(p.id); session.setView(AppView.PROFILE); }} className="w-full bg-white p-4 rounded-[32px] shadow-sm border border-stone-50 flex items-center space-x-4 hover:shadow-md transition-all">
-                        <img src={p.imageUrl} className="w-14 h-14 rounded-2xl object-cover grayscale" />
-                        <div className="text-left flex-1"><h4 className="font-serif text-xl">{p.name}</h4><p className="text-[10px] text-stone-400 font-black uppercase mt-1">{p.birthYear} — {p.deathYear || '...'}</p></div>
-                        <ChevronRight className="text-stone-200" size={18} />
-                      </button>
-                    ))}
-                  </div>
-                </section>
-              )}
-            </main>
-            {/* The file input is absent from the DOM entirely when unauthenticated.
-                This removes the programmatic .click() attack vector: even if someone
-                calls gedFileInputRef.current?.click() there is no element to click.
-                handleGedcomUpload also independently guards via assertAuthenticated,
-                providing defence-in-depth. */}
-            {session.user && (
-              <input
-                id="gedcomFile"
-                type="file"
-                ref={gedcom.gedFileInputRef}
-                onChange={gedcom.handleGedcomUpload}
-                accept=".ged,.GED,.gedcom,.txt,text/plain"
-                style={{ position: 'absolute', width: 1, height: 1, opacity: 0, pointerEvents: 'none' }}
-              />
-            )}
-          </div>
-        );
-
-      case AppView.PROFILE:
-        if (!activeProfile) return null;
-        return (
-          <ProfileView
-            activeProfile={activeProfile}
-            profiles={store.profiles}
-            familyTrees={store.familyTrees}
-            selectedTreeId={store.selectedTreeId}
-            onBack={() => session.setView(AppView.HOME)}
-            onEdit={() => { editor.startEdit(); session.setView(AppView.EDIT_PROFILE); }}
-            onLinkRelative={(role) => { editor.setLinkRole(role); session.setView(AppView.LINK_RELATIVE); }}
-            onDeleteProfile={() => { const did = editor.deleteProfile(window.confirm); if (did) { if (store.activeProfileId) store.deleteProfileById(store.activeProfileId); session.setView(AppView.HOME); } }}
-            onSetActiveProfile={(id) => { store.setActiveProfileId(id); session.setView(AppView.PROFILE); }}
-            onUploadMediaClick={() => profilePhotoFileInputRef.current?.click()}
-            onMediaFileChange={media.handleProfilePhotoUpload}
-            mediaInputRef={profilePhotoFileInputRef}
-            onEventMediaUpload={media.handleEventMediaUpload}
-            attachingToEventId={attachingToEventId}
-            setAttachingToEventId={setAttachingToEventId}
-            isAiLoading={isAiLoading}
-            isResearchLoading={isResearchLoading}
-            isPhotoLoading={media.isPhotoLoading}
-            isGeneratingPortrait={isGeneratingPortrait}
-            onGenerateSummary={handleGenerateSummary}
-            onResearch={handleResearch}
-            onGeneratePortrait={handleGeneratePortrait}
-            showToast={showToast}
-          />
-        );
-
-
-      case AppView.EDIT_PROFILE:
-        return (
-          <EditProfileView
-            editName={editor.editName}
-            setEditName={editor.setEditName}
-            editGender={editor.editGender}
-            setEditGender={editor.setEditGender}
-            editBirthYear={editor.editBirthYear}
-            setEditBirthYear={editor.setEditBirthYear}
-            editDeathYear={editor.editDeathYear}
-            setEditDeathYear={editor.setEditDeathYear}
-            editImageUrl={editor.editImageUrl}
-            setEditImageUrl={editor.setEditImageUrl}
-            onBack={() => session.setView(AppView.PROFILE)}
-            onSave={() => { editor.saveEdit(); session.setView(AppView.PROFILE); }}
-          />
-        );
-
-
-      case AppView.LINK_RELATIVE:
-        return (
-          <LinkRelativeView
-            linkRole={editor.linkRole}
-            searchQuery={searchQuery}
-            setSearchQuery={setSearchQuery}
-            searchResults={searchResults}
-            onBack={() => session.setView(AppView.PROFILE)}
-            onSelect={(p) => { editor.linkRelative(p); session.setView(AppView.PROFILE); setSearchQuery(''); }}
-          />
-        );
-
-
-      case AppView.CREATE_MEMORY:
-        return (
-          <CreateMemoryView
-            newMemoryInput={editor.newMemoryInput}
-            setNewMemoryInput={editor.setNewMemoryInput}
-            onBack={() => session.setView(AppView.PROFILE)}
-            onSave={() => { editor.saveMemory(); session.setView(AppView.PROFILE); }}
-          />
-        );
-
-
-      default:
-        return null;
-    }
-  };
-
-  return (
-    <div className="min-h-screen bg-[#e5e1d8] flex flex-col items-center justify-center p-4">
-      <div className="relative w-full h-[90vh] md:w-[390px] md:h-[844px] bg-white rounded-[40px] shadow-2xl overflow-hidden border-8 border-stone-800">
-        <div className="w-full h-full relative overflow-hidden">{renderContent()}</div>
-        {toast && (
-          <div className="absolute bottom-10 left-1/2 -translate-x-1/2 z-[200] animate-bounce">
-            <div className="bg-stone-900 text-white px-6 py-3 rounded-full shadow-2xl flex items-center space-x-3 text-[10px] font-bold uppercase"><Check size={14} className="text-emerald-500" /><span>{toast.message}</span></div>
-          </div>
-        )}
-      </div>
-    </div>
-  );
-};
-
-export default App;
\ No newline at end of file
diff -ruN before/Auth.tsx after/Auth.tsx
--- before/Auth.tsx	2026-02-21 02:03:33.758190066 +0000
+++ after/Auth.tsx	1970-01-01 00:00:00.000000000 +0000
@@ -1,192 +0,0 @@
-// components/Auth.tsx
-//
-// Authentication UI backed by Supabase Auth.
-// All credential handling is done server-side by Supabase — no passwords
-// are ever read, stored, or compared in client-side code.
-
-import React, { useState } from 'react';
-import { Anchor, RefreshCw, Eye, EyeOff } from 'lucide-react';
-import type { User } from '../types';
-import { supabase } from '../lib/supabaseClient';
-
-interface AuthProps {
-  // Called with the resolved User after a successful sign-in or sign-up.
-  // useSession.onAuthStateChange also fires, so the view transition happens
-  // from there — this callback lets App.tsx stay consistent.
-  onLogin: (user: User) => void;
-}
-
-const Auth: React.FC<AuthProps> = ({ onLogin }) => {
-  const [email, setEmail] = useState('');
-  const [password, setPassword] = useState('');
-  const [displayName, setDisplayName] = useState('');
-  const [showPassword, setShowPassword] = useState(false);
-  const [isLoading, setIsLoading] = useState(false);
-  const [error, setError] = useState('');
-  const [mode, setMode] = useState<'signin' | 'signup'>('signin');
-
-  const handleSignIn = async () => {
-    if (!email || !password) { setError('Email and password are required.'); return; }
-    setIsLoading(true);
-    setError('');
-
-    const { data, error: sbError } = await supabase.auth.signInWithPassword({
-      email: email.trim(),
-      password,
-    });
-
-    if (sbError || !data.session) {
-      setError(sbError?.message ?? 'Sign in failed. Please try again.');
-      setIsLoading(false);
-      return;
-    }
-
-    // Map Supabase session to our User type.
-    const u: User = {
-      id: data.user.id,
-      email: data.user.email ?? '',
-      name: (data.user.user_metadata?.display_name as string | undefined)
-        ?? data.user.email?.split('@')[0]
-        ?? 'User',
-      createdAt: data.user.created_at,
-    };
-    setIsLoading(false);
-    onLogin(u);
-  };
-
-  const handleSignUp = async () => {
-    if (!email || !password) { setError('Email and password are required.'); return; }
-    if (password.length < 8) { setError('Password must be at least 8 characters.'); return; }
-    setIsLoading(true);
-    setError('');
-
-    const name = displayName.trim() || email.split('@')[0];
-
-    const { data, error: sbError } = await supabase.auth.signUp({
-      email: email.trim(),
-      password,
-      options: {
-        data: { display_name: name },
-      },
-    });
-
-    if (sbError) {
-      setError(sbError.message);
-      setIsLoading(false);
-      return;
-    }
-
-    // Supabase may require email confirmation depending on project settings.
-    // If a session is returned immediately, log the user in now.
-    if (data.session) {
-      const u: User = {
-        id: data.user!.id,
-        email: data.user!.email ?? '',
-        name,
-        createdAt: data.user!.created_at,
-      };
-      setIsLoading(false);
-      onLogin(u);
-    } else {
-      // Email confirmation required — tell the user.
-      setError('');
-      setIsLoading(false);
-      // Reuse error slot for info message (styled below).
-      setError('CHECK_EMAIL');
-    }
-  };
-
-  const isCheckEmail = error === 'CHECK_EMAIL';
-
-  return (
-    <div className="flex flex-col h-full bg-[#f5f2eb] p-8 overflow-y-auto">
-      <header className="mt-16 mb-12 text-center space-y-4">
-        <div className="w-16 h-16 bg-stone-900 rounded-2xl flex items-center justify-center text-white mx-auto shadow-xl">
-          <Anchor size={32} />
-        </div>
-        <h2 className="text-4xl font-serif">Eternal</h2>
-        <p className="text-stone-400 text-xs italic">Family Archive Platform</p>
-      </header>
-
-      {/* Error / info banner */}
-      {error && !isCheckEmail && (
-        <div className="mb-4 p-4 bg-red-50 text-red-700 text-[10px] font-bold uppercase text-center rounded-xl border border-red-100">
-          {error}
-        </div>
-      )}
-      {isCheckEmail && (
-        <div className="mb-4 p-4 bg-amber-50 text-amber-800 text-[10px] font-bold uppercase text-center rounded-xl border border-amber-100">
-          Check your email to confirm your account, then sign in.
-        </div>
-      )}
-
-      {/* Mode toggle */}
-      <div className="flex mb-6 bg-stone-100 rounded-2xl p-1">
-        <button
-          onClick={() => { setMode('signin'); setError(''); }}
-          className={`flex-1 py-2 rounded-xl text-[11px] font-bold uppercase transition-all ${mode === 'signin' ? 'bg-white shadow text-stone-900' : 'text-stone-400'}`}
-        >
-          Sign In
-        </button>
-        <button
-          onClick={() => { setMode('signup'); setError(''); }}
-          className={`flex-1 py-2 rounded-xl text-[11px] font-bold uppercase transition-all ${mode === 'signup' ? 'bg-white shadow text-stone-900' : 'text-stone-400'}`}
-        >
-          Register
-        </button>
-      </div>
-
-      <div className="space-y-4">
-        {mode === 'signup' && (
-          <input
-            type="text"
-            value={displayName}
-            onChange={(e) => setDisplayName(e.target.value)}
-            placeholder="Display name (optional)"
-            className="w-full bg-white border rounded-2xl py-4 px-6 font-serif outline-none shadow-sm text-stone-900 placeholder-stone-400"
-          />
-        )}
-
-        <input
-          type="email"
-          value={email}
-          onChange={(e) => setEmail(e.target.value)}
-          placeholder="Email"
-          autoComplete="email"
-          className="w-full bg-white border rounded-2xl py-4 px-6 font-serif outline-none shadow-sm text-stone-900 placeholder-stone-400"
-        />
-
-        <div className="relative">
-          <input
-            type={showPassword ? 'text' : 'password'}
-            value={password}
-            onChange={(e) => setPassword(e.target.value)}
-            onKeyDown={(e) => e.key === 'Enter' && (mode === 'signin' ? handleSignIn() : handleSignUp())}
-            placeholder="Password"
-            autoComplete={mode === 'signup' ? 'new-password' : 'current-password'}
-            className="w-full bg-white border rounded-2xl py-4 px-6 font-serif outline-none shadow-sm text-stone-900 placeholder-stone-400"
-          />
-          <button
-            type="button"
-            onClick={() => setShowPassword(!showPassword)}
-            className="absolute right-4 top-1/2 -translate-y-1/2 text-stone-300"
-          >
-            {showPassword ? <Eye size={18} /> : <EyeOff size={18} />}
-          </button>
-        </div>
-
-        <button
-          onClick={mode === 'signin' ? handleSignIn : handleSignUp}
-          disabled={isLoading}
-          className="w-full bg-stone-900 text-white py-5 rounded-2xl font-bold uppercase text-[11px] shadow-lg flex items-center justify-center space-x-2 disabled:opacity-60"
-        >
-          {isLoading
-            ? <RefreshCw className="animate-spin" size={16} />
-            : <span>{mode === 'signin' ? 'Sign In' : 'Create Account'}</span>}
-        </button>
-      </div>
-    </div>
-  );
-};
-
-export default Auth;
diff -ruN before/api/gemini.ts after/api/gemini.ts
--- before/api/gemini.ts	1970-01-01 00:00:00.000000000 +0000
+++ after/api/gemini.ts	2026-02-21 02:03:47.063189967 +0000
@@ -0,0 +1,199 @@
+// api/gemini.ts — Vercel serverless function
+// Runs exclusively on the server; GEMINI_API_KEY never reaches the browser.
+//
+// POST /api/gemini
+// Body: GeminiRequest (discriminated union on `action`)
+// Response: GeminiResponse | ErrorResponse
+//
+// All three Gemini call-sites from the original client code are handled here:
+//   "summary"   — narrative profile biography   (gemini-2.0-flash)
+//   "research"  — grounded historical context   (gemini-2.5-pro-preview-05-06)
+//   "portrait"  — image generation              (gemini-2.0-flash-preview-image-generation)
+
+import type { VercelRequest, VercelResponse } from '@vercel/node';
+import { GoogleGenAI } from '@google/genai';
+
+// ── Request / response shapes (kept in sync with services/gemini.ts) ─────────
+
+type GeminiRequest =
+  | { action: 'summary';   prompt: string }
+  | { action: 'research';  prompt: string }
+  | { action: 'portrait';  prompt: string };
+
+type GeminiResponse =
+  | { text: string }                              // summary / research
+  | { imageBase64: string }                       // portrait
+  | { text: string; sources: GroundingSource[] }; // research with grounding
+
+interface GroundingSource {
+  web?: { uri: string; title: string };
+}
+
+interface ErrorResponse {
+  error: string;
+}
+
+// ── Validation ───────────────────────────────────────────────────────────────
+
+const VALID_ACTIONS = new Set(['summary', 'research', 'portrait']);
+const MAX_PROMPT_LENGTH = 8_000; // characters — well under Gemini input limits
+
+function validate(body: unknown): GeminiRequest {
+  if (!body || typeof body !== 'object') {
+    throw new RequestError(400, 'Request body must be a JSON object.');
+  }
+
+  const { action, prompt } = body as Record<string, unknown>;
+
+  if (typeof action !== 'string' || !VALID_ACTIONS.has(action)) {
+    throw new RequestError(
+      400,
+      `"action" must be one of: ${[...VALID_ACTIONS].join(', ')}.`
+    );
+  }
+
+  if (typeof prompt !== 'string' || prompt.trim().length === 0) {
+    throw new RequestError(400, '"prompt" must be a non-empty string.');
+  }
+
+  if (prompt.length > MAX_PROMPT_LENGTH) {
+    throw new RequestError(
+      400,
+      `"prompt" exceeds the maximum length of ${MAX_PROMPT_LENGTH} characters.`
+    );
+  }
+
+  return { action, prompt } as GeminiRequest;
+}
+
+class RequestError extends Error {
+  constructor(public readonly status: number, message: string) {
+    super(message);
+  }
+}
+
+// ── Gemini helpers ────────────────────────────────────────────────────────────
+
+async function runSummary(ai: GoogleGenAI, prompt: string): Promise<{ text: string }> {
+  const response = await ai.models.generateContent({
+    model: 'gemini-2.0-flash',
+    contents: prompt,
+  });
+  return { text: response.text ?? 'Summary unavailable.' };
+}
+
+async function runResearch(
+  ai: GoogleGenAI,
+  prompt: string
+): Promise<{ text: string; sources: GroundingSource[] }> {
+  const response = await ai.models.generateContent({
+    model: 'gemini-2.5-pro-preview-05-06',
+    contents: prompt,
+    config: {
+      tools: [{ googleSearch: {} }],
+    },
+  });
+
+  const sources: GroundingSource[] =
+    response.candidates?.[0]?.groundingMetadata?.groundingChunks ?? [];
+
+  return {
+    text: response.text ?? 'Historical research unavailable.',
+    sources,
+  };
+}
+
+async function runPortrait(
+  ai: GoogleGenAI,
+  prompt: string
+): Promise<{ imageBase64: string }> {
+  const response = await ai.models.generateContent({
+    model: 'gemini-2.0-flash-preview-image-generation',
+    contents: [{ parts: [{ text: prompt }] }],
+  });
+
+  const candidates = response.candidates ?? [];
+  for (const candidate of candidates) {
+    for (const part of candidate.content?.parts ?? []) {
+      if (part.inlineData?.data) {
+        return { imageBase64: part.inlineData.data };
+      }
+    }
+  }
+
+  throw new RequestError(502, 'Gemini did not return an image.');
+}
+
+// ── Dispatch ──────────────────────────────────────────────────────────────────
+// Extracted from the handler body so TypeScript can prove the return type is
+// always assigned. Each branch returns directly, eliminating the
+// "Variable 'result' used before assigned" risk from a bare `let result`.
+
+async function dispatch(ai: GoogleGenAI, request: GeminiRequest): Promise<GeminiResponse> {
+  switch (request.action) {
+    case 'summary':
+      return runSummary(ai, request.prompt);
+    case 'research':
+      return runResearch(ai, request.prompt);
+    case 'portrait':
+      return runPortrait(ai, request.prompt);
+    default: {
+      // TypeScript exhaustiveness guard — should never be reached because
+      // validate() only allows the three known actions.
+      const _exhaustive: never = request;
+      throw new RequestError(400, `Unknown action: ${(_exhaustive as any).action}`);
+    }
+  }
+}
+
+// ── Handler ───────────────────────────────────────────────────────────────────
+
+export default async function handler(
+  req: VercelRequest,
+  res: VercelResponse
+): Promise<void> {
+  // Only accept POST.
+  if (req.method !== 'POST') {
+    res.setHeader('Allow', 'POST');
+    res.status(405).json({ error: 'Method not allowed.' } satisfies ErrorResponse);
+    return;
+  }
+
+  // Guard: key must exist at runtime (set in Vercel dashboard / .env.local).
+  const apiKey = process.env.GEMINI_API_KEY;
+  if (!apiKey) {
+    console.error('[/api/gemini] GEMINI_API_KEY is not set.');
+    res.status(500).json({
+      error: 'Server misconfiguration: AI service is unavailable.',
+    } satisfies ErrorResponse);
+    return;
+  }
+
+  let request: GeminiRequest;
+  try {
+    request = validate(req.body);
+  } catch (err) {
+    const { status, message } =
+      err instanceof RequestError ? err : { status: 400, message: String(err) };
+    res.status(status).json({ error: message } satisfies ErrorResponse);
+    return;
+  }
+
+  const ai = new GoogleGenAI({ apiKey });
+
+  try {
+    const result = await dispatch(ai, request);
+    res.status(200).json(result);
+  } catch (err) {
+    if (err instanceof RequestError) {
+      res.status(err.status).json({ error: err.message } satisfies ErrorResponse);
+      return;
+    }
+
+    // Log the real error server-side but don't leak internals to the client.
+    console.error('[/api/gemini] Gemini API error:', err);
+    res.status(502).json({
+      error: 'The AI service returned an error. Please try again.',
+    } satisfies ErrorResponse);
+  }
+}
diff -ruN before/api.gemini.ts after/api.gemini.ts
--- before/api.gemini.ts	2026-02-21 02:03:33.789190066 +0000
+++ after/api.gemini.ts	1970-01-01 00:00:00.000000000 +0000
@@ -1,199 +0,0 @@
-// api/gemini.ts — Vercel serverless function
-// Runs exclusively on the server; GEMINI_API_KEY never reaches the browser.
-//
-// POST /api/gemini
-// Body: GeminiRequest (discriminated union on `action`)
-// Response: GeminiResponse | ErrorResponse
-//
-// All three Gemini call-sites from the original client code are handled here:
-//   "summary"   — narrative profile biography   (gemini-2.0-flash)
-//   "research"  — grounded historical context   (gemini-2.5-pro-preview-05-06)
-//   "portrait"  — image generation              (gemini-2.0-flash-preview-image-generation)
-
-import type { VercelRequest, VercelResponse } from '@vercel/node';
-import { GoogleGenAI } from '@google/genai';
-
-// ── Request / response shapes (kept in sync with services/gemini.ts) ─────────
-
-type GeminiRequest =
-  | { action: 'summary';   prompt: string }
-  | { action: 'research';  prompt: string }
-  | { action: 'portrait';  prompt: string };
-
-type GeminiResponse =
-  | { text: string }                              // summary / research
-  | { imageBase64: string }                       // portrait
-  | { text: string; sources: GroundingSource[] }; // research with grounding
-
-interface GroundingSource {
-  web?: { uri: string; title: string };
-}
-
-interface ErrorResponse {
-  error: string;
-}
-
-// ── Validation ───────────────────────────────────────────────────────────────
-
-const VALID_ACTIONS = new Set(['summary', 'research', 'portrait']);
-const MAX_PROMPT_LENGTH = 8_000; // characters — well under Gemini input limits
-
-function validate(body: unknown): GeminiRequest {
-  if (!body || typeof body !== 'object') {
-    throw new RequestError(400, 'Request body must be a JSON object.');
-  }
-
-  const { action, prompt } = body as Record<string, unknown>;
-
-  if (typeof action !== 'string' || !VALID_ACTIONS.has(action)) {
-    throw new RequestError(
-      400,
-      `"action" must be one of: ${[...VALID_ACTIONS].join(', ')}.`
-    );
-  }
-
-  if (typeof prompt !== 'string' || prompt.trim().length === 0) {
-    throw new RequestError(400, '"prompt" must be a non-empty string.');
-  }
-
-  if (prompt.length > MAX_PROMPT_LENGTH) {
-    throw new RequestError(
-      400,
-      `"prompt" exceeds the maximum length of ${MAX_PROMPT_LENGTH} characters.`
-    );
-  }
-
-  return { action, prompt } as GeminiRequest;
-}
-
-class RequestError extends Error {
-  constructor(public readonly status: number, message: string) {
-    super(message);
-  }
-}
-
-// ── Gemini helpers ────────────────────────────────────────────────────────────
-
-async function runSummary(ai: GoogleGenAI, prompt: string): Promise<{ text: string }> {
-  const response = await ai.models.generateContent({
-    model: 'gemini-2.0-flash',
-    contents: prompt,
-  });
-  return { text: response.text ?? 'Summary unavailable.' };
-}
-
-async function runResearch(
-  ai: GoogleGenAI,
-  prompt: string
-): Promise<{ text: string; sources: GroundingSource[] }> {
-  const response = await ai.models.generateContent({
-    model: 'gemini-2.5-pro-preview-05-06',
-    contents: prompt,
-    config: {
-      tools: [{ googleSearch: {} }],
-    },
-  });
-
-  const sources: GroundingSource[] =
-    response.candidates?.[0]?.groundingMetadata?.groundingChunks ?? [];
-
-  return {
-    text: response.text ?? 'Historical research unavailable.',
-    sources,
-  };
-}
-
-async function runPortrait(
-  ai: GoogleGenAI,
-  prompt: string
-): Promise<{ imageBase64: string }> {
-  const response = await ai.models.generateContent({
-    model: 'gemini-2.0-flash-preview-image-generation',
-    contents: [{ parts: [{ text: prompt }] }],
-  });
-
-  const candidates = response.candidates ?? [];
-  for (const candidate of candidates) {
-    for (const part of candidate.content?.parts ?? []) {
-      if (part.inlineData?.data) {
-        return { imageBase64: part.inlineData.data };
-      }
-    }
-  }
-
-  throw new RequestError(502, 'Gemini did not return an image.');
-}
-
-// ── Dispatch ──────────────────────────────────────────────────────────────────
-// Extracted from the handler body so TypeScript can prove the return type is
-// always assigned. Each branch returns directly, eliminating the
-// "Variable 'result' used before assigned" risk from a bare `let result`.
-
-async function dispatch(ai: GoogleGenAI, request: GeminiRequest): Promise<GeminiResponse> {
-  switch (request.action) {
-    case 'summary':
-      return runSummary(ai, request.prompt);
-    case 'research':
-      return runResearch(ai, request.prompt);
-    case 'portrait':
-      return runPortrait(ai, request.prompt);
-    default: {
-      // TypeScript exhaustiveness guard — should never be reached because
-      // validate() only allows the three known actions.
-      const _exhaustive: never = request;
-      throw new RequestError(400, `Unknown action: ${(_exhaustive as any).action}`);
-    }
-  }
-}
-
-// ── Handler ───────────────────────────────────────────────────────────────────
-
-export default async function handler(
-  req: VercelRequest,
-  res: VercelResponse
-): Promise<void> {
-  // Only accept POST.
-  if (req.method !== 'POST') {
-    res.setHeader('Allow', 'POST');
-    res.status(405).json({ error: 'Method not allowed.' } satisfies ErrorResponse);
-    return;
-  }
-
-  // Guard: key must exist at runtime (set in Vercel dashboard / .env.local).
-  const apiKey = process.env.GEMINI_API_KEY;
-  if (!apiKey) {
-    console.error('[/api/gemini] GEMINI_API_KEY is not set.');
-    res.status(500).json({
-      error: 'Server misconfiguration: AI service is unavailable.',
-    } satisfies ErrorResponse);
-    return;
-  }
-
-  let request: GeminiRequest;
-  try {
-    request = validate(req.body);
-  } catch (err) {
-    const { status, message } =
-      err instanceof RequestError ? err : { status: 400, message: String(err) };
-    res.status(status).json({ error: message } satisfies ErrorResponse);
-    return;
-  }
-
-  const ai = new GoogleGenAI({ apiKey });
-
-  try {
-    const result = await dispatch(ai, request);
-    res.status(200).json(result);
-  } catch (err) {
-    if (err instanceof RequestError) {
-      res.status(err.status).json({ error: err.message } satisfies ErrorResponse);
-      return;
-    }
-
-    // Log the real error server-side but don't leak internals to the client.
-    console.error('[/api/gemini] Gemini API error:', err);
-    res.status(502).json({
-      error: 'The AI service returned an error. Please try again.',
-    } satisfies ErrorResponse);
-  }
-}
diff -ruN before/assertAuthenticated.test.ts after/assertAuthenticated.test.ts
--- before/assertAuthenticated.test.ts	2026-02-21 02:03:33.804190066 +0000
+++ after/assertAuthenticated.test.ts	1970-01-01 00:00:00.000000000 +0000
@@ -1,92 +0,0 @@
-// utils/assertAuthenticated.test.ts
-//
-// Run with:  npx vitest run utils/assertAuthenticated.test.ts
-// Or:        npx jest utils/assertAuthenticated.test.ts
-//
-// No React, no Supabase, no network — pure unit tests.
-
-import { describe, it, expect } from 'vitest';
-import { assertAuthenticated, AuthenticationError } from './assertAuthenticated';
-
-// Minimal user stub — only `id` matters for the guard.
-const validUser = { id: 'user-abc-123', email: 'test@example.com', name: 'Test', createdAt: '' };
-
-describe('assertAuthenticated', () => {
-  // ── Should NOT throw (authenticated) ──────────────────────────────────────
-
-  it('does not throw when user has a valid id', () => {
-    expect(() => assertAuthenticated(validUser)).not.toThrow();
-  });
-
-  it('does not throw when called with context and a valid user', () => {
-    expect(() => assertAuthenticated(validUser, 'GEDCOM upload')).not.toThrow();
-  });
-
-  // ── Should throw (unauthenticated) ────────────────────────────────────────
-
-  it('throws AuthenticationError when user is null', () => {
-    expect(() => assertAuthenticated(null)).toThrow(AuthenticationError);
-  });
-
-  it('throws AuthenticationError when user is undefined', () => {
-    expect(() => assertAuthenticated(undefined)).toThrow(AuthenticationError);
-  });
-
-  it('throws AuthenticationError when user.id is empty string', () => {
-    expect(() => assertAuthenticated({ id: '' })).toThrow(AuthenticationError);
-  });
-
-  // ── Error shape ───────────────────────────────────────────────────────────
-
-  it('error has code NOT_AUTHENTICATED', () => {
-    try {
-      assertAuthenticated(null);
-      expect.fail('should have thrown');
-    } catch (err) {
-      expect(err).toBeInstanceOf(AuthenticationError);
-      expect((err as AuthenticationError).code).toBe('NOT_AUTHENTICATED');
-    }
-  });
-
-  it('error message includes the context when provided', () => {
-    try {
-      assertAuthenticated(null, 'GEDCOM upload');
-      expect.fail('should have thrown');
-    } catch (err) {
-      expect((err as AuthenticationError).message).toContain('GEDCOM upload');
-    }
-  });
-
-  it('error message does not mention context when not provided', () => {
-    try {
-      assertAuthenticated(null);
-      expect.fail('should have thrown');
-    } catch (err) {
-      const msg = (err as AuthenticationError).message;
-      // Should be a clean sentence ending in a period, no parenthetical
-      expect(msg).toMatch(/signed in/i);
-      expect(msg).not.toContain('(');
-    }
-  });
-
-  it('error name is AuthenticationError', () => {
-    try {
-      assertAuthenticated(null);
-      expect.fail('should have thrown');
-    } catch (err) {
-      expect((err as Error).name).toBe('AuthenticationError');
-    }
-  });
-
-  // ── TypeScript narrowing (compile-time, verified by type assertions below) ─
-
-  it('narrows the type to { id: string } after the call', () => {
-    // This test is primarily a compile-time check. If TypeScript is happy,
-    // the `asserts` return type is working correctly.
-    const user: { id: string } | null = validUser;
-    assertAuthenticated(user);
-    // After this line, TypeScript knows user is { id: string }, not null.
-    // We verify it at runtime by accessing .id without a null check:
-    expect(user.id).toBe('user-abc-123');
-  });
-});
diff -ruN before/assertAuthenticated.ts after/assertAuthenticated.ts
--- before/assertAuthenticated.ts	2026-02-21 02:03:33.818190066 +0000
+++ after/assertAuthenticated.ts	1970-01-01 00:00:00.000000000 +0000
@@ -1,51 +0,0 @@
-// utils/assertAuthenticated.ts
-//
-// A pure, framework-free guard that enforces session presence before any
-// privileged operation executes. Because it has no React or Supabase
-// dependencies it can be imported in unit tests without mocking anything.
-//
-// Usage:
-//   assertAuthenticated(session.user);           // throws on !user
-//   assertAuthenticated(session.user, 'upload'); // throws with context
-//
-// The thrown AuthenticationError is caught at the call-site and its
-// `.message` is shown to the user via toast / UI, not console only.
-
-export class AuthenticationError extends Error {
-  readonly code = 'NOT_AUTHENTICATED' as const;
-
-  constructor(context?: string) {
-    const where = context ? ` (${context})` : '';
-    super(`You must be signed in to perform this action${where}.`);
-    this.name = 'AuthenticationError';
-  }
-}
-
-/**
- * Assert that `user` is non-null and non-undefined.
- * Throws `AuthenticationError` if the assertion fails.
- *
- * @param user       - The current session user, or null/undefined.
- * @param context    - Optional label included in the error message for
- *                     easier debugging (e.g. "GEDCOM upload").
- *
- * @example
- * // Handler — throws before any privileged work starts:
- * function handleGedcomUpload(user: User | null, file: File) {
- *   assertAuthenticated(user, 'GEDCOM upload');
- *   // ...safe to proceed
- * }
- *
- * @example
- * // Test:
- * expect(() => assertAuthenticated(null)).toThrow(AuthenticationError);
- * expect(() => assertAuthenticated({ id: '1', ... })).not.toThrow();
- */
-export function assertAuthenticated(
-  user: { id: string } | null | undefined,
-  context?: string
-): asserts user is { id: string } {
-  if (!user || !user.id) {
-    throw new AuthenticationError(context);
-  }
-}
diff -ruN before/components/Auth.tsx after/components/Auth.tsx
--- before/components/Auth.tsx	2026-02-21 02:03:33.832190066 +0000
+++ after/components/Auth.tsx	1970-01-01 00:00:00.000000000 +0000
@@ -1,80 +0,0 @@
-
-import React, { useState } from 'react';
-import { Anchor, RefreshCw, Eye, EyeOff, Check } from 'lucide-react';
-import { User } from '../types';
-import { STORAGE_KEYS } from '../constants';
-
-interface AuthProps {
-  onLogin: (user: User) => void;
-}
-
-const Auth: React.FC<AuthProps> = ({ onLogin }) => {
-  const [email, setEmail] = useState('');
-  const [password, setPassword] = useState('');
-  const [showPassword, setShowPassword] = useState(false);
-  const [isAuthLoading, setIsAuthLoading] = useState(false);
-  const [error, setError] = useState('');
-
-  const handleAction = (isRegister: boolean) => {
-    if (!email || !password) {
-      setError('Required fields missing.');
-      return;
-    }
-    setIsAuthLoading(true);
-    setError('');
-    setTimeout(() => {
-      const users = JSON.parse(localStorage.getItem(STORAGE_KEYS.USERS) || '[]');
-      if (isRegister) {
-        if (users.find((u: any) => u.email === email)) {
-          setError('User already exists');
-          setIsAuthLoading(false);
-          return;
-        }
-        const newUser: User = { id: `u-${Date.now()}`, email, name: email.split('@')[0], createdAt: new Date().toISOString() };
-        users.push({ ...newUser, password });
-        localStorage.setItem(STORAGE_KEYS.USERS, JSON.stringify(users));
-        localStorage.setItem(STORAGE_KEYS.CURRENT_USER, JSON.stringify(newUser));
-        onLogin(newUser);
-      } else {
-        const user = users.find((u: any) => u.email === email && u.password === password);
-        if (!user) {
-          setError('Invalid credentials');
-          setIsAuthLoading(false);
-          return;
-        }
-        const userClean = { id: user.id, email: user.email, name: user.name, createdAt: user.createdAt };
-        localStorage.setItem(STORAGE_KEYS.CURRENT_USER, JSON.stringify(userClean));
-        onLogin(userClean);
-      }
-      setIsAuthLoading(false);
-    }, 1000);
-  };
-
-  return (
-    <div className="flex flex-col h-full bg-[#f5f2eb] p-8 overflow-y-auto">
-      <header className="mt-16 mb-12 text-center space-y-4">
-        <div className="w-16 h-16 bg-stone-900 rounded-2xl flex items-center justify-center text-white mx-auto shadow-xl"><Anchor size={32} /></div>
-        <h2 className="text-4xl font-serif">Eternal</h2>
-        <p className="text-stone-400 text-xs italic">Family Archive Platform</p>
-      </header>
-
-      {error && <div className="mb-4 p-4 bg-red-50 text-red-700 text-[10px] font-bold uppercase text-center rounded-xl border border-red-100">{error}</div>}
-
-      <form className="space-y-4" onSubmit={(e) => e.preventDefault()}>
-        <input type="email" value={email} onChange={(e) => setEmail(e.target.value)} placeholder="Email" className="w-full bg-white border rounded-2xl py-4 px-6 font-serif outline-none shadow-sm text-stone-900 placeholder-stone-400" />
-        <div className="relative">
-          <input type={showPassword ? "text" : "password"} value={password} onChange={(e) => setPassword(e.target.value)} placeholder="Password" className="w-full bg-white border rounded-2xl py-4 px-6 font-serif outline-none shadow-sm text-stone-900 placeholder-stone-400" />
-          <button type="button" onClick={() => setShowPassword(!showPassword)} className="absolute right-4 top-1/2 -translate-y-1/2 text-stone-300">{showPassword ? <Eye size={18} /> : <EyeOff size={18} />}</button>
-        </div>
-        <div className="flex gap-2 pt-4">
-          <button onClick={() => handleAction(false)} className="flex-1 bg-stone-900 text-white py-5 rounded-2xl font-bold uppercase text-[11px] shadow-lg flex items-center justify-center space-x-2">
-            {isAuthLoading ? <RefreshCw className="animate-spin" size={16} /> : <span>Sign In</span>}
-          </button>
-          <button onClick={() => handleAction(true)} className="flex-1 bg-amber-600 text-white py-5 rounded-2xl font-bold uppercase text-[11px] shadow-lg">Register</button>
-        </div>
-      </form>
-    </div>
-  );
-};
-
-export default Auth;
diff -ruN before/components/ErrorBoundary.tsx after/components/ErrorBoundary.tsx
--- before/components/ErrorBoundary.tsx	2026-02-21 02:03:33.846190065 +0000
+++ after/components/ErrorBoundary.tsx	1970-01-01 00:00:00.000000000 +0000
@@ -1,34 +0,0 @@
-import React from 'react';
-
-type Props = { children: React.ReactNode };
-type State = { error: Error | null };
-
-export default class ErrorBoundary extends React.Component<Props, State> {
-  state: State = { error: null };
-
-  static getDerivedStateFromError(error: Error): State {
-    return { error };
-  }
-
-  componentDidCatch(error: Error, info: React.ErrorInfo) {
-    // eslint-disable-next-line no-console
-    console.error('ErrorBoundary caught error', error, info);
-  }
-
-  render() {
-    if (this.state.error) {
-      return (
-        <div className="min-h-screen bg-[#f9f8f6] p-8">
-          <h1 className="text-xl font-bold text-slate-900">Something went wrong</h1>
-          <p className="mt-2 text-sm text-slate-600">
-            The app hit a runtime error right after an action. Open your browser console for details.
-          </p>
-          <pre className="mt-6 whitespace-pre-wrap rounded-xl bg-white p-4 text-xs text-slate-900 border border-stone-200 overflow-auto">
-{String(this.state.error.message || this.state.error)}
-          </pre>
-        </div>
-      );
-    }
-    return this.props.children;
-  }
-}
diff -ruN before/components/circle/CircleFeed.tsx after/components/circle/CircleFeed.tsx
--- before/components/circle/CircleFeed.tsx	2026-02-21 02:03:33.860190065 +0000
+++ after/components/circle/CircleFeed.tsx	1970-01-01 00:00:00.000000000 +0000
@@ -1,176 +0,0 @@
-import React, { useState } from 'react';
-import { Trash2, Image, FileText, Music, Video, ChevronDown, ChevronUp } from 'lucide-react';
-import { CircleAttachment, CirclePost, Profile } from '../../types';
-
-interface CircleFeedProps {
-  posts: CirclePost[];
-  profiles: Profile[];
-  currentUserId: string;
-  onDeletePost: (id: string) => void;
-  onProfileClick: (profileId: string) => void;
-}
-
-const formatRelativeTime = (iso: string): string => {
-  const diff = Date.now() - new Date(iso).getTime();
-  const mins = Math.floor(diff / 60000);
-  if (mins < 1) return 'Just now';
-  if (mins < 60) return `${mins}m ago`;
-  const hrs = Math.floor(mins / 60);
-  if (hrs < 24) return `${hrs}h ago`;
-  const days = Math.floor(hrs / 24);
-  if (days < 7) return `${days}d ago`;
-  return new Date(iso).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
-};
-
-const AttachmentKindIcon = ({ kind }: { kind: CircleAttachment['kind'] }) => {
-  if (kind === 'photo') return <Image size={12} />;
-  if (kind === 'video') return <Video size={12} />;
-  if (kind === 'audio') return <Music size={12} />;
-  return <FileText size={12} />;
-};
-
-const PostCard: React.FC<{
-  post: CirclePost;
-  profiles: Profile[];
-  isOwn: boolean;
-  onDelete: () => void;
-  onProfileClick: (id: string) => void;
-}> = ({ post, profiles, isOwn, onDelete, onProfileClick }) => {
-  const [expanded, setExpanded] = useState(false);
-  const tagged = profiles.filter((p) => post.taggedProfileIds.includes(p.id));
-  const photoAttachments = post.attachments.filter((a) => a.kind === 'photo');
-  const otherAttachments = post.attachments.filter((a) => a.kind !== 'photo');
-
-  const bodyIsLong = post.body.length > 200;
-  const displayBody = bodyIsLong && !expanded ? post.body.slice(0, 200) + '…' : post.body;
-
-  return (
-    <div className="bg-white rounded-[24px] border border-stone-100 shadow-sm overflow-hidden">
-      {/* Header */}
-      <div className="flex items-center justify-between px-5 pt-5 pb-3">
-        <div className="flex items-center gap-3">
-          <div className="w-8 h-8 rounded-xl bg-amber-100 flex items-center justify-center flex-shrink-0">
-            <span className="text-amber-700 text-[10px] font-black uppercase">
-              {post.authorLabel.charAt(0)}
-            </span>
-          </div>
-          <div>
-            <span className="text-[12px] font-bold text-slate-700 block">{post.authorLabel}</span>
-            <span className="text-[10px] text-stone-400">{formatRelativeTime(post.createdAt)}</span>
-          </div>
-        </div>
-        {isOwn && (
-          <button
-            onClick={onDelete}
-            className="text-stone-200 hover:text-red-400 transition-colors p-1"
-            title="Delete post"
-          >
-            <Trash2 size={14} />
-          </button>
-        )}
-      </div>
-
-      {/* Body */}
-      {post.body && (
-        <div className="px-5 pb-3">
-          <p className="font-serif text-[14px] text-slate-700 leading-relaxed whitespace-pre-wrap">{displayBody}</p>
-          {bodyIsLong && (
-            <button
-              onClick={() => setExpanded(!expanded)}
-              className="flex items-center gap-1 mt-1 text-[10px] font-bold uppercase tracking-wider text-amber-600 hover:text-amber-800"
-            >
-              {expanded ? <><ChevronUp size={10} /> Show less</> : <><ChevronDown size={10} /> Read more</>}
-            </button>
-          )}
-        </div>
-      )}
-
-      {/* Photo grid */}
-      {photoAttachments.length > 0 && (
-        <div className={`grid gap-0.5 mb-0.5 ${photoAttachments.length === 1 ? 'grid-cols-1' : 'grid-cols-2'}`}>
-          {photoAttachments.slice(0, 4).map((att, i) => (
-            <div key={att.id} className="relative aspect-square">
-              <img src={att.dataUrl} alt={att.name} className="w-full h-full object-cover" />
-              {i === 3 && photoAttachments.length > 4 && (
-                <div className="absolute inset-0 bg-black/50 flex items-center justify-center">
-                  <span className="text-white font-bold text-lg">+{photoAttachments.length - 4}</span>
-                </div>
-              )}
-            </div>
-          ))}
-        </div>
-      )}
-
-      {/* Other attachments */}
-      {otherAttachments.length > 0 && (
-        <div className="px-5 pb-3 space-y-1.5">
-          {otherAttachments.map((att) => (
-            <div
-              key={att.id}
-              className="flex items-center gap-2 bg-stone-50 rounded-xl px-3 py-2 text-stone-500"
-            >
-              <AttachmentKindIcon kind={att.kind} />
-              <span className="text-[11px] font-serif truncate flex-1">{att.name}</span>
-              {att.size && (
-                <span className="text-[9px] text-stone-300">
-                  {(att.size / 1024).toFixed(0)}KB
-                </span>
-              )}
-            </div>
-          ))}
-        </div>
-      )}
-
-      {/* Tagged people */}
-      {tagged.length > 0 && (
-        <div className="px-5 pb-4 pt-1 flex flex-wrap gap-1.5">
-          <span className="text-[10px] text-stone-400 self-center mr-0.5">with</span>
-          {tagged.map((p) => (
-            <button
-              key={p.id}
-              onClick={() => onProfileClick(p.id)}
-              className="inline-flex items-center gap-1.5 bg-stone-100 hover:bg-amber-100 text-stone-600 hover:text-amber-800 text-[10px] font-bold uppercase tracking-wider px-2.5 py-1 rounded-full transition-colors"
-            >
-              <img src={p.imageUrl} alt={p.name} className="w-4 h-4 rounded-md object-cover grayscale" />
-              {p.name.split(' ')[0]}
-            </button>
-          ))}
-        </div>
-      )}
-    </div>
-  );
-};
-
-export const CircleFeed: React.FC<CircleFeedProps> = ({
-  posts,
-  profiles,
-  currentUserId,
-  onDeletePost,
-  onProfileClick
-}) => {
-  if (posts.length === 0) {
-    return (
-      <div className="py-16 text-center space-y-3">
-        <div className="w-14 h-14 rounded-full bg-stone-100 flex items-center justify-center mx-auto">
-          <span className="text-2xl">🌿</span>
-        </div>
-        <p className="font-serif text-stone-400 italic text-sm">The circle is quiet. Share the first memory.</p>
-      </div>
-    );
-  }
-
-  return (
-    <div className="space-y-4">
-      {posts.map((post) => (
-        <PostCard
-          key={post.id}
-          post={post}
-          profiles={profiles}
-          isOwn={post.userId === currentUserId}
-          onDelete={() => onDeletePost(post.id)}
-          onProfileClick={onProfileClick}
-        />
-      ))}
-    </div>
-  );
-};
diff -ruN before/components/circle/PersonPicker.tsx after/components/circle/PersonPicker.tsx
--- before/components/circle/PersonPicker.tsx	2026-02-21 02:03:33.875190065 +0000
+++ after/components/circle/PersonPicker.tsx	1970-01-01 00:00:00.000000000 +0000
@@ -1,110 +0,0 @@
-import React, { useState, useRef, useEffect } from 'react';
-import { X, Search, User } from 'lucide-react';
-import { Profile } from '../../types';
-import { getFuzzyScore } from '../../utils/search';
-
-interface PersonPickerProps {
-  profiles: Profile[];
-  selectedIds: string[];
-  onChange: (ids: string[]) => void;
-}
-
-export const PersonPicker: React.FC<PersonPickerProps> = ({ profiles, selectedIds, onChange }) => {
-  const [query, setQuery] = useState('');
-  const [open, setOpen] = useState(false);
-  const containerRef = useRef<HTMLDivElement>(null);
-
-  const results = query.trim()
-    ? profiles
-        .map((p) => ({ p, score: getFuzzyScore(p.name, query) }))
-        .filter((x) => x.score > 0)
-        .sort((a, b) => b.score - a.score)
-        .slice(0, 8)
-        .map((x) => x.p)
-    : [];
-
-  const selected = profiles.filter((p) => selectedIds.includes(p.id));
-
-  const toggle = (id: string) => {
-    onChange(selectedIds.includes(id) ? selectedIds.filter((x) => x !== id) : [...selectedIds, id]);
-  };
-
-  // Close on outside click
-  useEffect(() => {
-    const handler = (e: MouseEvent) => {
-      if (containerRef.current && !containerRef.current.contains(e.target as Node)) {
-        setOpen(false);
-      }
-    };
-    document.addEventListener('mousedown', handler);
-    return () => document.removeEventListener('mousedown', handler);
-  }, []);
-
-  return (
-    <div ref={containerRef} className="relative">
-      {/* Selected chips */}
-      {selected.length > 0 && (
-        <div className="flex flex-wrap gap-1.5 mb-2">
-          {selected.map((p) => (
-            <span
-              key={p.id}
-              className="inline-flex items-center gap-1 bg-amber-100 text-amber-800 text-[10px] font-bold uppercase tracking-wider px-2.5 py-1 rounded-full"
-            >
-              {p.name.split(' ')[0]}
-              <button
-                type="button"
-                onClick={() => toggle(p.id)}
-                className="text-amber-500 hover:text-amber-900 ml-0.5"
-              >
-                <X size={10} />
-              </button>
-            </span>
-          ))}
-        </div>
-      )}
-
-      {/* Search input */}
-      <div className="relative">
-        <Search size={13} className="absolute left-3 top-1/2 -translate-y-1/2 text-stone-300 pointer-events-none" />
-        <input
-          type="text"
-          value={query}
-          onChange={(e) => { setQuery(e.target.value); setOpen(true); }}
-          onFocus={() => setOpen(true)}
-          placeholder="Tag a family member…"
-          className="w-full bg-stone-50 border border-stone-100 rounded-xl py-2 pl-9 pr-3 text-[12px] font-serif outline-none focus:ring-2 focus:ring-amber-200 placeholder:text-stone-300"
-        />
-      </div>
-
-      {/* Dropdown */}
-      {open && results.length > 0 && (
-        <div className="absolute top-full left-0 right-0 mt-1 bg-white border border-stone-100 rounded-2xl shadow-xl z-50 overflow-hidden max-h-48 overflow-y-auto">
-          {results.map((p) => {
-            const isSelected = selectedIds.includes(p.id);
-            return (
-              <button
-                key={p.id}
-                type="button"
-                onClick={() => { toggle(p.id); setQuery(''); }}
-                className={`w-full flex items-center gap-3 px-4 py-2.5 text-left hover:bg-stone-50 transition-colors ${isSelected ? 'bg-amber-50' : ''}`}
-              >
-                <img
-                  src={p.imageUrl}
-                  alt={p.name}
-                  className="w-7 h-7 rounded-lg object-cover grayscale flex-shrink-0"
-                />
-                <div className="flex-1 min-w-0">
-                  <span className="font-serif text-[12px] text-slate-800 block truncate">{p.name}</span>
-                  <span className="text-[10px] text-stone-400">{p.birthYear}{p.deathYear ? `–${p.deathYear}` : ''}</span>
-                </div>
-                {isSelected && (
-                  <span className="text-[10px] font-bold text-amber-600">Tagged</span>
-                )}
-              </button>
-            );
-          })}
-        </div>
-      )}
-    </div>
-  );
-};
diff -ruN before/components/circle/PostComposer.tsx after/components/circle/PostComposer.tsx
--- before/components/circle/PostComposer.tsx	2026-02-21 02:03:33.894190065 +0000
+++ after/components/circle/PostComposer.tsx	1970-01-01 00:00:00.000000000 +0000
@@ -1,182 +0,0 @@
-import React, { useRef, useState } from 'react';
-import { Paperclip, Send, X, Image, FileText, Music, Video } from 'lucide-react';
-import { CircleAttachment, CirclePost, Profile } from '../../types';
-import { PersonPicker } from './PersonPicker';
-
-interface PostComposerProps {
-  profiles: Profile[];
-  authorLabel: string;
-  userId: string;
-  onSubmit: (post: CirclePost) => void;
-}
-
-const kindIcon = (kind: CircleAttachment['kind']) => {
-  if (kind === 'photo') return <Image size={12} />;
-  if (kind === 'video') return <Video size={12} />;
-  if (kind === 'audio') return <Music size={12} />;
-  return <FileText size={12} />;
-};
-
-const inferKind = (file: File): CircleAttachment['kind'] => {
-  if (file.type.startsWith('image/')) return 'photo';
-  if (file.type.startsWith('video/')) return 'video';
-  if (file.type.startsWith('audio/')) return 'audio';
-  return 'document';
-};
-
-export const PostComposer: React.FC<PostComposerProps> = ({ profiles, authorLabel, userId, onSubmit }) => {
-  const [body, setBody] = useState('');
-  const [taggedIds, setTaggedIds] = useState<string[]>([]);
-  const [attachments, setAttachments] = useState<CircleAttachment[]>([]);
-  const [isSubmitting, setIsSubmitting] = useState(false);
-  const fileInputRef = useRef<HTMLInputElement>(null);
-
-  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
-    const files = Array.from(e.target.files || []);
-    files.forEach((file) => {
-      const reader = new FileReader();
-      reader.onload = (ev) => {
-        const dataUrl = ev.target?.result as string;
-        setAttachments((prev) => [
-          ...prev,
-          {
-            id: `att_${Date.now()}_${Math.random().toString(36).slice(2)}`,
-            kind: inferKind(file),
-            name: file.name,
-            dataUrl,
-            size: file.size
-          }
-        ]);
-      };
-      reader.readAsDataURL(file);
-    });
-    e.target.value = '';
-  };
-
-  const removeAttachment = (id: string) => setAttachments((prev) => prev.filter((a) => a.id !== id));
-
-  const handleSubmit = () => {
-    if (!body.trim() && attachments.length === 0) return;
-    setIsSubmitting(true);
-
-    const post: CirclePost = {
-      id: `post_${Date.now()}_${Math.random().toString(36).slice(2)}`,
-      userId,
-      createdAt: new Date().toISOString(),
-      authorLabel,
-      body: body.trim(),
-      attachments,
-      taggedProfileIds: taggedIds
-    };
-
-    onSubmit(post);
-    setBody('');
-    setTaggedIds([]);
-    setAttachments([]);
-    setIsSubmitting(false);
-  };
-
-  const canSubmit = (body.trim().length > 0 || attachments.length > 0) && !isSubmitting;
-
-  return (
-    <div className="bg-white rounded-[28px] border border-stone-100 shadow-sm p-5 space-y-4">
-      {/* Header */}
-      <div className="flex items-center gap-3">
-        <div className="w-9 h-9 rounded-2xl bg-amber-100 flex items-center justify-center flex-shrink-0">
-          <span className="text-amber-700 text-[11px] font-black uppercase">
-            {authorLabel.charAt(0)}
-          </span>
-        </div>
-        <span className="text-[11px] font-bold uppercase tracking-widest text-stone-400">
-          {authorLabel}
-        </span>
-      </div>
-
-      {/* Textarea */}
-      <textarea
-        value={body}
-        onChange={(e) => setBody(e.target.value)}
-        placeholder="Share a memory, story, or update with the family circle…"
-        rows={3}
-        className="w-full resize-none bg-stone-50 border border-stone-100 rounded-2xl p-4 font-serif text-[14px] text-slate-700 outline-none focus:ring-2 focus:ring-amber-200 placeholder:text-stone-300 leading-relaxed"
-      />
-
-      {/* Attachment previews */}
-      {attachments.length > 0 && (
-        <div className="flex flex-wrap gap-2">
-          {attachments.map((att) => (
-            <div
-              key={att.id}
-              className="relative group rounded-xl overflow-hidden border border-stone-100"
-            >
-              {att.kind === 'photo' ? (
-                <img
-                  src={att.dataUrl}
-                  alt={att.name}
-                  className="w-16 h-16 object-cover"
-                />
-              ) : (
-                <div className="w-16 h-16 bg-stone-50 flex flex-col items-center justify-center gap-1 text-stone-400">
-                  {kindIcon(att.kind)}
-                  <span className="text-[8px] text-center px-1 truncate w-full text-center">
-                    {att.name.slice(0, 10)}
-                  </span>
-                </div>
-              )}
-              <button
-                type="button"
-                onClick={() => removeAttachment(att.id)}
-                className="absolute top-0.5 right-0.5 w-4 h-4 rounded-full bg-stone-900/70 text-white flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity"
-              >
-                <X size={8} />
-              </button>
-            </div>
-          ))}
-        </div>
-      )}
-
-      {/* People tagger */}
-      {profiles.length > 0 && (
-        <PersonPicker
-          profiles={profiles}
-          selectedIds={taggedIds}
-          onChange={setTaggedIds}
-        />
-      )}
-
-      {/* Actions */}
-      <div className="flex items-center justify-between pt-1">
-        <button
-          type="button"
-          onClick={() => fileInputRef.current?.click()}
-          className="flex items-center gap-1.5 text-stone-400 hover:text-amber-600 transition-colors text-[11px] font-bold uppercase tracking-wider"
-        >
-          <Paperclip size={14} />
-          Attach
-        </button>
-        <input
-          ref={fileInputRef}
-          type="file"
-          multiple
-          accept="image/*,video/*,audio/*,.pdf,.doc,.docx"
-          onChange={handleFileChange}
-          className="hidden"
-        />
-
-        <button
-          type="button"
-          onClick={handleSubmit}
-          disabled={!canSubmit}
-          className={`flex items-center gap-2 px-5 py-2.5 rounded-full text-[11px] font-black uppercase tracking-widest transition-all ${
-            canSubmit
-              ? 'bg-stone-900 text-white hover:bg-stone-700 shadow-sm'
-              : 'bg-stone-100 text-stone-300 cursor-not-allowed'
-          }`}
-        >
-          <Send size={12} />
-          Post
-        </button>
-      </div>
-    </div>
-  );
-};
diff -ruN before/constants.tsx after/constants.tsx
--- before/constants.tsx	2026-02-21 02:03:33.909190065 +0000
+++ after/constants.tsx	1970-01-01 00:00:00.000000000 +0000
@@ -1,71 +0,0 @@
-
-import React from 'react';
-import { 
-  Sparkles, Disc, Heart, MapPin, ScrollText, Anchor, Map as MapIcon, History 
-} from 'lucide-react';
-
-export const STORAGE_KEYS = {
-  // These keys are kept for any residual migration tooling.
-  // The app itself no longer reads or writes localStorage for auth or data.
-  PROFILES: 'eternal_profiles',
-  FAMILY_TREES: 'eternal_family_trees',
-  REMEMBERED_EMAIL: 'eternal_remembered_email',
-  CIRCLE_POSTS: 'eternal_circle_posts',
-};
-
-export const MONTHS = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
-
-// Archival Silhouette Placeholders
-const PLACEHOLDERS = {
-  M: `data:image/svg+xml;utf8,${encodeURIComponent('<svg width="400" height="400" viewBox="0 0 400 400" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="400" height="400" fill="#D4CBB9"/><path d="M200 120C222.091 120 240 137.909 240 160C240 182.091 222.091 200 200 200C177.909 200 160 182.091 160 160C160 137.909 177.909 120 200 120ZM200 220C255.228 220 300 255.82 300 300V320H100V300C100 255.82 144.772 220 200 220Z" fill="#1C1917" fill-opacity="0.15"/></svg>')}`,
-  F: `data:image/svg+xml;utf8,${encodeURIComponent('<svg width="400" height="400" viewBox="0 0 400 400" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="400" height="400" fill="#D4CBB9"/><path d="M200 110C219.33 110 235 125.67 235 145C235 164.33 219.33 180 200 180C180.67 180 165 164.33 165 145C165 125.67 180.67 110 200 110ZM200 200C244.183 200 280 235.817 280 280C280 290 280 305 280 320H120C120 305 120 290 120 280C120 235.817 155.817 200 200 200Z" fill="#1C1917" fill-opacity="0.15"/></svg>')}`,
-  U: `data:image/svg+xml;utf8,${encodeURIComponent('<svg width="400" height="400" viewBox="0 0 400 400" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="400" height="400" fill="#D4CBB9"/><circle cx="200" cy="150" r="45" fill="#1C1917" fill-opacity="0.15"/><path d="M110 320C110 270 150.294 230 200 230C249.706 230 290 270 290 320H110Z" fill="#1C1917" fill-opacity="0.15"/></svg>')}`
-};
-
-export const getPlaceholderImage = (gender?: string) => {
-  if (gender === 'M') return PLACEHOLDERS.M;
-  if (gender === 'F') return PLACEHOLDERS.F;
-  return PLACEHOLDERS.U;
-};
-
-export type EventIconProps = { size?: number; className?: string };
-
-const iconMap: Record<string, React.FC<EventIconProps>> = {
-  'Birth':                (p) => <Sparkles  {...p} className="text-amber-500" />,
-  'Death':                (p) => <Disc      {...p} className="text-stone-400" />,
-  'Marriage':             (p) => <Heart     {...p} className="text-rose-400" />,
-  'Residence':            (p) => <MapPin    {...p} className="text-blue-400" />,
-  'Census':               (p) => <ScrollText {...p} className="text-emerald-400" />,
-  'Departure/Emigration': (p) => <Anchor    {...p} className="text-orange-400" />,
-  'Arrival/Immigration':  (p) => <MapIcon   {...p} className="text-indigo-400" />,
-  'Burial':               (p) => <Disc      {...p} className="text-stone-500" />,
-  'Graduation':           (p) => <Sparkles  {...p} className="text-purple-500" />,
-  'Military Service':     (p) => <MapPin    {...p} className="text-red-500" />,
-  'Bar Mitzvah':          (p) => <ScrollText {...p} className="text-blue-500" />,
-  'Bat Mitzvah':          (p) => <ScrollText {...p} className="text-pink-500" />,
-  'Confirmation':         (p) => <Sparkles  {...p} className="text-indigo-500" />,
-  'Event':                (p) => <History   {...p} className="text-stone-400" />,
-};
-
-export const getEventIcon = (type: string): React.FC<EventIconProps> =>
-  iconMap[type] ?? ((p) => <History {...p} className="text-stone-300" />);
-
-export const eventVerb = (type: string) => {
-  const verbs: Record<string, string> = {
-    'Birth': 'was born',
-    'Death': 'passed away',
-    'Marriage': 'married',
-    'Residence': 'resided',
-    'Census': 'appears in the census',
-    'Burial': 'was laid to rest',
-    'Departure/Emigration': 'departed',
-    'Arrival/Immigration': 'arrived',
-    'Graduation': 'graduated',
-    'Military Service': 'served',
-    'Bar Mitzvah': 'celebrated their Bar Mitzvah',
-    'Bat Mitzvah': 'celebrated their Bat Mitzvah',
-    'Confirmation': 'was confirmed',
-    'Event': 'had an event'
-  };
-  return verbs[type] || 'had a recorded event';
-};
diff -ruN before/database.types.ts after/database.types.ts
--- before/database.types.ts	2026-02-21 02:03:33.922190065 +0000
+++ after/database.types.ts	1970-01-01 00:00:00.000000000 +0000
@@ -1,105 +0,0 @@
-// ---------------------------------------------------------------------------
-// Hand-authored types that mirror the SQL schema in supabase_migration.sql.
-// Replace with the output of `supabase gen types typescript` once you have
-// a linked project: https://supabase.com/docs/reference/cli/supabase-gen-types
-// ---------------------------------------------------------------------------
-
-export type MediaKindEnum = 'photo' | 'video' | 'audio' | 'document';
-export type GenderCodeEnum = 'M' | 'F' | 'U';
-
-// ── Row shapes (what Supabase returns) ──────────────────────────────────────
-
-export interface TreeRow {
-  id: string;
-  user_id: string;
-  name: string;
-  home_person_id: string | null;
-  member_ids: string[];
-  created_at: string;
-  updated_at: string;
-}
-
-export interface ProfileRow {
-  id: string;
-  user_id: string;
-  tree_id: string | null;
-  name: string;
-  gender: GenderCodeEnum | null;
-  birth_year: string | null;
-  death_year: string | null;
-  image_url: string | null;
-  summary: string | null;
-  historical_context: { text: string; sources: unknown[] } | null;
-  is_memorial: boolean;
-  parent_ids: string[];
-  child_ids: string[];
-  spouse_ids: string[];
-  timeline: unknown[];   // LifeEvent[] stored as JSONB
-  memories: unknown[];   // Memory[] stored as JSONB
-  sources: string[];
-  created_at: string;
-  updated_at: string;
-}
-
-export interface PostRow {
-  id: string;
-  user_id: string;
-  author_label: string;
-  body: string;
-  attachments: unknown[];  // CircleAttachment[] stored as JSONB
-  created_at: string;
-  updated_at: string;
-}
-
-export interface PostPersonRow {
-  post_id: string;
-  profile_id: string;
-  user_id: string;
-}
-
-export interface MediaRow {
-  id: string;
-  user_id: string;
-  name: string;
-  kind: MediaKindEnum;
-  storage_path: string;
-  public_url: string | null;
-  mime: string | null;
-  size: number | null;
-  created_at: string;
-  updated_at: string;
-}
-
-export interface MediaPersonRow {
-  media_id: string;
-  profile_id: string;
-  user_id: string;
-}
-
-// ── Insert shapes (what we send to Supabase) ────────────────────────────────
-
-export type TreeInsert = Omit<TreeRow, 'created_at' | 'updated_at'>;
-export type ProfileInsert = Omit<ProfileRow, 'created_at' | 'updated_at'>;
-export type PostInsert = Omit<PostRow, 'created_at' | 'updated_at'>;
-export type MediaInsert = Omit<MediaRow, 'created_at' | 'updated_at'>;
-
-// ── Minimal Database shape for createClient<Database>() ─────────────────────
-
-export interface Database {
-  public: {
-    Tables: {
-      trees:        { Row: TreeRow;        Insert: TreeInsert;    Update: Partial<TreeInsert> };
-      profiles:     { Row: ProfileRow;     Insert: ProfileInsert; Update: Partial<ProfileInsert> };
-      posts:        { Row: PostRow;        Insert: PostInsert;    Update: Partial<PostInsert> };
-      post_people:  { Row: PostPersonRow;  Insert: PostPersonRow; Update: Partial<PostPersonRow> };
-      media:        { Row: MediaRow;       Insert: MediaInsert;   Update: Partial<MediaInsert> };
-      media_people: { Row: MediaPersonRow; Insert: MediaPersonRow; Update: Partial<MediaPersonRow> };
-    };
-    Views: Record<string, never>;
-    Functions: Record<string, never>;
-    Enums: {
-      media_kind: MediaKindEnum;
-      gender_code: GenderCodeEnum;
-    };
-  };
-}
diff -ruN before/gemini.ts after/gemini.ts
--- before/gemini.ts	2026-02-21 02:03:33.937190065 +0000
+++ after/gemini.ts	1970-01-01 00:00:00.000000000 +0000
@@ -1,126 +0,0 @@
-// services/gemini.ts
-// All Gemini calls now proxy through /api/gemini (a Vercel serverless function).
-// No @google/genai import, no API key, no process.env in this file.
-
-import type { Profile } from '../types';
-import { formatEventSentence } from '../utils/formatters';
-
-// ── Shared transport ──────────────────────────────────────────────────────────
-
-const ENDPOINT = '/api/gemini';
-
-interface SummaryResponse  { text: string }
-interface ResearchResponse { text: string; sources: GroundingSource[] }
-interface PortraitResponse { imageBase64: string }
-interface ErrorResponse    { error: string }
-
-interface GroundingSource {
-  web?: { uri: string; title: string };
-}
-
-type ApiAction = 'summary' | 'research' | 'portrait';
-
-async function callGemini(action: ApiAction, prompt: string): Promise<Response> {
-  return fetch(ENDPOINT, {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ action, prompt }),
-  });
-}
-
-/** Parse the response, throwing a human-readable message on failure. */
-async function parseOrThrow<T>(res: Response): Promise<T> {
-  const body = await res.json() as T | ErrorResponse;
-  if (!res.ok) {
-    const msg = (body as ErrorResponse).error ?? `Server error ${res.status}`;
-    throw new Error(msg);
-  }
-  return body as T;
-}
-
-// ── Public API (same signatures as the original service) ─────────────────────
-
-/**
- * Generate a narrative life summary for a profile.
- * Model: gemini-2.0-flash (server-side)
- */
-export async function generateAiProfileSummary(profile: Profile): Promise<string> {
-  const events = profile.timeline
-    .map((ev) => formatEventSentence(profile.name, ev))
-    .join('\n');
-  const memories = profile.memories.map((m) => m.content).join('\n');
-
-  const prompt = `
-Generate a respectful, high-quality, narrative life summary for ${profile.name} (born ${profile.birthYear}).
-Use the following timeline events and family stories to weave a cohesive biographical sketch.
-
-Timeline:
-${events}
-
-Family Stories:
-${memories}
-
-Instructions:
-- Focus on the impact of their life.
-- Keep it under 250 words.
-- Maintain an archival, historical, and elegant tone.
-`.trim();
-
-  try {
-    const res = await callGemini('summary', prompt);
-    const data = await parseOrThrow<SummaryResponse>(res);
-    return data.text;
-  } catch (err) {
-    console.error('[gemini] generateAiProfileSummary:', err);
-    return 'Failed to generate AI summary.';
-  }
-}
-
-/**
- * Fetch grounded historical context for a profile's life period and locations.
- * Model: gemini-2.5-pro-preview-05-06 with Google Search grounding (server-side)
- */
-export async function getHistoricalContext(
-  profile: Profile
-): Promise<{ text: string; sources: GroundingSource[] }> {
-  const lifePeriod = `${profile.birthYear} to ${profile.deathYear || 'the present'}`;
-  const locations = Array.from(
-    new Set(profile.timeline.map((e) => e.place).filter(Boolean))
-  ).join(', ');
-
-  const prompt = `Provide a comprehensive historical deep-dive into the era and specific locations inhabited by ${profile.name} during their life from ${lifePeriod}.
-The primary locations were: ${locations}.
-
-Research and describe:
-1. Specific local history and atmosphere of ${locations} during these decades.
-2. Major global events (wars, movements, economic shifts) that significantly altered their daily world.
-3. Technological innovations or cultural changes that a person living in ${locations} would have witnessed.
-
-Format this as a "Historical Narrative" for a family archive. Be specific, evocative, and archival in tone.`.trim();
-
-  try {
-    const res = await callGemini('research', prompt);
-    const data = await parseOrThrow<ResearchResponse>(res);
-    return { text: data.text, sources: data.sources ?? [] };
-  } catch (err) {
-    console.error('[gemini] getHistoricalContext:', err);
-    return {
-      text: 'Our digital archives could not be reached. Please check your connection and try again.',
-      sources: [],
-    };
-  }
-}
-
-/**
- * Generate an AI portrait image for a profile.
- * Model: gemini-2.0-flash-preview-image-generation (server-side)
- * Returns a data URL string ready to assign to profile.imageUrl.
- * Throws on failure so the caller (App.tsx) can catch and show a toast.
- */
-export async function generateAiPortrait(profile: Profile): Promise<string> {
-  const prompt = `A period-accurate, elegant studio portrait of a person named ${profile.name} born in ${profile.birthYear}. Style: historical photographic daguerreotype or charcoal sketch, highly detailed, archival museum quality.`;
-
-  const res = await callGemini('portrait', prompt);
-  const data = await parseOrThrow<PortraitResponse>(res);
-  return `data:image/png;base64,${data.imageBase64}`;
-}
diff -ruN before/hooks/useArchiveStore.ts after/hooks/useArchiveStore.ts
--- before/hooks/useArchiveStore.ts	2026-02-21 02:03:33.952190065 +0000
+++ after/hooks/useArchiveStore.ts	1970-01-01 00:00:00.000000000 +0000
@@ -1,122 +0,0 @@
-import { useCallback, useEffect, useMemo, useState } from 'react';
-import { CirclePost, FamilyTree, Profile, User } from '../types';
-import { STORAGE_KEYS } from '../constants';
-
-export const useArchiveStore = (user: User | null) => {
-  const [profiles, setProfiles] = useState<Profile[]>([]);
-  const [familyTrees, setFamilyTrees] = useState<FamilyTree[]>([]);
-  const [activeProfileId, setActiveProfileId] = useState<string | null>(null);
-  const [selectedTreeId, setSelectedTreeId] = useState<string | null>(null);
-  const [treeViewId, setTreeViewId] = useState<string | null>(null);
-  const [circlePosts, setCirclePosts] = useState<CirclePost[]>([]);
-
-  // Load user scoped data when user changes
-  useEffect(() => {
-    if (!user) return;
-    const savedProfiles = JSON.parse(localStorage.getItem(STORAGE_KEYS.PROFILES) || '[]') as Profile[];
-    const savedTrees = JSON.parse(localStorage.getItem(STORAGE_KEYS.FAMILY_TREES) || '[]') as FamilyTree[];
-    const savedPosts = JSON.parse(localStorage.getItem(STORAGE_KEYS.CIRCLE_POSTS) || '[]') as CirclePost[];
-
-    setProfiles(
-      savedProfiles
-        .filter((p) => p.userId === user.id)
-        .map((p) => ({
-          ...p,
-          parentIds: p.parentIds || [],
-          childIds: p.childIds || [],
-          spouseIds: p.spouseIds || [],
-          timeline: p.timeline || [],
-          memories: p.memories || [],
-          media: p.media || []
-        }))
-    );
-    setFamilyTrees(savedTrees.filter((t) => t.userId === user.id));
-    setCirclePosts(savedPosts.filter((p) => p.userId === user.id));
-  }, [user]);
-
-  // Persist when data changes
-  // Important: STORAGE_KEYS are global, so we must merge per-user data to avoid
-  // overwriting other users' archives on the same device/browser.
-  useEffect(() => {
-    if (!user) return;
-
-    const allProfiles = JSON.parse(localStorage.getItem(STORAGE_KEYS.PROFILES) || '[]') as Profile[];
-    const mergedProfiles = [
-      ...allProfiles.filter((p) => p.userId !== user.id),
-      ...profiles
-    ];
-
-    const allTrees = JSON.parse(localStorage.getItem(STORAGE_KEYS.FAMILY_TREES) || '[]') as FamilyTree[];
-    const mergedTrees = [
-      ...allTrees.filter((t) => t.userId !== user.id),
-      ...familyTrees
-    ];
-
-    const allPosts = JSON.parse(localStorage.getItem(STORAGE_KEYS.CIRCLE_POSTS) || '[]') as CirclePost[];
-    const mergedPosts = [
-      ...allPosts.filter((p) => p.userId !== user.id),
-      ...circlePosts
-    ];
-
-    try {
-      localStorage.setItem(STORAGE_KEYS.PROFILES, JSON.stringify(mergedProfiles));
-      localStorage.setItem(STORAGE_KEYS.FAMILY_TREES, JSON.stringify(mergedTrees));
-      localStorage.setItem(STORAGE_KEYS.CIRCLE_POSTS, JSON.stringify(mergedPosts));
-    } catch (e) {
-      console.error('Storage quota exceeded — archive may not be fully saved.', e);
-      // Attempt to save trees at minimum (much smaller than profiles with base64 images)
-      try {
-        localStorage.setItem(STORAGE_KEYS.FAMILY_TREES, JSON.stringify(mergedTrees));
-      } catch {
-        // Nothing more we can do without a backend
-      }
-    }
-  }, [profiles, familyTrees, circlePosts, user]);
-
-  const addCirclePost = useCallback((post: CirclePost) => {
-    setCirclePosts((prev) => [post, ...prev]);
-  }, []);
-
-  const deleteCirclePost = useCallback((id: string) => {
-    setCirclePosts((prev) => prev.filter((p) => p.id !== id));
-  }, []);
-
-  const updateCirclePost = useCallback((id: string, patch: Partial<CirclePost>) => {
-    setCirclePosts((prev) => prev.map((p) => (p.id === id ? { ...p, ...patch } : p)));
-  }, []);
-
-  const activeProfile = useMemo(
-    () => profiles.find((p) => p.id === activeProfileId) || null,
-    [profiles, activeProfileId]
-  );
-
-  const selectedTree = useMemo(
-    () => familyTrees.find((t) => t.id === selectedTreeId) || null,
-    [familyTrees, selectedTreeId]
-  );
-
-  const selectedTreeForView = useMemo(
-    () => familyTrees.find((t) => t.id === treeViewId) || null,
-    [familyTrees, treeViewId]
-  );
-
-  const clearAll = () => {
-    setProfiles([]);
-    setFamilyTrees([]);
-    setActiveProfileId(null);
-    setSelectedTreeId(null);
-    setTreeViewId(null);
-    setCirclePosts([]);
-  };
-
-  return {
-    profiles, setProfiles,
-    familyTrees, setFamilyTrees,
-    activeProfileId, setActiveProfileId,
-    selectedTreeId, setSelectedTreeId,
-    treeViewId, setTreeViewId,
-    activeProfile, selectedTree, selectedTreeForView,
-    circlePosts, addCirclePost, deleteCirclePost, updateCirclePost,
-    clearAll
-  };
-};
diff -ruN before/hooks/useGedcomImport.ts after/hooks/useGedcomImport.ts
--- before/hooks/useGedcomImport.ts	2026-02-21 02:03:33.970190064 +0000
+++ after/hooks/useGedcomImport.ts	1970-01-01 00:00:00.000000000 +0000
@@ -1,66 +0,0 @@
-import { useRef, useState } from 'react';
-import { AppView, FamilyTree, Profile, User } from '../types';
-import { parseGedcom } from '../utils/gedcom';
-
-export const useGedcomImport = (args: {
-  user: User | null;
-  setView: (v: AppView) => void;
-  setProfiles: React.Dispatch<React.SetStateAction<Profile[]>>;
-  setFamilyTrees: React.Dispatch<React.SetStateAction<FamilyTree[]>>;
-  setSelectedTreeId: (id: string | null) => void;
-  setActiveProfileId: (id: string | null) => void;
-  toast: (m: string) => void;
-}) => {
-  const { user, setView, setProfiles, setFamilyTrees, setSelectedTreeId, setActiveProfileId, toast } = args;
-
-  const gedFileInputRef = useRef<HTMLInputElement>(null);
-  const [pendingImport, setPendingImport] = useState<{ importedProfiles: Profile[]; tree: FamilyTree } | null>(null);
-
-  const handleGedcomUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
-    const f = e.target.files?.[0];
-    if (f && user) {
-      const reader = new FileReader();
-      reader.onload = (event) => {
-        const text = event.target?.result;
-        if (typeof text === 'string') {
-          try {
-            const result = parseGedcom(text, user.id, 4);
-            setPendingImport(result);
-            setView(AppView.SELECT_HOME);
-            toast(`Loaded ${result.importedProfiles.length} family members`);
-          } catch (err) {
-            console.error(err);
-            toast('Error parsing GEDCOM');
-          }
-        }
-      };
-      reader.readAsText(f);
-    }
-    e.target.value = '';
-  };
-
-  const chooseHome = (selected: Profile) => {
-    if (!pendingImport || !user) return;
-
-    setProfiles((prev) => {
-      const existingIds = new Set(prev.map((p) => p.id));
-      const newProfiles = pendingImport.importedProfiles.filter((p) => !existingIds.has(p.id));
-      return [...prev, ...newProfiles];
-    });
-
-    const updatedTree: FamilyTree = {
-      ...pendingImport.tree,
-      homePersonId: selected.id,
-      name: `The ${selected.name} Archive`
-    };
-
-    setFamilyTrees((prev) => [updatedTree, ...prev]);
-    setSelectedTreeId(updatedTree.id);
-    setActiveProfileId(selected.id);
-    setPendingImport(null);
-    setView(AppView.HOME);
-    toast('Archive successfully imported');
-  };
-
-  return { gedFileInputRef, pendingImport, setPendingImport, handleGedcomUpload, chooseHome };
-};
diff -ruN before/hooks/useMediaAttach.ts after/hooks/useMediaAttach.ts
--- before/hooks/useMediaAttach.ts	2026-02-21 02:03:33.986190064 +0000
+++ after/hooks/useMediaAttach.ts	1970-01-01 00:00:00.000000000 +0000
@@ -1,130 +0,0 @@
-import { useState } from 'react';
-import { AppView, MediaItem, Profile } from '../types';
-import { compressImage } from '../utils/media';
-import { inferMediaKind } from '../utils/formatters';
-
-export const useMediaAttach = (args: {
-  activeProfileId: string | null;
-  view: AppView;
-  attachingToEventId: string | null;
-  setAttachingToEventId: (id: string | null) => void;
-  setProfiles: React.Dispatch<React.SetStateAction<Profile[]>>;
-  setEditImageUrl: (v: string) => void;
-  toast: (m: string) => void;
-}) => {
-  const { activeProfileId, view, attachingToEventId, setAttachingToEventId, setProfiles, setEditImageUrl, toast } = args;
-  const [isPhotoLoading, setIsPhotoLoading] = useState(false);
-
-  const handleProfilePhotoUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
-    const file = e.target.files?.[0];
-    if (!file || !activeProfileId) return;
-    setIsPhotoLoading(true);
-    try {
-      const base64 = await compressImage(file);
-      if (view === AppView.EDIT_PROFILE) setEditImageUrl(base64);
-      else setProfiles((prev) => prev.map((p) => (p.id === activeProfileId ? { ...p, imageUrl: base64 } : p)));
-      toast('Photo updated');
-    } catch (err) {
-      console.error(err);
-      toast('Error processing photo');
-    } finally {
-      setIsPhotoLoading(false);
-      e.target.value = '';
-    }
-  };
-
-  const handleLifecycleFileUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
-    const files = e.target.files;
-    if (!files || files.length === 0 || !activeProfileId || !attachingToEventId) return;
-    toast('Processing...');
-    try {
-      const newMediaItems: MediaItem[] = await Promise.all(
-        Array.from(files).map(async (file: File) => {
-          const kind = inferMediaKind(file.name, file.type);
-          let url = '';
-          if (kind === 'photo') url = await compressImage(file);
-          else {
-            const reader = new FileReader();
-            url = await new Promise((resolve) => {
-              reader.onload = (ev) => resolve(ev.target?.result as string);
-              reader.readAsDataURL(file);
-            });
-          }
-          return { id: `m-${Date.now()}-${Math.random()}`, name: file.name, kind, url, createdAt: new Date().toISOString() };
-        })
-      );
-
-      setProfiles((prev) =>
-        prev.map((p) =>
-          p.id === activeProfileId
-            ? {
-                ...p,
-                timeline: (p.timeline || []).map((ev: any) =>
-                  ev.id === attachingToEventId ? { ...ev, media: [...(ev.media || []), ...newMediaItems] } : ev
-                )
-              }
-            : p
-        )
-      );
-      toast(`Attached ${newMediaItems.length} files`);
-    } catch (err) {
-      console.error(err);
-      toast('Upload error');
-    } finally {
-      setAttachingToEventId(null);
-      e.target.value = '';
-    }
-  };
-
-  const handleEventMediaUpload = async (eventId: string, files: FileList) => {
-    if (!activeProfileId || !files.length) return;
-    toast('Processing...');
-    try {
-      const newMediaItems: MediaItem[] = await Promise.all(
-        Array.from(files).map(async (file: File) => {
-          const kind = inferMediaKind(file.name, file.type);
-          let url = '';
-          if (kind === 'photo') {
-            url = await compressImage(file);
-          } else {
-            url = await new Promise<string>((resolve, reject) => {
-              const reader = new FileReader();
-              reader.onload = (ev) => resolve(ev.target?.result as string);
-              reader.onerror = reject;
-              reader.readAsDataURL(file);
-            });
-          }
-          return {
-            id: `m-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`,
-            name: file.name,
-            kind,
-            url,
-            mime: file.type,
-            size: file.size,
-            createdAt: new Date().toISOString(),
-          };
-        })
-      );
-
-      setProfiles(prev =>
-        prev.map(p =>
-          p.id !== activeProfileId ? p : {
-            ...p,
-            timeline: p.timeline.map(ev =>
-              ev.id !== eventId ? ev : {
-                ...ev,
-                media: [...(ev.media || []), ...newMediaItems],
-              }
-            ),
-          }
-        )
-      );
-      toast(`Attached ${newMediaItems.length} file${newMediaItems.length !== 1 ? 's' : ''}`);
-    } catch (err) {
-      console.error(err);
-      toast('Upload error');
-    }
-  };
-
-  return { isPhotoLoading, handleProfilePhotoUpload, handleLifecycleFileUpload, handleEventMediaUpload };
-};
diff -ruN before/hooks/useProfileEditor.ts after/hooks/useProfileEditor.ts
--- before/hooks/useProfileEditor.ts	2026-02-21 02:03:34.001190064 +0000
+++ after/hooks/useProfileEditor.ts	1970-01-01 00:00:00.000000000 +0000
@@ -1,108 +0,0 @@
-import { useState } from 'react';
-import { Profile } from '../types';
-
-export const useProfileEditor = (args: {
-  activeProfile: Profile | null;
-  activeProfileId: string | null;
-  setProfiles: React.Dispatch<React.SetStateAction<Profile[]>>;
-  toast: (m: string) => void;
-}) => {
-  const { activeProfile, activeProfileId, setProfiles, toast } = args;
-
-  const [editName, setEditName] = useState('');
-  const [editGender, setEditGender] = useState<'M' | 'F' | 'U'>('U');
-  const [editBirthYear, setEditBirthYear] = useState('');
-  const [editDeathYear, setEditDeathYear] = useState('');
-  const [editImageUrl, setEditImageUrl] = useState('');
-
-  const [newMemoryInput, setNewMemoryInput] = useState('');
-  const [linkRole, setLinkRole] = useState<'parent' | 'child' | 'spouse' | null>(null);
-
-  const startEdit = () => {
-    if (!activeProfile) return;
-    setEditName(activeProfile.name);
-    setEditGender(activeProfile.gender || 'U');
-    setEditBirthYear(activeProfile.birthYear);
-    setEditDeathYear(activeProfile.deathYear || '');
-    setEditImageUrl(activeProfile.imageUrl);
-  };
-
-  const saveEdit = () => {
-    if (!activeProfileId) return;
-    setProfiles((prev) =>
-      prev.map((p) =>
-        p.id === activeProfileId
-          ? {
-              ...p,
-              name: editName,
-              gender: editGender,
-              birthYear: editBirthYear,
-              deathYear: editDeathYear || undefined,
-              imageUrl: editImageUrl
-            }
-          : p
-      )
-    );
-    toast('Profile updated');
-  };
-
-  const deleteProfile = (confirmFn: (msg: string) => boolean) => {
-    if (!activeProfileId) return false;
-    const name = activeProfile?.name || 'this profile';
-    if (confirmFn(`Remove ${name}?`)) {
-      setProfiles((prev) => prev.filter((p) => p.id !== activeProfileId));
-      toast('Removed');
-      return true;
-    }
-    return false;
-  };
-
-  const linkRelative = (targetProfile: Profile) => {
-    if (!activeProfileId || !linkRole) return;
-    setProfiles((prev) =>
-      prev.map((p) => {
-        if (p.id === activeProfileId) {
-          const u = { ...p };
-          if (linkRole === 'parent' && !u.parentIds.includes(targetProfile.id)) u.parentIds = [...u.parentIds, targetProfile.id];
-          if (linkRole === 'child' && !u.childIds.includes(targetProfile.id)) u.childIds = [...u.childIds, targetProfile.id];
-          if (linkRole === 'spouse' && !u.spouseIds.includes(targetProfile.id)) u.spouseIds = [...u.spouseIds, targetProfile.id];
-          return u;
-        }
-        if (p.id === targetProfile.id) {
-          const u = { ...p };
-          if (linkRole === 'parent' && !u.childIds.includes(activeProfileId)) u.childIds = [...u.childIds, activeProfileId];
-          if (linkRole === 'child' && !u.parentIds.includes(activeProfileId)) u.parentIds = [...u.parentIds, activeProfileId];
-          if (linkRole === 'spouse' && !u.spouseIds.includes(activeProfileId)) u.spouseIds = [...u.spouseIds, activeProfileId];
-          return u;
-        }
-        return p;
-      })
-    );
-    toast('Link established');
-    setLinkRole(null);
-  };
-
-  const saveMemory = () => {
-    if (!activeProfileId || !newMemoryInput.trim()) return;
-    const m = {
-      id: Date.now().toString(),
-      type: 'story' as const,
-      content: newMemoryInput,
-      timestamp: new Date().toLocaleDateString('en-US', { month: 'short', year: 'numeric' })
-    };
-    setProfiles((prev) => prev.map((p) => (p.id === activeProfileId ? { ...p, memories: [m, ...(p.memories || [])] } : p)));
-    setNewMemoryInput('');
-    toast('Story preserved');
-  };
-
-  return {
-    editName, setEditName,
-    editGender, setEditGender,
-    editBirthYear, setEditBirthYear,
-    editDeathYear, setEditDeathYear,
-    editImageUrl, setEditImageUrl,
-    startEdit, saveEdit, deleteProfile,
-    newMemoryInput, setNewMemoryInput, saveMemory,
-    linkRole, setLinkRole, linkRelative
-  };
-};
diff -ruN before/hooks/useSession.ts after/hooks/useSession.ts
--- before/hooks/useSession.ts	2026-02-21 02:03:34.016190064 +0000
+++ after/hooks/useSession.ts	1970-01-01 00:00:00.000000000 +0000
@@ -1,34 +0,0 @@
-import { useEffect, useState } from 'react';
-import { AppView, User } from '../types';
-import { STORAGE_KEYS } from '../constants';
-
-export const useSession = () => {
-  const [view, setView] = useState<AppView>(AppView.SPLASH);
-  const [user, setUser] = useState<User | null>(null);
-
-  useEffect(() => {
-    const savedUser = localStorage.getItem(STORAGE_KEYS.CURRENT_USER);
-    if (savedUser) {
-      const u = JSON.parse(savedUser) as User;
-      setUser(u);
-      setView(AppView.HOME);
-    } else {
-      setTimeout(() => setView(AppView.LOGIN), 2500);
-    }
-  }, []);
-
-  const login = (u: User) => {
-    setUser(u);
-    setView(AppView.HOME);
-  };
-
-  const logout = () => {
-    localStorage.removeItem(STORAGE_KEYS.CURRENT_USER);
-    localStorage.removeItem(STORAGE_KEYS.PROFILES);
-    localStorage.removeItem(STORAGE_KEYS.FAMILY_TREES);
-    setUser(null);
-    setView(AppView.LOGIN);
-  };
-
-  return { view, setView, user, setUser, login, logout };
-};
diff -ruN before/index.css after/index.css
--- before/index.css	2026-02-21 02:03:34.030190064 +0000
+++ after/index.css	1970-01-01 00:00:00.000000000 +0000
@@ -1,16 +0,0 @@
-/* Eternal - Family Archive */
-
-@keyframes fade-in-up {
-  from {
-    opacity: 0;
-    transform: translateY(16px);
-  }
-  to {
-    opacity: 1;
-    transform: translateY(0);
-  }
-}
-
-.animate-fade-in-up {
-  animation: fade-in-up 0.8s ease-out both;
-}
diff -ruN before/index.tsx after/index.tsx
--- before/index.tsx	2026-02-21 02:03:34.060190064 +0000
+++ after/index.tsx	1970-01-01 00:00:00.000000000 +0000
@@ -1,17 +0,0 @@
-
-import React from 'react';
-import ReactDOM from 'react-dom/client';
-import App from './App';
-import ErrorBoundary from './components/ErrorBoundary';
-
-const rootElement = document.getElementById('root');
-if (!rootElement) {
-  throw new Error("Could not find root element to mount to");
-}
-
-const root = ReactDOM.createRoot(rootElement);
-root.render(
-  <React.StrictMode>
-    <ErrorBoundary><App /></ErrorBoundary>
-  </React.StrictMode>
-);
diff -ruN before/mappers.ts after/mappers.ts
--- before/mappers.ts	2026-02-21 02:03:34.075190064 +0000
+++ after/mappers.ts	1970-01-01 00:00:00.000000000 +0000
@@ -1,101 +0,0 @@
-// ---------------------------------------------------------------------------
-// Mappers: convert snake_case Supabase rows ↔ camelCase app types.
-// Keeping these in one place means the repos stay thin and the app types
-// never need to change.
-// ---------------------------------------------------------------------------
-
-import type { FamilyTree, Profile, CirclePost, CircleAttachment, LifeEvent, Memory } from '../types';
-import type { TreeRow, ProfileRow, PostRow, TreeInsert, ProfileInsert, PostInsert } from './database.types';
-
-// ── FamilyTree ───────────────────────────────────────────────────────────────
-
-export function rowToTree(row: TreeRow): FamilyTree {
-  return {
-    id: row.id,
-    userId: row.user_id,
-    name: row.name,
-    createdAt: row.created_at,
-    homePersonId: row.home_person_id ?? '',
-    memberIds: row.member_ids ?? [],
-  };
-}
-
-export function treeToInsert(t: FamilyTree): TreeInsert {
-  return {
-    id: t.id,
-    user_id: t.userId,
-    name: t.name,
-    home_person_id: t.homePersonId || null,
-    member_ids: t.memberIds,
-  };
-}
-
-// ── Profile ──────────────────────────────────────────────────────────────────
-
-export function rowToProfile(row: ProfileRow): Profile {
-  return {
-    id: row.id,
-    userId: row.user_id,
-    name: row.name,
-    gender: row.gender ?? undefined,
-    birthYear: row.birth_year ?? '',
-    deathYear: row.death_year ?? undefined,
-    imageUrl: row.image_url ?? '',
-    summary: row.summary ?? '',
-    historicalContext: row.historical_context ?? undefined,
-    isMemorial: row.is_memorial,
-    parentIds: row.parent_ids ?? [],
-    childIds: row.child_ids ?? [],
-    spouseIds: row.spouse_ids ?? [],
-    timeline: (row.timeline as LifeEvent[]) ?? [],
-    memories: (row.memories as Memory[]) ?? [],
-    sources: row.sources ?? [],
-  };
-}
-
-export function profileToInsert(p: Profile, treeId?: string): ProfileInsert {
-  return {
-    id: p.id,
-    user_id: p.userId,
-    tree_id: treeId ?? null,
-    name: p.name,
-    gender: p.gender ?? null,
-    birth_year: p.birthYear || null,
-    death_year: p.deathYear || null,
-    image_url: p.imageUrl || null,
-    summary: p.summary || null,
-    historical_context: p.historicalContext ?? null,
-    is_memorial: p.isMemorial ?? false,
-    parent_ids: p.parentIds ?? [],
-    child_ids: p.childIds ?? [],
-    spouse_ids: p.spouseIds ?? [],
-    timeline: (p.timeline ?? []) as unknown[],
-    memories: (p.memories ?? []) as unknown[],
-    sources: p.sources ?? [],
-  };
-}
-
-// ── CirclePost ───────────────────────────────────────────────────────────────
-
-/** taggedProfileIds must be injected from the post_people join */
-export function rowToPost(row: PostRow, taggedProfileIds: string[]): CirclePost {
-  return {
-    id: row.id,
-    userId: row.user_id,
-    createdAt: row.created_at,
-    authorLabel: row.author_label,
-    body: row.body,
-    attachments: (row.attachments as CircleAttachment[]) ?? [],
-    taggedProfileIds,
-  };
-}
-
-export function postToInsert(p: CirclePost): PostInsert {
-  return {
-    id: p.id,
-    user_id: p.userId,
-    author_label: p.authorLabel,
-    body: p.body,
-    attachments: p.attachments as unknown[],
-  };
-}
diff -ruN before/mediaRepo.ts after/mediaRepo.ts
--- before/mediaRepo.ts	2026-02-21 02:03:34.090190064 +0000
+++ after/mediaRepo.ts	1970-01-01 00:00:00.000000000 +0000
@@ -1,167 +0,0 @@
-// ---------------------------------------------------------------------------
-// repos/mediaRepo.ts
-// Files are uploaded to the Supabase Storage bucket named 'media' (private).
-// After a successful upload the metadata row is inserted into the media table.
-// Signed URLs are generated on demand (1-hour expiry) and should not be
-// persisted — generate a fresh one each time you render a <img> or <video>.
-// ---------------------------------------------------------------------------
-
-import { supabase } from '../lib/supabaseClient';
-import type { MediaItem, MediaKind } from '../types';
-import type { MediaRow } from '../lib/database.types';
-
-const BUCKET = 'media';
-const SIGNED_URL_EXPIRY_SECONDS = 60 * 60; // 1 hour
-
-// ── Internal helpers ─────────────────────────────────────────────────────────
-
-function rowToMediaItem(row: MediaRow, signedUrl: string): MediaItem {
-  return {
-    id: row.id,
-    name: row.name,
-    kind: row.kind as MediaKind,
-    url: signedUrl,
-    mime: row.mime ?? undefined,
-    size: row.size ?? undefined,
-    createdAt: row.created_at,
-  };
-}
-
-// ── Public API ───────────────────────────────────────────────────────────────
-
-export interface UploadMediaOptions {
-  /** UUID of the authenticated user — needed to namespace the storage path. */
-  userId: string;
-  /** The browser File object to upload. */
-  file: File;
-  /** Optional profile IDs to tag in media_people after upload. */
-  taggedProfileIds?: string[];
-}
-
-/**
- * Upload a file to Supabase Storage, write a metadata row, optionally tag
- * profiles, and return a MediaItem with a fresh signed URL.
- *
- * Storage path:  `{userId}/{timestamp}-{sanitisedFileName}`
- * This ensures files from different users never collide even without RLS on
- * the bucket (though you should also enable Storage RLS).
- */
-export async function uploadMedia(opts: UploadMediaOptions): Promise<MediaItem> {
-  const { userId, file, taggedProfileIds = [] } = opts;
-
-  // 1. Build a collision-safe storage path.
-  const safeName = file.name.replace(/[^a-zA-Z0-9._-]/g, '_');
-  const storagePath = `${userId}/${Date.now()}-${safeName}`;
-
-  // 2. Upload the raw file.
-  const { error: uploadError } = await supabase.storage
-    .from(BUCKET)
-    .upload(storagePath, file, {
-      contentType: file.type || 'application/octet-stream',
-      upsert: false,
-    });
-
-  if (uploadError) throw new Error(`uploadMedia storage: ${uploadError.message}`);
-
-  // 3. Infer media kind from MIME type.
-  const kind = inferKind(file.type);
-
-  // 4. Insert the metadata row.
-  const { data: row, error: insertError } = await supabase
-    .from('media')
-    .insert({
-      user_id: userId,
-      name: file.name,
-      kind,
-      storage_path: storagePath,
-      public_url: null,
-      mime: file.type || null,
-      size: file.size,
-    })
-    .select()
-    .single();
-
-  if (insertError) {
-    // Best-effort cleanup: remove the orphaned file from Storage.
-    await supabase.storage.from(BUCKET).remove([storagePath]).catch(() => {});
-    throw new Error(`uploadMedia insert: ${insertError.message}`);
-  }
-
-  // 5. Tag profiles if requested.
-  if (taggedProfileIds.length > 0) {
-    const tags = taggedProfileIds.map((profileId) => ({
-      media_id: row.id,
-      profile_id: profileId,
-      user_id: userId,
-    }));
-
-    const { error: tagError } = await supabase.from('media_people').insert(tags);
-    if (tagError) {
-      console.error('uploadMedia tagging failed:', tagError.message);
-    }
-  }
-
-  // 6. Generate a signed URL for immediate display.
-  const signedUrl = await getSignedUrl(storagePath);
-
-  return rowToMediaItem(row, signedUrl);
-}
-
-/**
- * Generate a fresh signed URL for a storage path.
- * Call this every time you need to display a private media item.
- */
-export async function getSignedUrl(storagePath: string): Promise<string> {
-  const { data, error } = await supabase.storage
-    .from(BUCKET)
-    .createSignedUrl(storagePath, SIGNED_URL_EXPIRY_SECONDS);
-
-  if (error || !data?.signedUrl) {
-    throw new Error(`getSignedUrl: ${error?.message ?? 'no URL returned'}`);
-  }
-
-  return data.signedUrl;
-}
-
-/**
- * List all media items for the current user (RLS-filtered).
- * Signed URLs are generated in parallel for all items.
- */
-export async function listMedia(): Promise<MediaItem[]> {
-  const { data, error } = await supabase
-    .from('media')
-    .select('*')
-    .order('created_at', { ascending: false });
-
-  if (error) throw new Error(`listMedia: ${error.message}`);
-
-  const rows = data ?? [];
-  const signedUrls = await Promise.all(
-    rows.map((r) => getSignedUrl(r.storage_path).catch(() => ''))
-  );
-
-  return rows.map((row, i) => rowToMediaItem(row, signedUrls[i]));
-}
-
-/**
- * Delete a media row and its file from Storage.
- * Cascades to media_people via FK ON DELETE CASCADE.
- */
-export async function deleteMedia(mediaId: string, storagePath: string): Promise<void> {
-  const [{ error: dbError }, { error: storageError }] = await Promise.all([
-    supabase.from('media').delete().eq('id', mediaId),
-    supabase.storage.from(BUCKET).remove([storagePath]),
-  ]);
-
-  if (dbError) throw new Error(`deleteMedia db: ${dbError.message}`);
-  if (storageError) throw new Error(`deleteMedia storage: ${storageError.message}`);
-}
-
-// ── Helpers ──────────────────────────────────────────────────────────────────
-
-function inferKind(mimeType: string): 'photo' | 'video' | 'audio' | 'document' {
-  if (mimeType.startsWith('image/')) return 'photo';
-  if (mimeType.startsWith('video/')) return 'video';
-  if (mimeType.startsWith('audio/')) return 'audio';
-  return 'document';
-}
diff -ruN before/package.json after/package.json
--- before/package.json	2026-02-21 02:03:34.104190064 +0000
+++ after/package.json	2026-02-21 02:07:07.269188472 +0000
@@ -1,30 +1,32 @@
 {
-  "name": "eternal---family-archive",
+  "name": "eternal-family-archive",
   "private": true,
   "version": "0.0.0",
   "type": "module",
   "scripts": {
     "dev": "vercel dev",
-    "build": "vite build",
+    "dev:vite": "vite",
+    "build": "tsc --noEmit && vite build",
     "preview": "vite preview",
     "test": "vitest run --config vitest.config.ts",
-    "test:watch": "vitest --config vitest.config.ts",
-    "dev:vite": "vite"
+    "test:watch": "vitest --config vitest.config.ts"
   },
   "dependencies": {
-    "react": "^19.2.4",
-    "react-dom": "^19.2.4",
+    "@supabase/supabase-js": "^2.49.0",
     "lucide-react": "^0.563.0",
-    "@google/genai": "^1.40.0",
-    "@supabase/supabase-js": "^2.49.0"
+    "react": "^19.2.4",
+    "react-dom": "^19.2.4"
   },
   "devDependencies": {
+    "@google/genai": "^1.40.0",
     "@types/node": "^22.14.0",
+    "@types/react": "^19.0.0",
+    "@types/react-dom": "^19.0.0",
+    "@vercel/node": "^5.0.0",
     "@vitejs/plugin-react": "^5.0.0",
     "typescript": "~5.8.2",
+    "vercel": "^39.0.0",
     "vite": "^6.2.0",
-    "@vercel/node": "^5.0.0",
-    "vitest": "^2.0.0",
-    "vercel": "^39.0.0"
+    "vitest": "^2.0.0"
   }
 }
diff -ruN before/postRepo.ts after/postRepo.ts
--- before/postRepo.ts	2026-02-21 02:03:34.118190063 +0000
+++ after/postRepo.ts	1970-01-01 00:00:00.000000000 +0000
@@ -1,80 +0,0 @@
-// ---------------------------------------------------------------------------
-// repos/postRepo.ts
-// Posts are created with an optional list of tagged profile IDs.
-// Mentions are stored in post_people in the same transaction (via Promise.all
-// after insert — Supabase JS v2 does not yet support true multi-statement
-// transactions from the client, so we do a best-effort insert and surface
-// any failure clearly).
-// ---------------------------------------------------------------------------
-
-import { supabase } from '../lib/supabaseClient';
-import { rowToPost, postToInsert } from '../lib/mappers';
-import type { CirclePost } from '../types';
-
-/**
- * Insert a post and its tagged-profile join rows.
- * If mention insertion fails the post still exists; the error is logged but
- * not re-thrown so the UI stays responsive.
- */
-export async function createPost(post: CirclePost): Promise<CirclePost> {
-  // 1. Insert the post row.
-  const { data, error } = await supabase
-    .from('posts')
-    .insert(postToInsert(post))
-    .select()
-    .single();
-
-  if (error) throw new Error(`createPost: ${error.message}`);
-
-  // 2. Insert mention rows for each tagged profile.
-  if (post.taggedProfileIds.length > 0) {
-    const mentions = post.taggedProfileIds.map((profileId) => ({
-      post_id: data.id,
-      profile_id: profileId,
-      user_id: post.userId,
-    }));
-
-    const { error: mentionError } = await supabase
-      .from('post_people')
-      .insert(mentions);
-
-    if (mentionError) {
-      // Non-fatal: the post is saved, just log the partial failure.
-      console.error('createPost mentions insert failed:', mentionError.message);
-    }
-  }
-
-  return rowToPost(data, post.taggedProfileIds);
-}
-
-/**
- * List posts for the current user (RLS-filtered), newest first.
- * Fetches tagged profile IDs by joining post_people.
- */
-export async function listPosts(): Promise<CirclePost[]> {
-  // Fetch posts + their mentions in one query using PostgREST's nested select.
-  const { data, error } = await supabase
-    .from('posts')
-    .select(`
-      *,
-      post_people ( profile_id )
-    `)
-    .order('created_at', { ascending: false });
-
-  if (error) throw new Error(`listPosts: ${error.message}`);
-
-  return (data ?? []).map((row) => {
-    const taggedProfileIds = (row.post_people as { profile_id: string }[]).map(
-      (pp) => pp.profile_id
-    );
-    return rowToPost(row, taggedProfileIds);
-  });
-}
-
-/**
- * Delete a post. Cascades to post_people rows via FK ON DELETE CASCADE.
- */
-export async function deletePost(postId: string): Promise<void> {
-  const { error } = await supabase.from('posts').delete().eq('id', postId);
-  if (error) throw new Error(`deletePost: ${error.message}`);
-}
diff -ruN before/profileRepo.ts after/profileRepo.ts
--- before/profileRepo.ts	2026-02-21 02:03:34.133190063 +0000
+++ after/profileRepo.ts	1970-01-01 00:00:00.000000000 +0000
@@ -1,80 +0,0 @@
-// ---------------------------------------------------------------------------
-// repos/profileRepo.ts
-// Profiles are bulk-upserted on GEDCOM import, and individually upserted
-// whenever the user edits a profile in the app.
-// ---------------------------------------------------------------------------
-
-import { supabase } from '../lib/supabaseClient';
-import { rowToProfile, profileToInsert } from '../lib/mappers';
-import type { Profile } from '../types';
-
-/**
- * Insert or update a single profile.
- * Pass `treeId` when creating during a GEDCOM import so the profile is
- * associated with the new tree.
- */
-export async function upsertProfile(
-  profile: Profile,
-  treeId?: string
-): Promise<Profile> {
-  const { data, error } = await supabase
-    .from('profiles')
-    .upsert(profileToInsert(profile, treeId), { onConflict: 'id' })
-    .select()
-    .single();
-
-  if (error) throw new Error(`upsertProfile: ${error.message}`);
-  return rowToProfile(data);
-}
-
-/**
- * Bulk upsert — used during a GEDCOM import where hundreds of profiles
- * arrive at once. Batches into chunks of 200 to stay within Supabase limits.
- */
-export async function upsertProfiles(
-  profiles: Profile[],
-  treeId?: string
-): Promise<Profile[]> {
-  const CHUNK = 200;
-  const results: Profile[] = [];
-
-  for (let i = 0; i < profiles.length; i += CHUNK) {
-    const chunk = profiles.slice(i, i + CHUNK);
-    const { data, error } = await supabase
-      .from('profiles')
-      .upsert(
-        chunk.map((p) => profileToInsert(p, treeId)),
-        { onConflict: 'id' }
-      )
-      .select();
-
-    if (error) throw new Error(`upsertProfiles (chunk ${i}): ${error.message}`);
-    results.push(...(data ?? []).map(rowToProfile));
-  }
-
-  return results;
-}
-
-/**
- * List every profile that belongs to the current user.
- * Optionally scope to a single tree.
- */
-export async function listProfiles(treeId?: string): Promise<Profile[]> {
-  let query = supabase.from('profiles').select('*');
-
-  if (treeId) {
-    query = query.eq('tree_id', treeId);
-  }
-
-  const { data, error } = await query.order('name', { ascending: true });
-  if (error) throw new Error(`listProfiles: ${error.message}`);
-  return (data ?? []).map(rowToProfile);
-}
-
-/**
- * Hard-delete a profile. Cascades to post_people and media_people via FK.
- */
-export async function deleteProfile(profileId: string): Promise<void> {
-  const { error } = await supabase.from('profiles').delete().eq('id', profileId);
-  if (error) throw new Error(`deleteProfile: ${error.message}`);
-}
diff -ruN before/services/gemini.ts after/services/gemini.ts
--- before/services/gemini.ts	2026-02-21 02:03:34.175190063 +0000
+++ after/services/gemini.ts	1970-01-01 00:00:00.000000000 +0000
@@ -1,78 +0,0 @@
-
-import { GoogleGenAI, Type } from "@google/genai";
-import { Profile } from "../types";
-import { formatEventSentence } from "../utils/formatters";
-
-export const generateAiProfileSummary = async (profile: Profile): Promise<string> => {
-  const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
-  
-  const events = profile.timeline.map(ev => formatEventSentence(profile.name, ev)).join('\n');
-  const memories = profile.memories.map(m => m.content).join('\n');
-  
-  const prompt = `
-    Generate a respectful, high-quality, narrative life summary for ${profile.name} (born ${profile.birthYear}).
-    Use the following timeline events and family stories to weave a cohesive biographical sketch.
-    
-    Timeline:
-    ${events}
-    
-    Family Stories:
-    ${memories}
-    
-    Instructions:
-    - Focus on the impact of their life.
-    - Keep it under 250 words.
-    - Maintain an archival, historical, and elegant tone.
-  `;
-
-  try {
-    const response = await ai.models.generateContent({
-      model: 'gemini-2.0-flash',
-      contents: prompt,
-    });
-    return response.text || "Summary unavailable.";
-  } catch (error) {
-    console.error("Gemini AI error:", error);
-    return "Failed to generate AI summary.";
-  }
-};
-
-export const getHistoricalContext = async (profile: Profile): Promise<{ text: string, sources: any[] }> => {
-  const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
-  
-  const lifePeriod = `${profile.birthYear} to ${profile.deathYear || 'the present'}`;
-  const locations = Array.from(new Set(profile.timeline.map(e => e.place).filter(Boolean))).join(', ');
-  
-  const prompt = `Provide a comprehensive historical deep-dive into the era and specific locations inhabited by ${profile.name} during their life from ${lifePeriod}. 
-  The primary locations were: ${locations}.
-  
-  Research and describe:
-  1. Specific local history and atmosphere of ${locations} during these decades.
-  2. Major global events (wars, movements, economic shifts) that significantly altered their daily world.
-  3. Technological innovations or cultural changes that a person living in ${locations} would have witnessed.
-  
-  Format this as a "Historical Narrative" for a family archive. Be specific, evocative, and archival in tone.`;
-
-  try {
-    const response = await ai.models.generateContent({
-      model: 'gemini-2.5-pro-preview-05-06',
-      contents: prompt,
-      config: {
-        tools: [{ googleSearch: {} }]
-      }
-    });
-
-    const sources = response.candidates?.[0]?.groundingMetadata?.groundingChunks || [];
-    
-    return {
-      text: response.text || "Historical research unavailable.",
-      sources: sources
-    };
-  } catch (error) {
-    console.error("Gemini Research Error:", error);
-    return { 
-      text: "Our digital archives could not be reached. Please check your connection and try again.", 
-      sources: [] 
-    };
-  }
-};
diff -ruN before/services.gemini.ts after/services.gemini.ts
--- before/services.gemini.ts	2026-02-21 02:03:34.161190063 +0000
+++ after/services.gemini.ts	1970-01-01 00:00:00.000000000 +0000
@@ -1,126 +0,0 @@
-// services/gemini.ts
-// All Gemini calls now proxy through /api/gemini (a Vercel serverless function).
-// No @google/genai import, no API key, no process.env in this file.
-
-import type { Profile } from '../types';
-import { formatEventSentence } from '../utils/formatters';
-
-// ── Shared transport ──────────────────────────────────────────────────────────
-
-const ENDPOINT = '/api/gemini';
-
-interface SummaryResponse  { text: string }
-interface ResearchResponse { text: string; sources: GroundingSource[] }
-interface PortraitResponse { imageBase64: string }
-interface ErrorResponse    { error: string }
-
-interface GroundingSource {
-  web?: { uri: string; title: string };
-}
-
-type ApiAction = 'summary' | 'research' | 'portrait';
-
-async function callGemini(action: ApiAction, prompt: string): Promise<Response> {
-  return fetch(ENDPOINT, {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ action, prompt }),
-  });
-}
-
-/** Parse the response, throwing a human-readable message on failure. */
-async function parseOrThrow<T>(res: Response): Promise<T> {
-  const body = await res.json() as T | ErrorResponse;
-  if (!res.ok) {
-    const msg = (body as ErrorResponse).error ?? `Server error ${res.status}`;
-    throw new Error(msg);
-  }
-  return body as T;
-}
-
-// ── Public API (same signatures as the original service) ─────────────────────
-
-/**
- * Generate a narrative life summary for a profile.
- * Model: gemini-2.0-flash (server-side)
- */
-export async function generateAiProfileSummary(profile: Profile): Promise<string> {
-  const events = profile.timeline
-    .map((ev) => formatEventSentence(profile.name, ev))
-    .join('\n');
-  const memories = profile.memories.map((m) => m.content).join('\n');
-
-  const prompt = `
-Generate a respectful, high-quality, narrative life summary for ${profile.name} (born ${profile.birthYear}).
-Use the following timeline events and family stories to weave a cohesive biographical sketch.
-
-Timeline:
-${events}
-
-Family Stories:
-${memories}
-
-Instructions:
-- Focus on the impact of their life.
-- Keep it under 250 words.
-- Maintain an archival, historical, and elegant tone.
-`.trim();
-
-  try {
-    const res = await callGemini('summary', prompt);
-    const data = await parseOrThrow<SummaryResponse>(res);
-    return data.text;
-  } catch (err) {
-    console.error('[gemini] generateAiProfileSummary:', err);
-    return 'Failed to generate AI summary.';
-  }
-}
-
-/**
- * Fetch grounded historical context for a profile's life period and locations.
- * Model: gemini-2.5-pro-preview-05-06 with Google Search grounding (server-side)
- */
-export async function getHistoricalContext(
-  profile: Profile
-): Promise<{ text: string; sources: GroundingSource[] }> {
-  const lifePeriod = `${profile.birthYear} to ${profile.deathYear || 'the present'}`;
-  const locations = Array.from(
-    new Set(profile.timeline.map((e) => e.place).filter(Boolean))
-  ).join(', ');
-
-  const prompt = `Provide a comprehensive historical deep-dive into the era and specific locations inhabited by ${profile.name} during their life from ${lifePeriod}.
-The primary locations were: ${locations}.
-
-Research and describe:
-1. Specific local history and atmosphere of ${locations} during these decades.
-2. Major global events (wars, movements, economic shifts) that significantly altered their daily world.
-3. Technological innovations or cultural changes that a person living in ${locations} would have witnessed.
-
-Format this as a "Historical Narrative" for a family archive. Be specific, evocative, and archival in tone.`.trim();
-
-  try {
-    const res = await callGemini('research', prompt);
-    const data = await parseOrThrow<ResearchResponse>(res);
-    return { text: data.text, sources: data.sources ?? [] };
-  } catch (err) {
-    console.error('[gemini] getHistoricalContext:', err);
-    return {
-      text: 'Our digital archives could not be reached. Please check your connection and try again.',
-      sources: [],
-    };
-  }
-}
-
-/**
- * Generate an AI portrait image for a profile.
- * Model: gemini-2.0-flash-preview-image-generation (server-side)
- * Returns a data URL string ready to assign to profile.imageUrl.
- * Throws on failure so the caller (App.tsx) can catch and show a toast.
- */
-export async function generateAiPortrait(profile: Profile): Promise<string> {
-  const prompt = `A period-accurate, elegant studio portrait of a person named ${profile.name} born in ${profile.birthYear}. Style: historical photographic daguerreotype or charcoal sketch, highly detailed, archival museum quality.`;
-
-  const res = await callGemini('portrait', prompt);
-  const data = await parseOrThrow<PortraitResponse>(res);
-  return `data:image/png;base64,${data.imageBase64}`;
-}
diff -ruN before/src/App.tsx after/src/App.tsx
--- before/src/App.tsx	1970-01-01 00:00:00.000000000 +0000
+++ after/src/App.tsx	2026-02-21 02:06:53.663188574 +0000
@@ -0,0 +1,401 @@
+import React, { useState, useRef, useMemo } from 'react';
+import { useSession } from './hooks/useSession';
+import { useArchiveStore } from './hooks/useArchiveStore';
+import { useGedcomImport } from './hooks/useGedcomImport';
+import { useProfileEditor } from './hooks/useProfileEditor';
+import { useMediaAttach } from './hooks/useMediaAttach';
+import {
+  LogOut, Search, GitBranch, Check, ChevronRight,
+} from 'lucide-react';
+import { Profile, FamilyTree, AppView } from './types';
+import { parseGedcomDate } from './utils/date';
+import { getFuzzyScore } from './utils/search';
+import { generateAiProfileSummary, getHistoricalContext, generateAiPortrait } from './services/gemini';
+import Auth from './components/Auth';
+import SplashView from './views/SplashView';
+import TreesView from './views/TreesView';
+import TreeView from './views/TreeView';
+import SelectHomeView from './views/SelectHomeView';
+import ProfileView from './views/ProfileView';
+import EditProfileView from './views/EditProfileView';
+import LinkRelativeView from './views/LinkRelativeView';
+import CreateMemoryView from './views/CreateMemoryView';
+import FamilyCircleView from './views/FamilyCircleView';
+
+const App: React.FC = () => {
+  const [toast, setToast] = useState<{ message: string } | null>(null);
+  const [isAiLoading, setIsAiLoading] = useState(false);
+  const [isResearchLoading, setIsResearchLoading] = useState(false);
+  const [isGeneratingPortrait, setIsGeneratingPortrait] = useState(false);
+  const [searchQuery, setSearchQuery] = useState('');
+  const [showSearchResults, setShowSearchResults] = useState(false);
+  const [attachingToEventId, setAttachingToEventId] = useState<string | null>(null);
+
+  const showToast = (message: string) => {
+    setToast({ message });
+    setTimeout(() => setToast(null), 3000);
+  };
+
+  const session = useSession();
+  const store = useArchiveStore(session.user);
+  const { activeProfile, selectedTreeForView } = store;
+
+  const gedcom = useGedcomImport({
+    user: session.user,
+    setView: session.setView,
+    setProfiles: store.setProfiles,
+    setFamilyTrees: store.setFamilyTrees,
+    setSelectedTreeId: store.setSelectedTreeId,
+    setActiveProfileId: store.setActiveProfileId,
+    toast: showToast,
+  });
+
+  const editor = useProfileEditor({
+    activeProfile: store.activeProfile,
+    activeProfileId: store.activeProfileId,
+    setProfiles: store.setProfiles,
+    toast: showToast,
+  });
+
+  const profilePhotoFileInputRef = useRef<HTMLInputElement>(null);
+  const searchInputRef = useRef<HTMLInputElement>(null);
+
+  const media = useMediaAttach({
+    user: session.user,
+    activeProfileId: store.activeProfileId,
+    view: session.view,
+    attachingToEventId,
+    setAttachingToEventId,
+    setProfiles: store.setProfiles,
+    setEditImageUrl: editor.setEditImageUrl,
+    toast: showToast,
+  });
+
+  const handleLogout = async () => {
+    store.clearAll();
+    await session.logout();
+    showToast('Signed out');
+  };
+
+  const handleGeneratePortrait = async () => {
+    if (!activeProfile) return;
+    setIsGeneratingPortrait(true);
+    showToast('Generating historical portrait...');
+    try {
+      const dataUrl = await generateAiPortrait(activeProfile);
+      store.setProfiles(prev =>
+        prev.map(p => p.id === store.activeProfileId ? { ...p, imageUrl: dataUrl } : p)
+      );
+      showToast('AI Portrait Created');
+    } catch (err) {
+      console.error(err);
+      showToast('Failed to generate portrait');
+    } finally {
+      setIsGeneratingPortrait(false);
+    }
+  };
+
+  const handleGenerateSummary = async () => {
+    if (!activeProfile) return;
+    setIsAiLoading(true);
+    const summary = await generateAiProfileSummary(activeProfile);
+    store.setProfiles(prev =>
+      prev.map(p => p.id === store.activeProfileId ? { ...p, summary } : p)
+    );
+    setIsAiLoading(false);
+    showToast('AI Summary Generated');
+  };
+
+  const handleResearch = async () => {
+    if (!activeProfile) return;
+    setIsResearchLoading(true);
+    showToast('Mining historical archives...');
+    const context = await getHistoricalContext(activeProfile);
+    store.setProfiles(prev =>
+      prev.map(p => p.id === store.activeProfileId ? { ...p, historicalContext: context } : p)
+    );
+    setIsResearchLoading(false);
+    showToast('Historical Research Complete');
+  };
+
+  const searchResults = useMemo(() => {
+    const query = searchQuery.trim();
+    if (!query) return [];
+    return store.profiles
+      .map(profile => ({ profile, score: getFuzzyScore(profile.name, query) }))
+      .filter(item => item.score > 0)
+      .sort((a, b) => b.score - a.score)
+      .slice(0, 10)
+      .map(item => item.profile);
+  }, [searchQuery, store.profiles]);
+
+  const sortedTimeline = useMemo(() => {
+    if (!activeProfile) return [];
+    return [...activeProfile.timeline].sort(
+      (a, b) => parseGedcomDate(a.date) - parseGedcomDate(b.date)
+    );
+  }, [activeProfile]);
+  void sortedTimeline; // consumed by ProfileView via activeProfile prop
+
+  const renderContent = () => {
+    // ── Auth gate: every view except SPLASH and LOGIN requires a session ──────
+    const isPublicView = session.view === AppView.SPLASH || session.view === AppView.LOGIN;
+    if (!isPublicView && !session.user) {
+      return <Auth onLogin={session.login} />;
+    }
+
+    switch (session.view) {
+      case AppView.SPLASH:
+        return <SplashView />;
+
+      case AppView.LOGIN:
+        return <Auth onLogin={session.login} />;
+
+      case AppView.SELECT_HOME:
+        return (
+          <SelectHomeView
+            pendingImport={gedcom.pendingImport}
+            onBack={() => session.setView(AppView.HOME)}
+            onChooseHome={gedcom.chooseHome}
+          />
+        );
+
+      case AppView.TREES:
+        return (
+          <TreesView
+            trees={store.familyTrees}
+            selectedTreeId={store.selectedTreeId}
+            onBack={() => session.setView(AppView.HOME)}
+            onSelectTree={id => store.setSelectedTreeId(id)}
+            onOpenTree={id => { store.setTreeViewId(id); session.setView(AppView.TREE_VIEW); }}
+          />
+        );
+
+      case AppView.TREE_VIEW:
+        if (!selectedTreeForView) return null;
+        return (
+          <TreeView
+            tree={selectedTreeForView}
+            profiles={store.profiles}
+            onBack={() => session.setView(AppView.TREES)}
+            onOpenProfile={id => { store.setActiveProfileId(id); session.setView(AppView.PROFILE); }}
+          />
+        );
+
+      case AppView.FAMILY_CIRCLE:
+        return (
+          <FamilyCircleView
+            user={session.user!}
+            profiles={store.profiles}
+            posts={store.circlePosts}
+            onBack={() => session.setView(AppView.HOME)}
+            onAddPost={store.addCirclePost}
+            onDeletePost={store.deleteCirclePost}
+            onProfileClick={profileId => {
+              store.setActiveProfileId(profileId);
+              session.setView(AppView.PROFILE);
+            }}
+          />
+        );
+
+      case AppView.HOME:
+        return (
+          <div className="flex flex-col h-full bg-[#f9f8f6]">
+            <header className="pt-16 px-8 pb-6 bg-[#f5f2eb] border-b border-stone-200">
+              <div className="flex justify-between items-start mb-6">
+                <div>
+                  <h2 className="text-3xl font-serif text-slate-800">Archive</h2>
+                  <p className="text-stone-400 text-[10px] font-bold uppercase">{session.user?.name}</p>
+                </div>
+                <button onClick={handleLogout} className="p-2 bg-white rounded-full border border-stone-200 text-stone-300 hover:text-red-500">
+                  <LogOut size={18} />
+                </button>
+              </div>
+              <div className="relative">
+                <Search className="absolute left-4 top-1/2 -translate-y-1/2 text-stone-300" size={18} />
+                <input
+                  ref={searchInputRef}
+                  value={searchQuery}
+                  onChange={e => { setSearchQuery(e.target.value); setShowSearchResults(true); }}
+                  placeholder="Find a family member..."
+                  className="w-full bg-white border border-stone-100 rounded-2xl py-3 pl-12 pr-4 outline-none font-serif shadow-sm focus:ring-2 focus:ring-amber-200"
+                />
+                {showSearchResults && searchQuery.trim() && (
+                  <div className="absolute top-full left-0 right-0 mt-2 bg-white border rounded-2xl shadow-xl z-30 overflow-hidden max-h-96">
+                    {searchResults.length > 0 ? searchResults.map(p => (
+                      <button
+                        key={p.id}
+                        onClick={() => { store.setActiveProfileId(p.id); session.setView(AppView.PROFILE); setShowSearchResults(false); setSearchQuery(''); }}
+                        className="w-full text-left px-4 py-3 hover:bg-stone-50 border-b last:border-0 flex items-center space-x-3"
+                      >
+                        <img src={p.imageUrl} className="w-10 h-10 rounded-xl object-cover grayscale" alt={p.name} />
+                        <div>
+                          <span className="font-serif text-sm block">{p.name}</span>
+                          <span className="text-[10px] text-stone-300 uppercase">{p.birthYear} — {p.deathYear || '...'}</span>
+                        </div>
+                      </button>
+                    )) : (
+                      <div className="p-8 text-center text-xs font-serif text-stone-300">No records found.</div>
+                    )}
+                  </div>
+                )}
+              </div>
+            </header>
+
+            <main className="flex-1 p-8 space-y-8 overflow-y-auto scrollbar-hide pb-20">
+              {store.profiles.length === 0 ? (
+                <div className="py-20 text-center space-y-6">
+                  <GitBranch size={48} className="mx-auto text-stone-200" />
+                  <p className="font-serif text-stone-500 italic">Archive is empty.</p>
+                  {/* Gate: only render the upload trigger when authenticated */}
+                  {session.user && (
+                    <label
+                      htmlFor="gedcomFile"
+                      className="bg-stone-900 text-white px-8 py-4 rounded-full font-bold uppercase tracking-widest text-[11px] inline-block cursor-pointer"
+                    >
+                      Import GEDCOM
+                    </label>
+                  )}
+                </div>
+              ) : (
+                <section className="space-y-4">
+                  <div className="flex justify-between items-center px-2">
+                    <h3 className="text-[10px] font-bold uppercase tracking-widest text-stone-400">Library</h3>
+                    <div className="flex items-center gap-3">
+                      <button onClick={() => session.setView(AppView.FAMILY_CIRCLE)} className="text-[10px] font-bold uppercase text-amber-600">Circle</button>
+                      <button onClick={() => session.setView(AppView.TREES)} className="text-[10px] font-bold uppercase text-amber-600">Trees</button>
+                    </div>
+                  </div>
+                  <div className="grid gap-3">
+                    {store.profiles.slice(0, 10).map(p => (
+                      <button
+                        key={p.id}
+                        onClick={() => { store.setActiveProfileId(p.id); session.setView(AppView.PROFILE); }}
+                        className="w-full bg-white p-4 rounded-[32px] shadow-sm border border-stone-50 flex items-center space-x-4 hover:shadow-md transition-all"
+                      >
+                        <img src={p.imageUrl} className="w-14 h-14 rounded-2xl object-cover grayscale" alt={p.name} />
+                        <div className="text-left flex-1">
+                          <h4 className="font-serif text-xl">{p.name}</h4>
+                          <p className="text-[10px] text-stone-400 font-black uppercase mt-1">{p.birthYear} — {p.deathYear || '...'}</p>
+                        </div>
+                        <ChevronRight className="text-stone-200" size={18} />
+                      </button>
+                    ))}
+                  </div>
+                </section>
+              )}
+            </main>
+
+            {/* File input absent from DOM when unauthenticated — removes the .click() attack vector */}
+            {session.user && (
+              <input
+                id="gedcomFile"
+                type="file"
+                ref={gedcom.gedFileInputRef}
+                onChange={gedcom.handleGedcomUpload}
+                accept=".ged,.GED,.gedcom,.txt,text/plain"
+                style={{ position: 'absolute', width: 1, height: 1, opacity: 0, pointerEvents: 'none' }}
+              />
+            )}
+          </div>
+        );
+
+      case AppView.PROFILE:
+        if (!activeProfile) return null;
+        return (
+          <ProfileView
+            activeProfile={activeProfile}
+            profiles={store.profiles}
+            familyTrees={store.familyTrees}
+            selectedTreeId={store.selectedTreeId}
+            onBack={() => session.setView(AppView.HOME)}
+            onEdit={() => { editor.startEdit(); session.setView(AppView.EDIT_PROFILE); }}
+            onLinkRelative={role => { editor.setLinkRole(role); session.setView(AppView.LINK_RELATIVE); }}
+            onDeleteProfile={() => {
+              const did = editor.deleteProfile(window.confirm);
+              if (did) {
+                if (store.activeProfileId) store.deleteProfileById(store.activeProfileId);
+                session.setView(AppView.HOME);
+              }
+            }}
+            onSetActiveProfile={id => { store.setActiveProfileId(id); session.setView(AppView.PROFILE); }}
+            onUploadMediaClick={() => profilePhotoFileInputRef.current?.click()}
+            onMediaFileChange={media.handleProfilePhotoUpload}
+            mediaInputRef={profilePhotoFileInputRef}
+            onEventMediaUpload={media.handleEventMediaUpload}
+            attachingToEventId={attachingToEventId}
+            setAttachingToEventId={setAttachingToEventId}
+            isAiLoading={isAiLoading}
+            isResearchLoading={isResearchLoading}
+            isPhotoLoading={media.isPhotoLoading}
+            isGeneratingPortrait={isGeneratingPortrait}
+            onGenerateSummary={handleGenerateSummary}
+            onResearch={handleResearch}
+            onGeneratePortrait={handleGeneratePortrait}
+            showToast={showToast}
+          />
+        );
+
+      case AppView.EDIT_PROFILE:
+        return (
+          <EditProfileView
+            editName={editor.editName}
+            setEditName={editor.setEditName}
+            editGender={editor.editGender}
+            setEditGender={editor.setEditGender}
+            editBirthYear={editor.editBirthYear}
+            setEditBirthYear={editor.setEditBirthYear}
+            editDeathYear={editor.editDeathYear}
+            setEditDeathYear={editor.setEditDeathYear}
+            editImageUrl={editor.editImageUrl}
+            setEditImageUrl={editor.setEditImageUrl}
+            onBack={() => session.setView(AppView.PROFILE)}
+            onSave={() => { editor.saveEdit(); session.setView(AppView.PROFILE); }}
+          />
+        );
+
+      case AppView.LINK_RELATIVE:
+        return (
+          <LinkRelativeView
+            linkRole={editor.linkRole}
+            searchQuery={searchQuery}
+            setSearchQuery={setSearchQuery}
+            searchResults={searchResults}
+            onBack={() => session.setView(AppView.PROFILE)}
+            onSelect={p => { editor.linkRelative(p); session.setView(AppView.PROFILE); setSearchQuery(''); }}
+          />
+        );
+
+      case AppView.CREATE_MEMORY:
+        return (
+          <CreateMemoryView
+            newMemoryInput={editor.newMemoryInput}
+            setNewMemoryInput={editor.setNewMemoryInput}
+            onBack={() => session.setView(AppView.PROFILE)}
+            onSave={() => { editor.saveMemory(); session.setView(AppView.PROFILE); }}
+          />
+        );
+
+      default:
+        return null;
+    }
+  };
+
+  return (
+    <div className="min-h-screen bg-[#e5e1d8] flex flex-col items-center justify-center p-4">
+      <div className="relative w-full h-[90vh] md:w-[390px] md:h-[844px] bg-white rounded-[40px] shadow-2xl overflow-hidden border-8 border-stone-800">
+        <div className="w-full h-full relative overflow-hidden">{renderContent()}</div>
+        {toast && (
+          <div className="absolute bottom-10 left-1/2 -translate-x-1/2 z-[200] animate-bounce">
+            <div className="bg-stone-900 text-white px-6 py-3 rounded-full shadow-2xl flex items-center space-x-3 text-[10px] font-bold uppercase">
+              <Check size={14} className="text-emerald-500" />
+              <span>{toast.message}</span>
+            </div>
+          </div>
+        )}
+      </div>
+    </div>
+  );
+};
+
+export default App;
diff -ruN before/src/components/Auth.tsx after/src/components/Auth.tsx
--- before/src/components/Auth.tsx	1970-01-01 00:00:00.000000000 +0000
+++ after/src/components/Auth.tsx	2026-02-21 02:04:32.500189628 +0000
@@ -0,0 +1,192 @@
+// components/Auth.tsx
+//
+// Authentication UI backed by Supabase Auth.
+// All credential handling is done server-side by Supabase — no passwords
+// are ever read, stored, or compared in client-side code.
+
+import React, { useState } from 'react';
+import { Anchor, RefreshCw, Eye, EyeOff } from 'lucide-react';
+import type { User } from '../types';
+import { supabase } from '../lib/supabaseClient';
+
+interface AuthProps {
+  // Called with the resolved User after a successful sign-in or sign-up.
+  // useSession.onAuthStateChange also fires, so the view transition happens
+  // from there — this callback lets App.tsx stay consistent.
+  onLogin: (user: User) => void;
+}
+
+const Auth: React.FC<AuthProps> = ({ onLogin }) => {
+  const [email, setEmail] = useState('');
+  const [password, setPassword] = useState('');
+  const [displayName, setDisplayName] = useState('');
+  const [showPassword, setShowPassword] = useState(false);
+  const [isLoading, setIsLoading] = useState(false);
+  const [error, setError] = useState('');
+  const [mode, setMode] = useState<'signin' | 'signup'>('signin');
+
+  const handleSignIn = async () => {
+    if (!email || !password) { setError('Email and password are required.'); return; }
+    setIsLoading(true);
+    setError('');
+
+    const { data, error: sbError } = await supabase.auth.signInWithPassword({
+      email: email.trim(),
+      password,
+    });
+
+    if (sbError || !data.session) {
+      setError(sbError?.message ?? 'Sign in failed. Please try again.');
+      setIsLoading(false);
+      return;
+    }
+
+    // Map Supabase session to our User type.
+    const u: User = {
+      id: data.user.id,
+      email: data.user.email ?? '',
+      name: (data.user.user_metadata?.display_name as string | undefined)
+        ?? data.user.email?.split('@')[0]
+        ?? 'User',
+      createdAt: data.user.created_at,
+    };
+    setIsLoading(false);
+    onLogin(u);
+  };
+
+  const handleSignUp = async () => {
+    if (!email || !password) { setError('Email and password are required.'); return; }
+    if (password.length < 8) { setError('Password must be at least 8 characters.'); return; }
+    setIsLoading(true);
+    setError('');
+
+    const name = displayName.trim() || email.split('@')[0];
+
+    const { data, error: sbError } = await supabase.auth.signUp({
+      email: email.trim(),
+      password,
+      options: {
+        data: { display_name: name },
+      },
+    });
+
+    if (sbError) {
+      setError(sbError.message);
+      setIsLoading(false);
+      return;
+    }
+
+    // Supabase may require email confirmation depending on project settings.
+    // If a session is returned immediately, log the user in now.
+    if (data.session) {
+      const u: User = {
+        id: data.user!.id,
+        email: data.user!.email ?? '',
+        name,
+        createdAt: data.user!.created_at,
+      };
+      setIsLoading(false);
+      onLogin(u);
+    } else {
+      // Email confirmation required — tell the user.
+      setError('');
+      setIsLoading(false);
+      // Reuse error slot for info message (styled below).
+      setError('CHECK_EMAIL');
+    }
+  };
+
+  const isCheckEmail = error === 'CHECK_EMAIL';
+
+  return (
+    <div className="flex flex-col h-full bg-[#f5f2eb] p-8 overflow-y-auto">
+      <header className="mt-16 mb-12 text-center space-y-4">
+        <div className="w-16 h-16 bg-stone-900 rounded-2xl flex items-center justify-center text-white mx-auto shadow-xl">
+          <Anchor size={32} />
+        </div>
+        <h2 className="text-4xl font-serif">Eternal</h2>
+        <p className="text-stone-400 text-xs italic">Family Archive Platform</p>
+      </header>
+
+      {/* Error / info banner */}
+      {error && !isCheckEmail && (
+        <div className="mb-4 p-4 bg-red-50 text-red-700 text-[10px] font-bold uppercase text-center rounded-xl border border-red-100">
+          {error}
+        </div>
+      )}
+      {isCheckEmail && (
+        <div className="mb-4 p-4 bg-amber-50 text-amber-800 text-[10px] font-bold uppercase text-center rounded-xl border border-amber-100">
+          Check your email to confirm your account, then sign in.
+        </div>
+      )}
+
+      {/* Mode toggle */}
+      <div className="flex mb-6 bg-stone-100 rounded-2xl p-1">
+        <button
+          onClick={() => { setMode('signin'); setError(''); }}
+          className={`flex-1 py-2 rounded-xl text-[11px] font-bold uppercase transition-all ${mode === 'signin' ? 'bg-white shadow text-stone-900' : 'text-stone-400'}`}
+        >
+          Sign In
+        </button>
+        <button
+          onClick={() => { setMode('signup'); setError(''); }}
+          className={`flex-1 py-2 rounded-xl text-[11px] font-bold uppercase transition-all ${mode === 'signup' ? 'bg-white shadow text-stone-900' : 'text-stone-400'}`}
+        >
+          Register
+        </button>
+      </div>
+
+      <div className="space-y-4">
+        {mode === 'signup' && (
+          <input
+            type="text"
+            value={displayName}
+            onChange={(e) => setDisplayName(e.target.value)}
+            placeholder="Display name (optional)"
+            className="w-full bg-white border rounded-2xl py-4 px-6 font-serif outline-none shadow-sm text-stone-900 placeholder-stone-400"
+          />
+        )}
+
+        <input
+          type="email"
+          value={email}
+          onChange={(e) => setEmail(e.target.value)}
+          placeholder="Email"
+          autoComplete="email"
+          className="w-full bg-white border rounded-2xl py-4 px-6 font-serif outline-none shadow-sm text-stone-900 placeholder-stone-400"
+        />
+
+        <div className="relative">
+          <input
+            type={showPassword ? 'text' : 'password'}
+            value={password}
+            onChange={(e) => setPassword(e.target.value)}
+            onKeyDown={(e) => e.key === 'Enter' && (mode === 'signin' ? handleSignIn() : handleSignUp())}
+            placeholder="Password"
+            autoComplete={mode === 'signup' ? 'new-password' : 'current-password'}
+            className="w-full bg-white border rounded-2xl py-4 px-6 font-serif outline-none shadow-sm text-stone-900 placeholder-stone-400"
+          />
+          <button
+            type="button"
+            onClick={() => setShowPassword(!showPassword)}
+            className="absolute right-4 top-1/2 -translate-y-1/2 text-stone-300"
+          >
+            {showPassword ? <Eye size={18} /> : <EyeOff size={18} />}
+          </button>
+        </div>
+
+        <button
+          onClick={mode === 'signin' ? handleSignIn : handleSignUp}
+          disabled={isLoading}
+          className="w-full bg-stone-900 text-white py-5 rounded-2xl font-bold uppercase text-[11px] shadow-lg flex items-center justify-center space-x-2 disabled:opacity-60"
+        >
+          {isLoading
+            ? <RefreshCw className="animate-spin" size={16} />
+            : <span>{mode === 'signin' ? 'Sign In' : 'Create Account'}</span>}
+        </button>
+      </div>
+    </div>
+  );
+};
+
+export default Auth;
diff -ruN before/src/components/ErrorBoundary.tsx after/src/components/ErrorBoundary.tsx
--- before/src/components/ErrorBoundary.tsx	1970-01-01 00:00:00.000000000 +0000
+++ after/src/components/ErrorBoundary.tsx	2026-02-21 02:04:32.506189627 +0000
@@ -0,0 +1,34 @@
+import React from 'react';
+
+type Props = { children: React.ReactNode };
+type State = { error: Error | null };
+
+export default class ErrorBoundary extends React.Component<Props, State> {
+  state: State = { error: null };
+
+  static getDerivedStateFromError(error: Error): State {
+    return { error };
+  }
+
+  componentDidCatch(error: Error, info: React.ErrorInfo) {
+    // eslint-disable-next-line no-console
+    console.error('ErrorBoundary caught error', error, info);
+  }
+
+  render() {
+    if (this.state.error) {
+      return (
+        <div className="min-h-screen bg-[#f9f8f6] p-8">
+          <h1 className="text-xl font-bold text-slate-900">Something went wrong</h1>
+          <p className="mt-2 text-sm text-slate-600">
+            The app hit a runtime error right after an action. Open your browser console for details.
+          </p>
+          <pre className="mt-6 whitespace-pre-wrap rounded-xl bg-white p-4 text-xs text-slate-900 border border-stone-200 overflow-auto">
+{String(this.state.error.message || this.state.error)}
+          </pre>
+        </div>
+      );
+    }
+    return this.props.children;
+  }
+}
diff -ruN before/src/components/circle/CircleFeed.tsx after/src/components/circle/CircleFeed.tsx
--- before/src/components/circle/CircleFeed.tsx	1970-01-01 00:00:00.000000000 +0000
+++ after/src/components/circle/CircleFeed.tsx	2026-02-21 02:04:32.517189628 +0000
@@ -0,0 +1,176 @@
+import React, { useState } from 'react';
+import { Trash2, Image, FileText, Music, Video, ChevronDown, ChevronUp } from 'lucide-react';
+import { CircleAttachment, CirclePost, Profile } from '../../types';
+
+interface CircleFeedProps {
+  posts: CirclePost[];
+  profiles: Profile[];
+  currentUserId: string;
+  onDeletePost: (id: string) => void;
+  onProfileClick: (profileId: string) => void;
+}
+
+const formatRelativeTime = (iso: string): string => {
+  const diff = Date.now() - new Date(iso).getTime();
+  const mins = Math.floor(diff / 60000);
+  if (mins < 1) return 'Just now';
+  if (mins < 60) return `${mins}m ago`;
+  const hrs = Math.floor(mins / 60);
+  if (hrs < 24) return `${hrs}h ago`;
+  const days = Math.floor(hrs / 24);
+  if (days < 7) return `${days}d ago`;
+  return new Date(iso).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
+};
+
+const AttachmentKindIcon = ({ kind }: { kind: CircleAttachment['kind'] }) => {
+  if (kind === 'photo') return <Image size={12} />;
+  if (kind === 'video') return <Video size={12} />;
+  if (kind === 'audio') return <Music size={12} />;
+  return <FileText size={12} />;
+};
+
+const PostCard: React.FC<{
+  post: CirclePost;
+  profiles: Profile[];
+  isOwn: boolean;
+  onDelete: () => void;
+  onProfileClick: (id: string) => void;
+}> = ({ post, profiles, isOwn, onDelete, onProfileClick }) => {
+  const [expanded, setExpanded] = useState(false);
+  const tagged = profiles.filter((p) => post.taggedProfileIds.includes(p.id));
+  const photoAttachments = post.attachments.filter((a) => a.kind === 'photo');
+  const otherAttachments = post.attachments.filter((a) => a.kind !== 'photo');
+
+  const bodyIsLong = post.body.length > 200;
+  const displayBody = bodyIsLong && !expanded ? post.body.slice(0, 200) + '…' : post.body;
+
+  return (
+    <div className="bg-white rounded-[24px] border border-stone-100 shadow-sm overflow-hidden">
+      {/* Header */}
+      <div className="flex items-center justify-between px-5 pt-5 pb-3">
+        <div className="flex items-center gap-3">
+          <div className="w-8 h-8 rounded-xl bg-amber-100 flex items-center justify-center flex-shrink-0">
+            <span className="text-amber-700 text-[10px] font-black uppercase">
+              {post.authorLabel.charAt(0)}
+            </span>
+          </div>
+          <div>
+            <span className="text-[12px] font-bold text-slate-700 block">{post.authorLabel}</span>
+            <span className="text-[10px] text-stone-400">{formatRelativeTime(post.createdAt)}</span>
+          </div>
+        </div>
+        {isOwn && (
+          <button
+            onClick={onDelete}
+            className="text-stone-200 hover:text-red-400 transition-colors p-1"
+            title="Delete post"
+          >
+            <Trash2 size={14} />
+          </button>
+        )}
+      </div>
+
+      {/* Body */}
+      {post.body && (
+        <div className="px-5 pb-3">
+          <p className="font-serif text-[14px] text-slate-700 leading-relaxed whitespace-pre-wrap">{displayBody}</p>
+          {bodyIsLong && (
+            <button
+              onClick={() => setExpanded(!expanded)}
+              className="flex items-center gap-1 mt-1 text-[10px] font-bold uppercase tracking-wider text-amber-600 hover:text-amber-800"
+            >
+              {expanded ? <><ChevronUp size={10} /> Show less</> : <><ChevronDown size={10} /> Read more</>}
+            </button>
+          )}
+        </div>
+      )}
+
+      {/* Photo grid */}
+      {photoAttachments.length > 0 && (
+        <div className={`grid gap-0.5 mb-0.5 ${photoAttachments.length === 1 ? 'grid-cols-1' : 'grid-cols-2'}`}>
+          {photoAttachments.slice(0, 4).map((att, i) => (
+            <div key={att.id} className="relative aspect-square">
+              <img src={att.dataUrl} alt={att.name} className="w-full h-full object-cover" />
+              {i === 3 && photoAttachments.length > 4 && (
+                <div className="absolute inset-0 bg-black/50 flex items-center justify-center">
+                  <span className="text-white font-bold text-lg">+{photoAttachments.length - 4}</span>
+                </div>
+              )}
+            </div>
+          ))}
+        </div>
+      )}
+
+      {/* Other attachments */}
+      {otherAttachments.length > 0 && (
+        <div className="px-5 pb-3 space-y-1.5">
+          {otherAttachments.map((att) => (
+            <div
+              key={att.id}
+              className="flex items-center gap-2 bg-stone-50 rounded-xl px-3 py-2 text-stone-500"
+            >
+              <AttachmentKindIcon kind={att.kind} />
+              <span className="text-[11px] font-serif truncate flex-1">{att.name}</span>
+              {att.size && (
+                <span className="text-[9px] text-stone-300">
+                  {(att.size / 1024).toFixed(0)}KB
+                </span>
+              )}
+            </div>
+          ))}
+        </div>
+      )}
+
+      {/* Tagged people */}
+      {tagged.length > 0 && (
+        <div className="px-5 pb-4 pt-1 flex flex-wrap gap-1.5">
+          <span className="text-[10px] text-stone-400 self-center mr-0.5">with</span>
+          {tagged.map((p) => (
+            <button
+              key={p.id}
+              onClick={() => onProfileClick(p.id)}
+              className="inline-flex items-center gap-1.5 bg-stone-100 hover:bg-amber-100 text-stone-600 hover:text-amber-800 text-[10px] font-bold uppercase tracking-wider px-2.5 py-1 rounded-full transition-colors"
+            >
+              <img src={p.imageUrl} alt={p.name} className="w-4 h-4 rounded-md object-cover grayscale" />
+              {p.name.split(' ')[0]}
+            </button>
+          ))}
+        </div>
+      )}
+    </div>
+  );
+};
+
+export const CircleFeed: React.FC<CircleFeedProps> = ({
+  posts,
+  profiles,
+  currentUserId,
+  onDeletePost,
+  onProfileClick
+}) => {
+  if (posts.length === 0) {
+    return (
+      <div className="py-16 text-center space-y-3">
+        <div className="w-14 h-14 rounded-full bg-stone-100 flex items-center justify-center mx-auto">
+          <span className="text-2xl">🌿</span>
+        </div>
+        <p className="font-serif text-stone-400 italic text-sm">The circle is quiet. Share the first memory.</p>
+      </div>
+    );
+  }
+
+  return (
+    <div className="space-y-4">
+      {posts.map((post) => (
+        <PostCard
+          key={post.id}
+          post={post}
+          profiles={profiles}
+          isOwn={post.userId === currentUserId}
+          onDelete={() => onDeletePost(post.id)}
+          onProfileClick={onProfileClick}
+        />
+      ))}
+    </div>
+  );
+};
diff -ruN before/src/components/circle/PersonPicker.tsx after/src/components/circle/PersonPicker.tsx
--- before/src/components/circle/PersonPicker.tsx	1970-01-01 00:00:00.000000000 +0000
+++ after/src/components/circle/PersonPicker.tsx	2026-02-21 02:04:32.523189627 +0000
@@ -0,0 +1,110 @@
+import React, { useState, useRef, useEffect } from 'react';
+import { X, Search, User } from 'lucide-react';
+import { Profile } from '../../types';
+import { getFuzzyScore } from '../../utils/search';
+
+interface PersonPickerProps {
+  profiles: Profile[];
+  selectedIds: string[];
+  onChange: (ids: string[]) => void;
+}
+
+export const PersonPicker: React.FC<PersonPickerProps> = ({ profiles, selectedIds, onChange }) => {
+  const [query, setQuery] = useState('');
+  const [open, setOpen] = useState(false);
+  const containerRef = useRef<HTMLDivElement>(null);
+
+  const results = query.trim()
+    ? profiles
+        .map((p) => ({ p, score: getFuzzyScore(p.name, query) }))
+        .filter((x) => x.score > 0)
+        .sort((a, b) => b.score - a.score)
+        .slice(0, 8)
+        .map((x) => x.p)
+    : [];
+
+  const selected = profiles.filter((p) => selectedIds.includes(p.id));
+
+  const toggle = (id: string) => {
+    onChange(selectedIds.includes(id) ? selectedIds.filter((x) => x !== id) : [...selectedIds, id]);
+  };
+
+  // Close on outside click
+  useEffect(() => {
+    const handler = (e: MouseEvent) => {
+      if (containerRef.current && !containerRef.current.contains(e.target as Node)) {
+        setOpen(false);
+      }
+    };
+    document.addEventListener('mousedown', handler);
+    return () => document.removeEventListener('mousedown', handler);
+  }, []);
+
+  return (
+    <div ref={containerRef} className="relative">
+      {/* Selected chips */}
+      {selected.length > 0 && (
+        <div className="flex flex-wrap gap-1.5 mb-2">
+          {selected.map((p) => (
+            <span
+              key={p.id}
+              className="inline-flex items-center gap-1 bg-amber-100 text-amber-800 text-[10px] font-bold uppercase tracking-wider px-2.5 py-1 rounded-full"
+            >
+              {p.name.split(' ')[0]}
+              <button
+                type="button"
+                onClick={() => toggle(p.id)}
+                className="text-amber-500 hover:text-amber-900 ml-0.5"
+              >
+                <X size={10} />
+              </button>
+            </span>
+          ))}
+        </div>
+      )}
+
+      {/* Search input */}
+      <div className="relative">
+        <Search size={13} className="absolute left-3 top-1/2 -translate-y-1/2 text-stone-300 pointer-events-none" />
+        <input
+          type="text"
+          value={query}
+          onChange={(e) => { setQuery(e.target.value); setOpen(true); }}
+          onFocus={() => setOpen(true)}
+          placeholder="Tag a family member…"
+          className="w-full bg-stone-50 border border-stone-100 rounded-xl py-2 pl-9 pr-3 text-[12px] font-serif outline-none focus:ring-2 focus:ring-amber-200 placeholder:text-stone-300"
+        />
+      </div>
+
+      {/* Dropdown */}
+      {open && results.length > 0 && (
+        <div className="absolute top-full left-0 right-0 mt-1 bg-white border border-stone-100 rounded-2xl shadow-xl z-50 overflow-hidden max-h-48 overflow-y-auto">
+          {results.map((p) => {
+            const isSelected = selectedIds.includes(p.id);
+            return (
+              <button
+                key={p.id}
+                type="button"
+                onClick={() => { toggle(p.id); setQuery(''); }}
+                className={`w-full flex items-center gap-3 px-4 py-2.5 text-left hover:bg-stone-50 transition-colors ${isSelected ? 'bg-amber-50' : ''}`}
+              >
+                <img
+                  src={p.imageUrl}
+                  alt={p.name}
+                  className="w-7 h-7 rounded-lg object-cover grayscale flex-shrink-0"
+                />
+                <div className="flex-1 min-w-0">
+                  <span className="font-serif text-[12px] text-slate-800 block truncate">{p.name}</span>
+                  <span className="text-[10px] text-stone-400">{p.birthYear}{p.deathYear ? `–${p.deathYear}` : ''}</span>
+                </div>
+                {isSelected && (
+                  <span className="text-[10px] font-bold text-amber-600">Tagged</span>
+                )}
+              </button>
+            );
+          })}
+        </div>
+      )}
+    </div>
+  );
+};
diff -ruN before/src/components/circle/PostComposer.tsx after/src/components/circle/PostComposer.tsx
--- before/src/components/circle/PostComposer.tsx	1970-01-01 00:00:00.000000000 +0000
+++ after/src/components/circle/PostComposer.tsx	2026-02-21 02:04:32.529189627 +0000
@@ -0,0 +1,182 @@
+import React, { useRef, useState } from 'react';
+import { Paperclip, Send, X, Image, FileText, Music, Video } from 'lucide-react';
+import { CircleAttachment, CirclePost, Profile } from '../../types';
+import { PersonPicker } from './PersonPicker';
+
+interface PostComposerProps {
+  profiles: Profile[];
+  authorLabel: string;
+  userId: string;
+  onSubmit: (post: CirclePost) => void;
+}
+
+const kindIcon = (kind: CircleAttachment['kind']) => {
+  if (kind === 'photo') return <Image size={12} />;
+  if (kind === 'video') return <Video size={12} />;
+  if (kind === 'audio') return <Music size={12} />;
+  return <FileText size={12} />;
+};
+
+const inferKind = (file: File): CircleAttachment['kind'] => {
+  if (file.type.startsWith('image/')) return 'photo';
+  if (file.type.startsWith('video/')) return 'video';
+  if (file.type.startsWith('audio/')) return 'audio';
+  return 'document';
+};
+
+export const PostComposer: React.FC<PostComposerProps> = ({ profiles, authorLabel, userId, onSubmit }) => {
+  const [body, setBody] = useState('');
+  const [taggedIds, setTaggedIds] = useState<string[]>([]);
+  const [attachments, setAttachments] = useState<CircleAttachment[]>([]);
+  const [isSubmitting, setIsSubmitting] = useState(false);
+  const fileInputRef = useRef<HTMLInputElement>(null);
+
+  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
+    const files = Array.from(e.target.files || []);
+    files.forEach((file) => {
+      const reader = new FileReader();
+      reader.onload = (ev) => {
+        const dataUrl = ev.target?.result as string;
+        setAttachments((prev) => [
+          ...prev,
+          {
+            id: `att_${Date.now()}_${Math.random().toString(36).slice(2)}`,
+            kind: inferKind(file),
+            name: file.name,
+            dataUrl,
+            size: file.size
+          }
+        ]);
+      };
+      reader.readAsDataURL(file);
+    });
+    e.target.value = '';
+  };
+
+  const removeAttachment = (id: string) => setAttachments((prev) => prev.filter((a) => a.id !== id));
+
+  const handleSubmit = () => {
+    if (!body.trim() && attachments.length === 0) return;
+    setIsSubmitting(true);
+
+    const post: CirclePost = {
+      id: `post_${Date.now()}_${Math.random().toString(36).slice(2)}`,
+      userId,
+      createdAt: new Date().toISOString(),
+      authorLabel,
+      body: body.trim(),
+      attachments,
+      taggedProfileIds: taggedIds
+    };
+
+    onSubmit(post);
+    setBody('');
+    setTaggedIds([]);
+    setAttachments([]);
+    setIsSubmitting(false);
+  };
+
+  const canSubmit = (body.trim().length > 0 || attachments.length > 0) && !isSubmitting;
+
+  return (
+    <div className="bg-white rounded-[28px] border border-stone-100 shadow-sm p-5 space-y-4">
+      {/* Header */}
+      <div className="flex items-center gap-3">
+        <div className="w-9 h-9 rounded-2xl bg-amber-100 flex items-center justify-center flex-shrink-0">
+          <span className="text-amber-700 text-[11px] font-black uppercase">
+            {authorLabel.charAt(0)}
+          </span>
+        </div>
+        <span className="text-[11px] font-bold uppercase tracking-widest text-stone-400">
+          {authorLabel}
+        </span>
+      </div>
+
+      {/* Textarea */}
+      <textarea
+        value={body}
+        onChange={(e) => setBody(e.target.value)}
+        placeholder="Share a memory, story, or update with the family circle…"
+        rows={3}
+        className="w-full resize-none bg-stone-50 border border-stone-100 rounded-2xl p-4 font-serif text-[14px] text-slate-700 outline-none focus:ring-2 focus:ring-amber-200 placeholder:text-stone-300 leading-relaxed"
+      />
+
+      {/* Attachment previews */}
+      {attachments.length > 0 && (
+        <div className="flex flex-wrap gap-2">
+          {attachments.map((att) => (
+            <div
+              key={att.id}
+              className="relative group rounded-xl overflow-hidden border border-stone-100"
+            >
+              {att.kind === 'photo' ? (
+                <img
+                  src={att.dataUrl}
+                  alt={att.name}
+                  className="w-16 h-16 object-cover"
+                />
+              ) : (
+                <div className="w-16 h-16 bg-stone-50 flex flex-col items-center justify-center gap-1 text-stone-400">
+                  {kindIcon(att.kind)}
+                  <span className="text-[8px] text-center px-1 truncate w-full text-center">
+                    {att.name.slice(0, 10)}
+                  </span>
+                </div>
+              )}
+              <button
+                type="button"
+                onClick={() => removeAttachment(att.id)}
+                className="absolute top-0.5 right-0.5 w-4 h-4 rounded-full bg-stone-900/70 text-white flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity"
+              >
+                <X size={8} />
+              </button>
+            </div>
+          ))}
+        </div>
+      )}
+
+      {/* People tagger */}
+      {profiles.length > 0 && (
+        <PersonPicker
+          profiles={profiles}
+          selectedIds={taggedIds}
+          onChange={setTaggedIds}
+        />
+      )}
+
+      {/* Actions */}
+      <div className="flex items-center justify-between pt-1">
+        <button
+          type="button"
+          onClick={() => fileInputRef.current?.click()}
+          className="flex items-center gap-1.5 text-stone-400 hover:text-amber-600 transition-colors text-[11px] font-bold uppercase tracking-wider"
+        >
+          <Paperclip size={14} />
+          Attach
+        </button>
+        <input
+          ref={fileInputRef}
+          type="file"
+          multiple
+          accept="image/*,video/*,audio/*,.pdf,.doc,.docx"
+          onChange={handleFileChange}
+          className="hidden"
+        />
+
+        <button
+          type="button"
+          onClick={handleSubmit}
+          disabled={!canSubmit}
+          className={`flex items-center gap-2 px-5 py-2.5 rounded-full text-[11px] font-black uppercase tracking-widest transition-all ${
+            canSubmit
+              ? 'bg-stone-900 text-white hover:bg-stone-700 shadow-sm'
+              : 'bg-stone-100 text-stone-300 cursor-not-allowed'
+          }`}
+        >
+          <Send size={12} />
+          Post
+        </button>
+      </div>
+    </div>
+  );
+};
diff -ruN before/src/constants.tsx after/src/constants.tsx
--- before/src/constants.tsx	1970-01-01 00:00:00.000000000 +0000
+++ after/src/constants.tsx	2026-02-21 02:03:53.068189922 +0000
@@ -0,0 +1,71 @@
+
+import React from 'react';
+import { 
+  Sparkles, Disc, Heart, MapPin, ScrollText, Anchor, Map as MapIcon, History 
+} from 'lucide-react';
+
+export const STORAGE_KEYS = {
+  // These keys are kept for any residual migration tooling.
+  // The app itself no longer reads or writes localStorage for auth or data.
+  PROFILES: 'eternal_profiles',
+  FAMILY_TREES: 'eternal_family_trees',
+  REMEMBERED_EMAIL: 'eternal_remembered_email',
+  CIRCLE_POSTS: 'eternal_circle_posts',
+};
+
+export const MONTHS = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
+
+// Archival Silhouette Placeholders
+const PLACEHOLDERS = {
+  M: `data:image/svg+xml;utf8,${encodeURIComponent('<svg width="400" height="400" viewBox="0 0 400 400" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="400" height="400" fill="#D4CBB9"/><path d="M200 120C222.091 120 240 137.909 240 160C240 182.091 222.091 200 200 200C177.909 200 160 182.091 160 160C160 137.909 177.909 120 200 120ZM200 220C255.228 220 300 255.82 300 300V320H100V300C100 255.82 144.772 220 200 220Z" fill="#1C1917" fill-opacity="0.15"/></svg>')}`,
+  F: `data:image/svg+xml;utf8,${encodeURIComponent('<svg width="400" height="400" viewBox="0 0 400 400" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="400" height="400" fill="#D4CBB9"/><path d="M200 110C219.33 110 235 125.67 235 145C235 164.33 219.33 180 200 180C180.67 180 165 164.33 165 145C165 125.67 180.67 110 200 110ZM200 200C244.183 200 280 235.817 280 280C280 290 280 305 280 320H120C120 305 120 290 120 280C120 235.817 155.817 200 200 200Z" fill="#1C1917" fill-opacity="0.15"/></svg>')}`,
+  U: `data:image/svg+xml;utf8,${encodeURIComponent('<svg width="400" height="400" viewBox="0 0 400 400" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="400" height="400" fill="#D4CBB9"/><circle cx="200" cy="150" r="45" fill="#1C1917" fill-opacity="0.15"/><path d="M110 320C110 270 150.294 230 200 230C249.706 230 290 270 290 320H110Z" fill="#1C1917" fill-opacity="0.15"/></svg>')}`
+};
+
+export const getPlaceholderImage = (gender?: string) => {
+  if (gender === 'M') return PLACEHOLDERS.M;
+  if (gender === 'F') return PLACEHOLDERS.F;
+  return PLACEHOLDERS.U;
+};
+
+export type EventIconProps = { size?: number; className?: string };
+
+const iconMap: Record<string, React.FC<EventIconProps>> = {
+  'Birth':                (p) => <Sparkles  {...p} className="text-amber-500" />,
+  'Death':                (p) => <Disc      {...p} className="text-stone-400" />,
+  'Marriage':             (p) => <Heart     {...p} className="text-rose-400" />,
+  'Residence':            (p) => <MapPin    {...p} className="text-blue-400" />,
+  'Census':               (p) => <ScrollText {...p} className="text-emerald-400" />,
+  'Departure/Emigration': (p) => <Anchor    {...p} className="text-orange-400" />,
+  'Arrival/Immigration':  (p) => <MapIcon   {...p} className="text-indigo-400" />,
+  'Burial':               (p) => <Disc      {...p} className="text-stone-500" />,
+  'Graduation':           (p) => <Sparkles  {...p} className="text-purple-500" />,
+  'Military Service':     (p) => <MapPin    {...p} className="text-red-500" />,
+  'Bar Mitzvah':          (p) => <ScrollText {...p} className="text-blue-500" />,
+  'Bat Mitzvah':          (p) => <ScrollText {...p} className="text-pink-500" />,
+  'Confirmation':         (p) => <Sparkles  {...p} className="text-indigo-500" />,
+  'Event':                (p) => <History   {...p} className="text-stone-400" />,
+};
+
+export const getEventIcon = (type: string): React.FC<EventIconProps> =>
+  iconMap[type] ?? ((p) => <History {...p} className="text-stone-300" />);
+
+export const eventVerb = (type: string) => {
+  const verbs: Record<string, string> = {
+    'Birth': 'was born',
+    'Death': 'passed away',
+    'Marriage': 'married',
+    'Residence': 'resided',
+    'Census': 'appears in the census',
+    'Burial': 'was laid to rest',
+    'Departure/Emigration': 'departed',
+    'Arrival/Immigration': 'arrived',
+    'Graduation': 'graduated',
+    'Military Service': 'served',
+    'Bar Mitzvah': 'celebrated their Bar Mitzvah',
+    'Bat Mitzvah': 'celebrated their Bat Mitzvah',
+    'Confirmation': 'was confirmed',
+    'Event': 'had an event'
+  };
+  return verbs[type] || 'had a recorded event';
+};
diff -ruN before/src/hooks/useArchiveStore.ts after/src/hooks/useArchiveStore.ts
--- before/src/hooks/useArchiveStore.ts	1970-01-01 00:00:00.000000000 +0000
+++ after/src/hooks/useArchiveStore.ts	2026-02-21 02:05:00.246189420 +0000
@@ -0,0 +1,67 @@
+import { useCallback, useMemo, useState } from 'react';
+import { CirclePost, FamilyTree, Profile, User } from '../types';
+
+export const useArchiveStore = (user: User | null) => {
+  const [profiles, setProfiles] = useState<Profile[]>([]);
+  const [familyTrees, setFamilyTrees] = useState<FamilyTree[]>([]);
+  const [activeProfileId, setActiveProfileId] = useState<string | null>(null);
+  const [selectedTreeId, setSelectedTreeId] = useState<string | null>(null);
+  const [treeViewId, setTreeViewId] = useState<string | null>(null);
+  const [circlePosts, setCirclePosts] = useState<CirclePost[]>([]);
+
+  // Reset state when user signs out
+  const prevUserId = useMemo(() => user?.id, [user?.id]);
+
+  const addCirclePost = useCallback((post: CirclePost) => {
+    setCirclePosts(prev => [post, ...prev]);
+  }, []);
+
+  const deleteCirclePost = useCallback((id: string) => {
+    setCirclePosts(prev => prev.filter(p => p.id !== id));
+  }, []);
+
+  const updateCirclePost = useCallback((id: string, patch: Partial<CirclePost>) => {
+    setCirclePosts(prev => prev.map(p => p.id === id ? { ...p, ...patch } : p));
+  }, []);
+
+  const activeProfile = useMemo(
+    () => profiles.find(p => p.id === activeProfileId) ?? null,
+    [profiles, activeProfileId]
+  );
+
+  const selectedTree = useMemo(
+    () => familyTrees.find(t => t.id === selectedTreeId) ?? null,
+    [familyTrees, selectedTreeId]
+  );
+
+  const selectedTreeForView = useMemo(
+    () => familyTrees.find(t => t.id === treeViewId) ?? null,
+    [familyTrees, treeViewId]
+  );
+
+  const clearAll = useCallback(() => {
+    setProfiles([]);
+    setFamilyTrees([]);
+    setActiveProfileId(null);
+    setSelectedTreeId(null);
+    setTreeViewId(null);
+    setCirclePosts([]);
+  }, []);
+
+  // Required by App.tsx onDeleteProfile handler
+  const deleteProfileById = useCallback((id: string) => {
+    setProfiles(prev => prev.filter(p => p.id !== id));
+  }, []);
+
+  return {
+    profiles, setProfiles,
+    familyTrees, setFamilyTrees,
+    activeProfileId, setActiveProfileId,
+    selectedTreeId, setSelectedTreeId,
+    treeViewId, setTreeViewId,
+    activeProfile, selectedTree, selectedTreeForView,
+    circlePosts, addCirclePost, deleteCirclePost, updateCirclePost,
+    clearAll,
+    deleteProfileById,
+  };
+};
diff -ruN before/src/hooks/useGedcomImport.ts after/src/hooks/useGedcomImport.ts
--- before/src/hooks/useGedcomImport.ts	1970-01-01 00:00:00.000000000 +0000
+++ after/src/hooks/useGedcomImport.ts	2026-02-21 02:05:13.540189321 +0000
@@ -0,0 +1,73 @@
+import { useRef, useState } from 'react';
+import { AppView, FamilyTree, Profile, User } from '../types';
+import { parseGedcom } from '../utils/gedcom';
+
+export const useGedcomImport = (args: {
+  user: User | null;
+  setView: (v: AppView) => void;
+  setProfiles: React.Dispatch<React.SetStateAction<Profile[]>>;
+  setFamilyTrees: React.Dispatch<React.SetStateAction<FamilyTree[]>>;
+  setSelectedTreeId: (id: string | null) => void;
+  setActiveProfileId: (id: string | null) => void;
+  toast: (m: string) => void;
+}) => {
+  const { user, setView, setProfiles, setFamilyTrees, setSelectedTreeId, setActiveProfileId, toast } = args;
+
+  const gedFileInputRef = useRef<HTMLInputElement>(null);
+  const [pendingImport, setPendingImport] = useState<{ importedProfiles: Profile[]; tree: FamilyTree } | null>(null);
+
+  const handleGedcomUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
+    // Hard auth gate — no session, no upload
+    if (!user) {
+      toast('Please sign in to import a family archive.');
+      e.target.value = '';
+      return;
+    }
+
+    const f = e.target.files?.[0];
+    if (!f) { e.target.value = ''; return; }
+
+    const reader = new FileReader();
+    reader.onload = (event) => {
+      const text = event.target?.result;
+      if (typeof text === 'string') {
+        try {
+          const result = parseGedcom(text, user.id, 4);
+          setPendingImport(result);
+          setView(AppView.SELECT_HOME);
+          toast(`Loaded ${result.importedProfiles.length} family members`);
+        } catch (err) {
+          console.error(err);
+          toast('Error parsing GEDCOM');
+        }
+      }
+    };
+    reader.readAsText(f);
+    e.target.value = '';
+  };
+
+  const chooseHome = (selected: Profile) => {
+    if (!pendingImport || !user) return;
+
+    setProfiles(prev => {
+      const existingIds = new Set(prev.map(p => p.id));
+      const newProfiles = pendingImport.importedProfiles.filter(p => !existingIds.has(p.id));
+      return [...prev, ...newProfiles];
+    });
+
+    const updatedTree: FamilyTree = {
+      ...pendingImport.tree,
+      homePersonId: selected.id,
+      name: `The ${selected.name} Archive`,
+    };
+
+    setFamilyTrees(prev => [updatedTree, ...prev]);
+    setSelectedTreeId(updatedTree.id);
+    setActiveProfileId(selected.id);
+    setPendingImport(null);
+    setView(AppView.HOME);
+    toast('Archive successfully imported');
+  };
+
+  return { gedFileInputRef, pendingImport, setPendingImport, handleGedcomUpload, chooseHome };
+};
diff -ruN before/src/hooks/useMediaAttach.ts after/src/hooks/useMediaAttach.ts
--- before/src/hooks/useMediaAttach.ts	1970-01-01 00:00:00.000000000 +0000
+++ after/src/hooks/useMediaAttach.ts	2026-02-21 02:05:29.847189199 +0000
@@ -0,0 +1,91 @@
+import { useState } from 'react';
+import { AppView, MediaItem, Profile, User } from '../types';
+import { compressImage } from '../utils/media';
+import { inferMediaKind } from '../utils/formatters';
+
+export const useMediaAttach = (args: {
+  user?: User | null;
+  activeProfileId: string | null;
+  view: AppView;
+  attachingToEventId: string | null;
+  setAttachingToEventId: (id: string | null) => void;
+  setProfiles: React.Dispatch<React.SetStateAction<Profile[]>>;
+  setEditImageUrl: (v: string) => void;
+  toast: (m: string) => void;
+}) => {
+  const {
+    activeProfileId, view, attachingToEventId,
+    setAttachingToEventId, setProfiles, setEditImageUrl, toast,
+  } = args;
+  const [isPhotoLoading, setIsPhotoLoading] = useState(false);
+
+  const handleProfilePhotoUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
+    const file = e.target.files?.[0];
+    if (!file || !activeProfileId) return;
+    setIsPhotoLoading(true);
+    try {
+      const base64 = await compressImage(file);
+      if (view === AppView.EDIT_PROFILE) setEditImageUrl(base64);
+      else setProfiles(prev => prev.map(p => p.id === activeProfileId ? { ...p, imageUrl: base64 } : p));
+      toast('Photo updated');
+    } catch (err) {
+      console.error(err);
+      toast('Error processing photo');
+    } finally {
+      setIsPhotoLoading(false);
+      e.target.value = '';
+    }
+  };
+
+  const handleEventMediaUpload = async (eventId: string, files: FileList) => {
+    if (!activeProfileId || !files.length) return;
+    toast('Processing...');
+    try {
+      const newMediaItems: MediaItem[] = await Promise.all(
+        Array.from(files).map(async (file: File) => {
+          const kind = inferMediaKind(file.name, file.type);
+          let url = '';
+          if (kind === 'photo') {
+            url = await compressImage(file);
+          } else {
+            url = await new Promise<string>((resolve, reject) => {
+              const reader = new FileReader();
+              reader.onload = ev => resolve(ev.target?.result as string);
+              reader.onerror = reject;
+              reader.readAsDataURL(file);
+            });
+          }
+          return {
+            id: `m-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`,
+            name: file.name,
+            kind,
+            url,
+            mime: file.type,
+            size: file.size,
+            createdAt: new Date().toISOString(),
+          };
+        })
+      );
+
+      setProfiles(prev =>
+        prev.map(p =>
+          p.id !== activeProfileId ? p : {
+            ...p,
+            timeline: p.timeline.map(ev =>
+              ev.id !== eventId ? ev : {
+                ...ev,
+                media: [...(ev.media ?? []), ...newMediaItems],
+              }
+            ),
+          }
+        )
+      );
+      toast(`Attached ${newMediaItems.length} file${newMediaItems.length !== 1 ? 's' : ''}`);
+    } catch (err) {
+      console.error(err);
+      toast('Upload error');
+    }
+  };
+
+  return { isPhotoLoading, handleProfilePhotoUpload, handleEventMediaUpload };
+};
diff -ruN before/src/hooks/useProfileEditor.ts after/src/hooks/useProfileEditor.ts
--- before/src/hooks/useProfileEditor.ts	1970-01-01 00:00:00.000000000 +0000
+++ after/src/hooks/useProfileEditor.ts	2026-02-21 02:05:35.385189158 +0000
@@ -0,0 +1,108 @@
+import { useState } from 'react';
+import { Profile } from '../types';
+
+export const useProfileEditor = (args: {
+  activeProfile: Profile | null;
+  activeProfileId: string | null;
+  setProfiles: React.Dispatch<React.SetStateAction<Profile[]>>;
+  toast: (m: string) => void;
+}) => {
+  const { activeProfile, activeProfileId, setProfiles, toast } = args;
+
+  const [editName, setEditName] = useState('');
+  const [editGender, setEditGender] = useState<'M' | 'F' | 'U'>('U');
+  const [editBirthYear, setEditBirthYear] = useState('');
+  const [editDeathYear, setEditDeathYear] = useState('');
+  const [editImageUrl, setEditImageUrl] = useState('');
+
+  const [newMemoryInput, setNewMemoryInput] = useState('');
+  const [linkRole, setLinkRole] = useState<'parent' | 'child' | 'spouse' | null>(null);
+
+  const startEdit = () => {
+    if (!activeProfile) return;
+    setEditName(activeProfile.name);
+    setEditGender(activeProfile.gender || 'U');
+    setEditBirthYear(activeProfile.birthYear);
+    setEditDeathYear(activeProfile.deathYear || '');
+    setEditImageUrl(activeProfile.imageUrl);
+  };
+
+  const saveEdit = () => {
+    if (!activeProfileId) return;
+    setProfiles((prev) =>
+      prev.map((p) =>
+        p.id === activeProfileId
+          ? {
+              ...p,
+              name: editName,
+              gender: editGender,
+              birthYear: editBirthYear,
+              deathYear: editDeathYear || undefined,
+              imageUrl: editImageUrl
+            }
+          : p
+      )
+    );
+    toast('Profile updated');
+  };
+
+  const deleteProfile = (confirmFn: (msg: string) => boolean) => {
+    if (!activeProfileId) return false;
+    const name = activeProfile?.name || 'this profile';
+    if (confirmFn(`Remove ${name}?`)) {
+      setProfiles((prev) => prev.filter((p) => p.id !== activeProfileId));
+      toast('Removed');
+      return true;
+    }
+    return false;
+  };
+
+  const linkRelative = (targetProfile: Profile) => {
+    if (!activeProfileId || !linkRole) return;
+    setProfiles((prev) =>
+      prev.map((p) => {
+        if (p.id === activeProfileId) {
+          const u = { ...p };
+          if (linkRole === 'parent' && !u.parentIds.includes(targetProfile.id)) u.parentIds = [...u.parentIds, targetProfile.id];
+          if (linkRole === 'child' && !u.childIds.includes(targetProfile.id)) u.childIds = [...u.childIds, targetProfile.id];
+          if (linkRole === 'spouse' && !u.spouseIds.includes(targetProfile.id)) u.spouseIds = [...u.spouseIds, targetProfile.id];
+          return u;
+        }
+        if (p.id === targetProfile.id) {
+          const u = { ...p };
+          if (linkRole === 'parent' && !u.childIds.includes(activeProfileId)) u.childIds = [...u.childIds, activeProfileId];
+          if (linkRole === 'child' && !u.parentIds.includes(activeProfileId)) u.parentIds = [...u.parentIds, activeProfileId];
+          if (linkRole === 'spouse' && !u.spouseIds.includes(activeProfileId)) u.spouseIds = [...u.spouseIds, activeProfileId];
+          return u;
+        }
+        return p;
+      })
+    );
+    toast('Link established');
+    setLinkRole(null);
+  };
+
+  const saveMemory = () => {
+    if (!activeProfileId || !newMemoryInput.trim()) return;
+    const m = {
+      id: Date.now().toString(),
+      type: 'story' as const,
+      content: newMemoryInput,
+      timestamp: new Date().toLocaleDateString('en-US', { month: 'short', year: 'numeric' })
+    };
+    setProfiles((prev) => prev.map((p) => (p.id === activeProfileId ? { ...p, memories: [m, ...(p.memories || [])] } : p)));
+    setNewMemoryInput('');
+    toast('Story preserved');
+  };
+
+  return {
+    editName, setEditName,
+    editGender, setEditGender,
+    editBirthYear, setEditBirthYear,
+    editDeathYear, setEditDeathYear,
+    editImageUrl, setEditImageUrl,
+    startEdit, saveEdit, deleteProfile,
+    newMemoryInput, setNewMemoryInput, saveMemory,
+    linkRole, setLinkRole, linkRelative
+  };
+};
diff -ruN before/src/hooks/useSession.ts after/src/hooks/useSession.ts
--- before/src/hooks/useSession.ts	1970-01-01 00:00:00.000000000 +0000
+++ after/src/hooks/useSession.ts	2026-02-21 02:04:46.468189523 +0000
@@ -0,0 +1,70 @@
+import { useEffect, useState, useCallback } from 'react';
+import { supabase } from '../lib/supabaseClient';
+import { AppView, User } from '../types';
+import type { Session } from '@supabase/supabase-js';
+
+function sessionToUser(session: Session): User {
+  const { user } = session;
+  return {
+    id: user.id,
+    email: user.email ?? '',
+    name:
+      (user.user_metadata?.display_name as string | undefined) ??
+      user.email?.split('@')[0] ??
+      'User',
+    createdAt: user.created_at,
+  };
+}
+
+export const useSession = () => {
+  const [view, setView] = useState<AppView>(AppView.SPLASH);
+  const [user, setUser] = useState<User | null>(null);
+  const [loading, setLoading] = useState(true);
+
+  useEffect(() => {
+    // Restore existing session on mount
+    supabase.auth.getSession().then(({ data: { session } }) => {
+      if (session) {
+        setUser(sessionToUser(session));
+        setView(AppView.HOME);
+      } else {
+        // Brief splash before showing login
+        const t = setTimeout(() => setView(AppView.LOGIN), 1200);
+        return () => clearTimeout(t);
+      }
+      setLoading(false);
+    });
+
+    // React to sign-in / sign-out events
+    const { data: { subscription } } = supabase.auth.onAuthStateChange(
+      (_event, session) => {
+        if (session) {
+          setUser(sessionToUser(session));
+          setView(prev =>
+            prev === AppView.LOGIN || prev === AppView.SPLASH
+              ? AppView.HOME
+              : prev
+          );
+        } else {
+          setUser(null);
+          setView(AppView.LOGIN);
+        }
+      }
+    );
+
+    return () => subscription.unsubscribe();
+  }, []);
+
+  const login = useCallback((u: User) => {
+    setUser(u);
+    setView(AppView.HOME);
+  }, []);
+
+  const logout = useCallback(async () => {
+    await supabase.auth.signOut();
+    setUser(null);
+    setView(AppView.LOGIN);
+  }, []);
+
+  return { view, setView, user, setUser, login, logout, loading };
+};
diff -ruN before/src/index.css after/src/index.css
--- before/src/index.css	1970-01-01 00:00:00.000000000 +0000
+++ after/src/index.css	2026-02-21 02:03:53.057189922 +0000
@@ -0,0 +1,16 @@
+/* Eternal - Family Archive */
+
+@keyframes fade-in-up {
+  from {
+    opacity: 0;
+    transform: translateY(16px);
+  }
+  to {
+    opacity: 1;
+    transform: translateY(0);
+  }
+}
+
+.animate-fade-in-up {
+  animation: fade-in-up 0.8s ease-out both;
+}
diff -ruN before/src/lib/database.types.ts after/src/lib/database.types.ts
--- before/src/lib/database.types.ts	1970-01-01 00:00:00.000000000 +0000
+++ after/src/lib/database.types.ts	2026-02-21 02:04:13.073189773 +0000
@@ -0,0 +1,105 @@
+// ---------------------------------------------------------------------------
+// Hand-authored types that mirror the SQL schema in supabase_migration.sql.
+// Replace with the output of `supabase gen types typescript` once you have
+// a linked project: https://supabase.com/docs/reference/cli/supabase-gen-types
+// ---------------------------------------------------------------------------
+
+export type MediaKindEnum = 'photo' | 'video' | 'audio' | 'document';
+export type GenderCodeEnum = 'M' | 'F' | 'U';
+
+// ── Row shapes (what Supabase returns) ──────────────────────────────────────
+
+export interface TreeRow {
+  id: string;
+  user_id: string;
+  name: string;
+  home_person_id: string | null;
+  member_ids: string[];
+  created_at: string;
+  updated_at: string;
+}
+
+export interface ProfileRow {
+  id: string;
+  user_id: string;
+  tree_id: string | null;
+  name: string;
+  gender: GenderCodeEnum | null;
+  birth_year: string | null;
+  death_year: string | null;
+  image_url: string | null;
+  summary: string | null;
+  historical_context: { text: string; sources: unknown[] } | null;
+  is_memorial: boolean;
+  parent_ids: string[];
+  child_ids: string[];
+  spouse_ids: string[];
+  timeline: unknown[];   // LifeEvent[] stored as JSONB
+  memories: unknown[];   // Memory[] stored as JSONB
+  sources: string[];
+  created_at: string;
+  updated_at: string;
+}
+
+export interface PostRow {
+  id: string;
+  user_id: string;
+  author_label: string;
+  body: string;
+  attachments: unknown[];  // CircleAttachment[] stored as JSONB
+  created_at: string;
+  updated_at: string;
+}
+
+export interface PostPersonRow {
+  post_id: string;
+  profile_id: string;
+  user_id: string;
+}
+
+export interface MediaRow {
+  id: string;
+  user_id: string;
+  name: string;
+  kind: MediaKindEnum;
+  storage_path: string;
+  public_url: string | null;
+  mime: string | null;
+  size: number | null;
+  created_at: string;
+  updated_at: string;
+}
+
+export interface MediaPersonRow {
+  media_id: string;
+  profile_id: string;
+  user_id: string;
+}
+
+// ── Insert shapes (what we send to Supabase) ────────────────────────────────
+
+export type TreeInsert = Omit<TreeRow, 'created_at' | 'updated_at'>;
+export type ProfileInsert = Omit<ProfileRow, 'created_at' | 'updated_at'>;
+export type PostInsert = Omit<PostRow, 'created_at' | 'updated_at'>;
+export type MediaInsert = Omit<MediaRow, 'created_at' | 'updated_at'>;
+
+// ── Minimal Database shape for createClient<Database>() ─────────────────────
+
+export interface Database {
+  public: {
+    Tables: {
+      trees:        { Row: TreeRow;        Insert: TreeInsert;    Update: Partial<TreeInsert> };
+      profiles:     { Row: ProfileRow;     Insert: ProfileInsert; Update: Partial<ProfileInsert> };
+      posts:        { Row: PostRow;        Insert: PostInsert;    Update: Partial<PostInsert> };
+      post_people:  { Row: PostPersonRow;  Insert: PostPersonRow; Update: Partial<PostPersonRow> };
+      media:        { Row: MediaRow;       Insert: MediaInsert;   Update: Partial<MediaInsert> };
+      media_people: { Row: MediaPersonRow; Insert: MediaPersonRow; Update: Partial<MediaPersonRow> };
+    };
+    Views: Record<string, never>;
+    Functions: Record<string, never>;
+    Enums: {
+      media_kind: MediaKindEnum;
+      gender_code: GenderCodeEnum;
+    };
+  };
+}
diff -ruN before/src/lib/mappers.ts after/src/lib/mappers.ts
--- before/src/lib/mappers.ts	1970-01-01 00:00:00.000000000 +0000
+++ after/src/lib/mappers.ts	2026-02-21 02:04:13.078189772 +0000
@@ -0,0 +1,101 @@
+// ---------------------------------------------------------------------------
+// Mappers: convert snake_case Supabase rows ↔ camelCase app types.
+// Keeping these in one place means the repos stay thin and the app types
+// never need to change.
+// ---------------------------------------------------------------------------
+
+import type { FamilyTree, Profile, CirclePost, CircleAttachment, LifeEvent, Memory } from '../types';
+import type { TreeRow, ProfileRow, PostRow, TreeInsert, ProfileInsert, PostInsert } from './database.types';
+
+// ── FamilyTree ───────────────────────────────────────────────────────────────
+
+export function rowToTree(row: TreeRow): FamilyTree {
+  return {
+    id: row.id,
+    userId: row.user_id,
+    name: row.name,
+    createdAt: row.created_at,
+    homePersonId: row.home_person_id ?? '',
+    memberIds: row.member_ids ?? [],
+  };
+}
+
+export function treeToInsert(t: FamilyTree): TreeInsert {
+  return {
+    id: t.id,
+    user_id: t.userId,
+    name: t.name,
+    home_person_id: t.homePersonId || null,
+    member_ids: t.memberIds,
+  };
+}
+
+// ── Profile ──────────────────────────────────────────────────────────────────
+
+export function rowToProfile(row: ProfileRow): Profile {
+  return {
+    id: row.id,
+    userId: row.user_id,
+    name: row.name,
+    gender: row.gender ?? undefined,
+    birthYear: row.birth_year ?? '',
+    deathYear: row.death_year ?? undefined,
+    imageUrl: row.image_url ?? '',
+    summary: row.summary ?? '',
+    historicalContext: row.historical_context ?? undefined,
+    isMemorial: row.is_memorial,
+    parentIds: row.parent_ids ?? [],
+    childIds: row.child_ids ?? [],
+    spouseIds: row.spouse_ids ?? [],
+    timeline: (row.timeline as LifeEvent[]) ?? [],
+    memories: (row.memories as Memory[]) ?? [],
+    sources: row.sources ?? [],
+  };
+}
+
+export function profileToInsert(p: Profile, treeId?: string): ProfileInsert {
+  return {
+    id: p.id,
+    user_id: p.userId,
+    tree_id: treeId ?? null,
+    name: p.name,
+    gender: p.gender ?? null,
+    birth_year: p.birthYear || null,
+    death_year: p.deathYear || null,
+    image_url: p.imageUrl || null,
+    summary: p.summary || null,
+    historical_context: p.historicalContext ?? null,
+    is_memorial: p.isMemorial ?? false,
+    parent_ids: p.parentIds ?? [],
+    child_ids: p.childIds ?? [],
+    spouse_ids: p.spouseIds ?? [],
+    timeline: (p.timeline ?? []) as unknown[],
+    memories: (p.memories ?? []) as unknown[],
+    sources: p.sources ?? [],
+  };
+}
+
+// ── CirclePost ───────────────────────────────────────────────────────────────
+
+/** taggedProfileIds must be injected from the post_people join */
+export function rowToPost(row: PostRow, taggedProfileIds: string[]): CirclePost {
+  return {
+    id: row.id,
+    userId: row.user_id,
+    createdAt: row.created_at,
+    authorLabel: row.author_label,
+    body: row.body,
+    attachments: (row.attachments as CircleAttachment[]) ?? [],
+    taggedProfileIds,
+  };
+}
+
+export function postToInsert(p: CirclePost): PostInsert {
+  return {
+    id: p.id,
+    user_id: p.userId,
+    author_label: p.authorLabel,
+    body: p.body,
+    attachments: p.attachments as unknown[],
+  };
+}
diff -ruN before/src/lib/supabaseClient.ts after/src/lib/supabaseClient.ts
--- before/src/lib/supabaseClient.ts	1970-01-01 00:00:00.000000000 +0000
+++ after/src/lib/supabaseClient.ts	2026-02-21 02:04:13.067189773 +0000
@@ -0,0 +1,20 @@
+import { createClient } from '@supabase/supabase-js';
+import type { Database } from './database.types';
+
+const supabaseUrl = import.meta.env.VITE_SUPABASE_URL as string | undefined;
+const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY as string | undefined;
+
+if (!supabaseUrl || supabaseUrl.trim() === '') {
+  throw new Error(
+    '[supabaseClient] Missing env var: VITE_SUPABASE_URL\n' +
+    'Add it to .env.local or your Vercel project settings.'
+  );
+}
+if (!supabaseAnonKey || supabaseAnonKey.trim() === '') {
+  throw new Error(
+    '[supabaseClient] Missing env var: VITE_SUPABASE_ANON_KEY\n' +
+    'Add it to .env.local or your Vercel project settings.'
+  );
+}
+
+export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey);
diff -ruN before/src/main.tsx after/src/main.tsx
--- before/src/main.tsx	1970-01-01 00:00:00.000000000 +0000
+++ after/src/main.tsx	2026-02-21 02:03:47.072189967 +0000
@@ -0,0 +1,18 @@
+import React from 'react';
+import ReactDOM from 'react-dom/client';
+import App from './App';
+import ErrorBoundary from './components/ErrorBoundary';
+
+const rootElement = document.getElementById('root');
+if (!rootElement) {
+  throw new Error('Could not find root element to mount to');
+}
+
+const root = ReactDOM.createRoot(rootElement);
+root.render(
+  <React.StrictMode>
+    <ErrorBoundary>
+      <App />
+    </ErrorBoundary>
+  </React.StrictMode>
+);
diff -ruN before/src/repos/mediaRepo.ts after/src/repos/mediaRepo.ts
--- before/src/repos/mediaRepo.ts	1970-01-01 00:00:00.000000000 +0000
+++ after/src/repos/mediaRepo.ts	2026-02-21 02:04:19.555189724 +0000
@@ -0,0 +1,167 @@
+// ---------------------------------------------------------------------------
+// repos/mediaRepo.ts
+// Files are uploaded to the Supabase Storage bucket named 'media' (private).
+// After a successful upload the metadata row is inserted into the media table.
+// Signed URLs are generated on demand (1-hour expiry) and should not be
+// persisted — generate a fresh one each time you render a <img> or <video>.
+// ---------------------------------------------------------------------------
+
+import { supabase } from '../lib/supabaseClient';
+import type { MediaItem, MediaKind } from '../types';
+import type { MediaRow } from '../lib/database.types';
+
+const BUCKET = 'media';
+const SIGNED_URL_EXPIRY_SECONDS = 60 * 60; // 1 hour
+
+// ── Internal helpers ─────────────────────────────────────────────────────────
+
+function rowToMediaItem(row: MediaRow, signedUrl: string): MediaItem {
+  return {
+    id: row.id,
+    name: row.name,
+    kind: row.kind as MediaKind,
+    url: signedUrl,
+    mime: row.mime ?? undefined,
+    size: row.size ?? undefined,
+    createdAt: row.created_at,
+  };
+}
+
+// ── Public API ───────────────────────────────────────────────────────────────
+
+export interface UploadMediaOptions {
+  /** UUID of the authenticated user — needed to namespace the storage path. */
+  userId: string;
+  /** The browser File object to upload. */
+  file: File;
+  /** Optional profile IDs to tag in media_people after upload. */
+  taggedProfileIds?: string[];
+}
+
+/**
+ * Upload a file to Supabase Storage, write a metadata row, optionally tag
+ * profiles, and return a MediaItem with a fresh signed URL.
+ *
+ * Storage path:  `{userId}/{timestamp}-{sanitisedFileName}`
+ * This ensures files from different users never collide even without RLS on
+ * the bucket (though you should also enable Storage RLS).
+ */
+export async function uploadMedia(opts: UploadMediaOptions): Promise<MediaItem> {
+  const { userId, file, taggedProfileIds = [] } = opts;
+
+  // 1. Build a collision-safe storage path.
+  const safeName = file.name.replace(/[^a-zA-Z0-9._-]/g, '_');
+  const storagePath = `${userId}/${Date.now()}-${safeName}`;
+
+  // 2. Upload the raw file.
+  const { error: uploadError } = await supabase.storage
+    .from(BUCKET)
+    .upload(storagePath, file, {
+      contentType: file.type || 'application/octet-stream',
+      upsert: false,
+    });
+
+  if (uploadError) throw new Error(`uploadMedia storage: ${uploadError.message}`);
+
+  // 3. Infer media kind from MIME type.
+  const kind = inferKind(file.type);
+
+  // 4. Insert the metadata row.
+  const { data: row, error: insertError } = await supabase
+    .from('media')
+    .insert({
+      user_id: userId,
+      name: file.name,
+      kind,
+      storage_path: storagePath,
+      public_url: null,
+      mime: file.type || null,
+      size: file.size,
+    })
+    .select()
+    .single();
+
+  if (insertError) {
+    // Best-effort cleanup: remove the orphaned file from Storage.
+    await supabase.storage.from(BUCKET).remove([storagePath]).catch(() => {});
+    throw new Error(`uploadMedia insert: ${insertError.message}`);
+  }
+
+  // 5. Tag profiles if requested.
+  if (taggedProfileIds.length > 0) {
+    const tags = taggedProfileIds.map((profileId) => ({
+      media_id: row.id,
+      profile_id: profileId,
+      user_id: userId,
+    }));
+
+    const { error: tagError } = await supabase.from('media_people').insert(tags);
+    if (tagError) {
+      console.error('uploadMedia tagging failed:', tagError.message);
+    }
+  }
+
+  // 6. Generate a signed URL for immediate display.
+  const signedUrl = await getSignedUrl(storagePath);
+
+  return rowToMediaItem(row, signedUrl);
+}
+
+/**
+ * Generate a fresh signed URL for a storage path.
+ * Call this every time you need to display a private media item.
+ */
+export async function getSignedUrl(storagePath: string): Promise<string> {
+  const { data, error } = await supabase.storage
+    .from(BUCKET)
+    .createSignedUrl(storagePath, SIGNED_URL_EXPIRY_SECONDS);
+
+  if (error || !data?.signedUrl) {
+    throw new Error(`getSignedUrl: ${error?.message ?? 'no URL returned'}`);
+  }
+
+  return data.signedUrl;
+}
+
+/**
+ * List all media items for the current user (RLS-filtered).
+ * Signed URLs are generated in parallel for all items.
+ */
+export async function listMedia(): Promise<MediaItem[]> {
+  const { data, error } = await supabase
+    .from('media')
+    .select('*')
+    .order('created_at', { ascending: false });
+
+  if (error) throw new Error(`listMedia: ${error.message}`);
+
+  const rows = data ?? [];
+  const signedUrls = await Promise.all(
+    rows.map((r) => getSignedUrl(r.storage_path).catch(() => ''))
+  );
+
+  return rows.map((row, i) => rowToMediaItem(row, signedUrls[i]));
+}
+
+/**
+ * Delete a media row and its file from Storage.
+ * Cascades to media_people via FK ON DELETE CASCADE.
+ */
+export async function deleteMedia(mediaId: string, storagePath: string): Promise<void> {
+  const [{ error: dbError }, { error: storageError }] = await Promise.all([
+    supabase.from('media').delete().eq('id', mediaId),
+    supabase.storage.from(BUCKET).remove([storagePath]),
+  ]);
+
+  if (dbError) throw new Error(`deleteMedia db: ${dbError.message}`);
+  if (storageError) throw new Error(`deleteMedia storage: ${storageError.message}`);
+}
+
+// ── Helpers ──────────────────────────────────────────────────────────────────
+
+function inferKind(mimeType: string): 'photo' | 'video' | 'audio' | 'document' {
+  if (mimeType.startsWith('image/')) return 'photo';
+  if (mimeType.startsWith('video/')) return 'video';
+  if (mimeType.startsWith('audio/')) return 'audio';
+  return 'document';
+}
diff -ruN before/src/repos/postRepo.ts after/src/repos/postRepo.ts
--- before/src/repos/postRepo.ts	1970-01-01 00:00:00.000000000 +0000
+++ after/src/repos/postRepo.ts	2026-02-21 02:04:19.537189724 +0000
@@ -0,0 +1,80 @@
+// ---------------------------------------------------------------------------
+// repos/postRepo.ts
+// Posts are created with an optional list of tagged profile IDs.
+// Mentions are stored in post_people in the same transaction (via Promise.all
+// after insert — Supabase JS v2 does not yet support true multi-statement
+// transactions from the client, so we do a best-effort insert and surface
+// any failure clearly).
+// ---------------------------------------------------------------------------
+
+import { supabase } from '../lib/supabaseClient';
+import { rowToPost, postToInsert } from '../lib/mappers';
+import type { CirclePost } from '../types';
+
+/**
+ * Insert a post and its tagged-profile join rows.
+ * If mention insertion fails the post still exists; the error is logged but
+ * not re-thrown so the UI stays responsive.
+ */
+export async function createPost(post: CirclePost): Promise<CirclePost> {
+  // 1. Insert the post row.
+  const { data, error } = await supabase
+    .from('posts')
+    .insert(postToInsert(post))
+    .select()
+    .single();
+
+  if (error) throw new Error(`createPost: ${error.message}`);
+
+  // 2. Insert mention rows for each tagged profile.
+  if (post.taggedProfileIds.length > 0) {
+    const mentions = post.taggedProfileIds.map((profileId) => ({
+      post_id: data.id,
+      profile_id: profileId,
+      user_id: post.userId,
+    }));
+
+    const { error: mentionError } = await supabase
+      .from('post_people')
+      .insert(mentions);
+
+    if (mentionError) {
+      // Non-fatal: the post is saved, just log the partial failure.
+      console.error('createPost mentions insert failed:', mentionError.message);
+    }
+  }
+
+  return rowToPost(data, post.taggedProfileIds);
+}
+
+/**
+ * List posts for the current user (RLS-filtered), newest first.
+ * Fetches tagged profile IDs by joining post_people.
+ */
+export async function listPosts(): Promise<CirclePost[]> {
+  // Fetch posts + their mentions in one query using PostgREST's nested select.
+  const { data, error } = await supabase
+    .from('posts')
+    .select(`
+      *,
+      post_people ( profile_id )
+    `)
+    .order('created_at', { ascending: false });
+
+  if (error) throw new Error(`listPosts: ${error.message}`);
+
+  return (data ?? []).map((row) => {
+    const taggedProfileIds = (row.post_people as { profile_id: string }[]).map(
+      (pp) => pp.profile_id
+    );
+    return rowToPost(row, taggedProfileIds);
+  });
+}
+
+/**
+ * Delete a post. Cascades to post_people rows via FK ON DELETE CASCADE.
+ */
+export async function deletePost(postId: string): Promise<void> {
+  const { error } = await supabase.from('posts').delete().eq('id', postId);
+  if (error) throw new Error(`deletePost: ${error.message}`);
+}
diff -ruN before/src/repos/profileRepo.ts after/src/repos/profileRepo.ts
--- before/src/repos/profileRepo.ts	1970-01-01 00:00:00.000000000 +0000
+++ after/src/repos/profileRepo.ts	2026-02-21 02:04:19.544189724 +0000
@@ -0,0 +1,80 @@
+// ---------------------------------------------------------------------------
+// repos/profileRepo.ts
+// Profiles are bulk-upserted on GEDCOM import, and individually upserted
+// whenever the user edits a profile in the app.
+// ---------------------------------------------------------------------------
+
+import { supabase } from '../lib/supabaseClient';
+import { rowToProfile, profileToInsert } from '../lib/mappers';
+import type { Profile } from '../types';
+
+/**
+ * Insert or update a single profile.
+ * Pass `treeId` when creating during a GEDCOM import so the profile is
+ * associated with the new tree.
+ */
+export async function upsertProfile(
+  profile: Profile,
+  treeId?: string
+): Promise<Profile> {
+  const { data, error } = await supabase
+    .from('profiles')
+    .upsert(profileToInsert(profile, treeId), { onConflict: 'id' })
+    .select()
+    .single();
+
+  if (error) throw new Error(`upsertProfile: ${error.message}`);
+  return rowToProfile(data);
+}
+
+/**
+ * Bulk upsert — used during a GEDCOM import where hundreds of profiles
+ * arrive at once. Batches into chunks of 200 to stay within Supabase limits.
+ */
+export async function upsertProfiles(
+  profiles: Profile[],
+  treeId?: string
+): Promise<Profile[]> {
+  const CHUNK = 200;
+  const results: Profile[] = [];
+
+  for (let i = 0; i < profiles.length; i += CHUNK) {
+    const chunk = profiles.slice(i, i + CHUNK);
+    const { data, error } = await supabase
+      .from('profiles')
+      .upsert(
+        chunk.map((p) => profileToInsert(p, treeId)),
+        { onConflict: 'id' }
+      )
+      .select();
+
+    if (error) throw new Error(`upsertProfiles (chunk ${i}): ${error.message}`);
+    results.push(...(data ?? []).map(rowToProfile));
+  }
+
+  return results;
+}
+
+/**
+ * List every profile that belongs to the current user.
+ * Optionally scope to a single tree.
+ */
+export async function listProfiles(treeId?: string): Promise<Profile[]> {
+  let query = supabase.from('profiles').select('*');
+
+  if (treeId) {
+    query = query.eq('tree_id', treeId);
+  }
+
+  const { data, error } = await query.order('name', { ascending: true });
+  if (error) throw new Error(`listProfiles: ${error.message}`);
+  return (data ?? []).map(rowToProfile);
+}
+
+/**
+ * Hard-delete a profile. Cascades to post_people and media_people via FK.
+ */
+export async function deleteProfile(profileId: string): Promise<void> {
+  const { error } = await supabase.from('profiles').delete().eq('id', profileId);
+  if (error) throw new Error(`deleteProfile: ${error.message}`);
+}
diff -ruN before/src/repos/treeRepo.ts after/src/repos/treeRepo.ts
--- before/src/repos/treeRepo.ts	1970-01-01 00:00:00.000000000 +0000
+++ after/src/repos/treeRepo.ts	2026-02-21 02:04:19.549189724 +0000
@@ -0,0 +1,56 @@
+// ---------------------------------------------------------------------------
+// repos/treeRepo.ts
+// All queries rely on RLS for user scoping; auth.uid() is evaluated
+// server-side so no user_id filter is needed client-side. We still pass
+// user_id explicitly on INSERT because RLS WITH CHECK requires it to match
+// auth.uid() and the client sets it directly.
+// ---------------------------------------------------------------------------
+
+import { supabase } from '../lib/supabaseClient';
+import { rowToTree, treeToInsert } from '../lib/mappers';
+import type { FamilyTree } from '../types';
+
+/**
+ * Persist a new tree. Typically called once per GEDCOM import.
+ * Throws on Supabase error so the caller can surface it via toast.
+ */
+export async function createTree(tree: FamilyTree): Promise<FamilyTree> {
+  const { data, error } = await supabase
+    .from('trees')
+    .insert(treeToInsert(tree))
+    .select()
+    .single();
+
+  if (error) throw new Error(`createTree: ${error.message}`);
+  return rowToTree(data);
+}
+
+/**
+ * Return all trees belonging to the authenticated user.
+ * RLS ensures only the current user's rows are returned.
+ */
+export async function listTrees(): Promise<FamilyTree[]> {
+  const { data, error } = await supabase
+    .from('trees')
+    .select('*')
+    .order('created_at', { ascending: false });
+
+  if (error) throw new Error(`listTrees: ${error.message}`);
+  return (data ?? []).map(rowToTree);
+}
+
+/**
+ * Update the home_person_id and member_ids after the user picks a home person.
+ */
+export async function updateTree(
+  id: string,
+  patch: { homePersonId?: string; memberIds?: string[]; name?: string }
+): Promise<void> {
+  const update: Record<string, unknown> = {};
+  if (patch.homePersonId !== undefined) update.home_person_id = patch.homePersonId;
+  if (patch.memberIds !== undefined)    update.member_ids = patch.memberIds;
+  if (patch.name !== undefined)         update.name = patch.name;
+
+  const { error } = await supabase.from('trees').update(update).eq('id', id);
+  if (error) throw new Error(`updateTree: ${error.message}`);
+}
diff -ruN before/src/services/gemini.ts after/src/services/gemini.ts
--- before/src/services/gemini.ts	1970-01-01 00:00:00.000000000 +0000
+++ after/src/services/gemini.ts	2026-02-21 02:04:16.164189750 +0000
@@ -0,0 +1,126 @@
+// services/gemini.ts
+// All Gemini calls now proxy through /api/gemini (a Vercel serverless function).
+// No @google/genai import, no API key, no process.env in this file.
+
+import type { Profile } from '../types';
+import { formatEventSentence } from '../utils/formatters';
+
+// ── Shared transport ──────────────────────────────────────────────────────────
+
+const ENDPOINT = '/api/gemini';
+
+interface SummaryResponse  { text: string }
+interface ResearchResponse { text: string; sources: GroundingSource[] }
+interface PortraitResponse { imageBase64: string }
+interface ErrorResponse    { error: string }
+
+interface GroundingSource {
+  web?: { uri: string; title: string };
+}
+
+type ApiAction = 'summary' | 'research' | 'portrait';
+
+async function callGemini(action: ApiAction, prompt: string): Promise<Response> {
+  return fetch(ENDPOINT, {
+    method: 'POST',
+    headers: { 'Content-Type': 'application/json' },
+    body: JSON.stringify({ action, prompt }),
+  });
+}
+
+/** Parse the response, throwing a human-readable message on failure. */
+async function parseOrThrow<T>(res: Response): Promise<T> {
+  const body = await res.json() as T | ErrorResponse;
+  if (!res.ok) {
+    const msg = (body as ErrorResponse).error ?? `Server error ${res.status}`;
+    throw new Error(msg);
+  }
+  return body as T;
+}
+
+// ── Public API (same signatures as the original service) ─────────────────────
+
+/**
+ * Generate a narrative life summary for a profile.
+ * Model: gemini-2.0-flash (server-side)
+ */
+export async function generateAiProfileSummary(profile: Profile): Promise<string> {
+  const events = profile.timeline
+    .map((ev) => formatEventSentence(profile.name, ev))
+    .join('\n');
+  const memories = profile.memories.map((m) => m.content).join('\n');
+
+  const prompt = `
+Generate a respectful, high-quality, narrative life summary for ${profile.name} (born ${profile.birthYear}).
+Use the following timeline events and family stories to weave a cohesive biographical sketch.
+
+Timeline:
+${events}
+
+Family Stories:
+${memories}
+
+Instructions:
+- Focus on the impact of their life.
+- Keep it under 250 words.
+- Maintain an archival, historical, and elegant tone.
+`.trim();
+
+  try {
+    const res = await callGemini('summary', prompt);
+    const data = await parseOrThrow<SummaryResponse>(res);
+    return data.text;
+  } catch (err) {
+    console.error('[gemini] generateAiProfileSummary:', err);
+    return 'Failed to generate AI summary.';
+  }
+}
+
+/**
+ * Fetch grounded historical context for a profile's life period and locations.
+ * Model: gemini-2.5-pro-preview-05-06 with Google Search grounding (server-side)
+ */
+export async function getHistoricalContext(
+  profile: Profile
+): Promise<{ text: string; sources: GroundingSource[] }> {
+  const lifePeriod = `${profile.birthYear} to ${profile.deathYear || 'the present'}`;
+  const locations = Array.from(
+    new Set(profile.timeline.map((e) => e.place).filter(Boolean))
+  ).join(', ');
+
+  const prompt = `Provide a comprehensive historical deep-dive into the era and specific locations inhabited by ${profile.name} during their life from ${lifePeriod}.
+The primary locations were: ${locations}.
+
+Research and describe:
+1. Specific local history and atmosphere of ${locations} during these decades.
+2. Major global events (wars, movements, economic shifts) that significantly altered their daily world.
+3. Technological innovations or cultural changes that a person living in ${locations} would have witnessed.
+
+Format this as a "Historical Narrative" for a family archive. Be specific, evocative, and archival in tone.`.trim();
+
+  try {
+    const res = await callGemini('research', prompt);
+    const data = await parseOrThrow<ResearchResponse>(res);
+    return { text: data.text, sources: data.sources ?? [] };
+  } catch (err) {
+    console.error('[gemini] getHistoricalContext:', err);
+    return {
+      text: 'Our digital archives could not be reached. Please check your connection and try again.',
+      sources: [],
+    };
+  }
+}
+
+/**
+ * Generate an AI portrait image for a profile.
+ * Model: gemini-2.0-flash-preview-image-generation (server-side)
+ * Returns a data URL string ready to assign to profile.imageUrl.
+ * Throws on failure so the caller (App.tsx) can catch and show a toast.
+ */
+export async function generateAiPortrait(profile: Profile): Promise<string> {
+  const prompt = `A period-accurate, elegant studio portrait of a person named ${profile.name} born in ${profile.birthYear}. Style: historical photographic daguerreotype or charcoal sketch, highly detailed, archival museum quality.`;
+
+  const res = await callGemini('portrait', prompt);
+  const data = await parseOrThrow<PortraitResponse>(res);
+  return `data:image/png;base64,${data.imageBase64}`;
+}
diff -ruN before/src/types.ts after/src/types.ts
--- before/src/types.ts	1970-01-01 00:00:00.000000000 +0000
+++ after/src/types.ts	2026-02-21 02:03:53.062189922 +0000
@@ -0,0 +1,101 @@
+
+export interface User {
+  id: string;
+  email: string;
+  name: string;
+  createdAt: string;
+}
+
+export type MediaKind = 'photo' | 'video' | 'audio' | 'document';
+
+export interface MediaItem {
+  id: string;
+  name: string;
+  kind: MediaKind;
+  url: string;
+  mime?: string;
+  size?: number;
+  createdAt: string;
+}
+
+export interface LifeEvent {
+  id: string;
+  type: string;
+  date: string;
+  place: string;
+  spouseName?: string;
+  media: MediaItem[];
+}
+
+export interface Memory {
+  id: string;
+  type: 'story' | 'note';
+  content: string;
+  timestamp: string;
+}
+
+export interface Profile {
+  id: string;
+  userId: string;
+  name: string;
+  gender?: 'M' | 'F' | 'U';
+  birthYear: string;
+  deathYear?: string;
+  imageUrl: string;
+  summary: string;
+  historicalContext?: {
+    text: string;
+    sources: any[];
+  };
+  timeline: LifeEvent[];
+  memories: Memory[];
+  sources: string[];
+  isMemorial?: boolean;
+  // Relationships
+  parentIds: string[];
+  childIds: string[];
+  spouseIds: string[];
+}
+
+export interface FamilyTree {
+  id: string;
+  userId: string;
+  name: string;
+  createdAt: string;
+  homePersonId: string;
+  memberIds: string[];
+}
+
+export type AttachmentKind = 'photo' | 'video' | 'audio' | 'document';
+
+export interface CircleAttachment {
+  id: string;
+  kind: AttachmentKind;
+  name: string;
+  dataUrl: string;
+  size?: number;
+}
+
+export interface CirclePost {
+  id: string;
+  userId: string;
+  createdAt: string;
+  authorLabel: string;
+  body: string;
+  attachments: CircleAttachment[];
+  taggedProfileIds: string[];
+}
+
+export enum AppView {
+  SPLASH = 'splash',
+  LOGIN = 'login',
+  HOME = 'home',
+  TREES = 'trees',
+  TREE_VIEW = 'tree_view',
+  SELECT_HOME = 'select_home',
+  PROFILE = 'profile',
+  EDIT_PROFILE = 'edit_profile',
+  LINK_RELATIVE = 'link_relative',
+  CREATE_MEMORY = 'create_memory',
+  FAMILY_CIRCLE = 'family_circle'
+}
diff -ruN before/src/utils/assertAuthenticated.test.ts after/src/utils/assertAuthenticated.test.ts
--- before/src/utils/assertAuthenticated.test.ts	1970-01-01 00:00:00.000000000 +0000
+++ after/src/utils/assertAuthenticated.test.ts	2026-02-21 02:04:24.853189685 +0000
@@ -0,0 +1,92 @@
+// utils/assertAuthenticated.test.ts
+//
+// Run with:  npx vitest run utils/assertAuthenticated.test.ts
+// Or:        npx jest utils/assertAuthenticated.test.ts
+//
+// No React, no Supabase, no network — pure unit tests.
+
+import { describe, it, expect } from 'vitest';
+import { assertAuthenticated, AuthenticationError } from './assertAuthenticated';
+
+// Minimal user stub — only `id` matters for the guard.
+const validUser = { id: 'user-abc-123', email: 'test@example.com', name: 'Test', createdAt: '' };
+
+describe('assertAuthenticated', () => {
+  // ── Should NOT throw (authenticated) ──────────────────────────────────────
+
+  it('does not throw when user has a valid id', () => {
+    expect(() => assertAuthenticated(validUser)).not.toThrow();
+  });
+
+  it('does not throw when called with context and a valid user', () => {
+    expect(() => assertAuthenticated(validUser, 'GEDCOM upload')).not.toThrow();
+  });
+
+  // ── Should throw (unauthenticated) ────────────────────────────────────────
+
+  it('throws AuthenticationError when user is null', () => {
+    expect(() => assertAuthenticated(null)).toThrow(AuthenticationError);
+  });
+
+  it('throws AuthenticationError when user is undefined', () => {
+    expect(() => assertAuthenticated(undefined)).toThrow(AuthenticationError);
+  });
+
+  it('throws AuthenticationError when user.id is empty string', () => {
+    expect(() => assertAuthenticated({ id: '' })).toThrow(AuthenticationError);
+  });
+
+  // ── Error shape ───────────────────────────────────────────────────────────
+
+  it('error has code NOT_AUTHENTICATED', () => {
+    try {
+      assertAuthenticated(null);
+      expect.fail('should have thrown');
+    } catch (err) {
+      expect(err).toBeInstanceOf(AuthenticationError);
+      expect((err as AuthenticationError).code).toBe('NOT_AUTHENTICATED');
+    }
+  });
+
+  it('error message includes the context when provided', () => {
+    try {
+      assertAuthenticated(null, 'GEDCOM upload');
+      expect.fail('should have thrown');
+    } catch (err) {
+      expect((err as AuthenticationError).message).toContain('GEDCOM upload');
+    }
+  });
+
+  it('error message does not mention context when not provided', () => {
+    try {
+      assertAuthenticated(null);
+      expect.fail('should have thrown');
+    } catch (err) {
+      const msg = (err as AuthenticationError).message;
+      // Should be a clean sentence ending in a period, no parenthetical
+      expect(msg).toMatch(/signed in/i);
+      expect(msg).not.toContain('(');
+    }
+  });
+
+  it('error name is AuthenticationError', () => {
+    try {
+      assertAuthenticated(null);
+      expect.fail('should have thrown');
+    } catch (err) {
+      expect((err as Error).name).toBe('AuthenticationError');
+    }
+  });
+
+  // ── TypeScript narrowing (compile-time, verified by type assertions below) ─
+
+  it('narrows the type to { id: string } after the call', () => {
+    // This test is primarily a compile-time check. If TypeScript is happy,
+    // the `asserts` return type is working correctly.
+    const user: { id: string } | null = validUser;
+    assertAuthenticated(user);
+    // After this line, TypeScript knows user is { id: string }, not null.
+    // We verify it at runtime by accessing .id without a null check:
+    expect(user.id).toBe('user-abc-123');
+  });
+});
diff -ruN before/src/utils/assertAuthenticated.ts after/src/utils/assertAuthenticated.ts
--- before/src/utils/assertAuthenticated.ts	1970-01-01 00:00:00.000000000 +0000
+++ after/src/utils/assertAuthenticated.ts	2026-02-21 02:04:24.847189685 +0000
@@ -0,0 +1,51 @@
+// utils/assertAuthenticated.ts
+//
+// A pure, framework-free guard that enforces session presence before any
+// privileged operation executes. Because it has no React or Supabase
+// dependencies it can be imported in unit tests without mocking anything.
+//
+// Usage:
+//   assertAuthenticated(session.user);           // throws on !user
+//   assertAuthenticated(session.user, 'upload'); // throws with context
+//
+// The thrown AuthenticationError is caught at the call-site and its
+// `.message` is shown to the user via toast / UI, not console only.
+
+export class AuthenticationError extends Error {
+  readonly code = 'NOT_AUTHENTICATED' as const;
+
+  constructor(context?: string) {
+    const where = context ? ` (${context})` : '';
+    super(`You must be signed in to perform this action${where}.`);
+    this.name = 'AuthenticationError';
+  }
+}
+
+/**
+ * Assert that `user` is non-null and non-undefined.
+ * Throws `AuthenticationError` if the assertion fails.
+ *
+ * @param user       - The current session user, or null/undefined.
+ * @param context    - Optional label included in the error message for
+ *                     easier debugging (e.g. "GEDCOM upload").
+ *
+ * @example
+ * // Handler — throws before any privileged work starts:
+ * function handleGedcomUpload(user: User | null, file: File) {
+ *   assertAuthenticated(user, 'GEDCOM upload');
+ *   // ...safe to proceed
+ * }
+ *
+ * @example
+ * // Test:
+ * expect(() => assertAuthenticated(null)).toThrow(AuthenticationError);
+ * expect(() => assertAuthenticated({ id: '1', ... })).not.toThrow();
+ */
+export function assertAuthenticated(
+  user: { id: string } | null | undefined,
+  context?: string
+): asserts user is { id: string } {
+  if (!user || !user.id) {
+    throw new AuthenticationError(context);
+  }
+}
diff -ruN before/src/utils/date.ts after/src/utils/date.ts
--- before/src/utils/date.ts	1970-01-01 00:00:00.000000000 +0000
+++ after/src/utils/date.ts	2026-02-21 02:04:24.818189685 +0000
@@ -0,0 +1,45 @@
+
+import { MONTHS } from '../constants.tsx';
+import { gedcomDateToSortKey } from './gedcom';
+
+// Re-export for backward compatibility
+export const parseGedcomDate = gedcomDateToSortKey;
+
+export const parseGedcomMonthDayYear = (dateStr?: string) => {
+  if (!dateStr) return {};
+  const cleaned = dateStr.toUpperCase().replace(/ABT\.?|EST\.?|BEF\.?|AFT\.?|BET\.?|AND\b|CAL\.?/g, '').trim();
+  const yearMatch = cleaned.match(/\b(\d{4})\b/);
+  const year = yearMatch ? parseInt(yearMatch[1], 10) : undefined;
+  const monthIndex = MONTHS.findIndex((m) => new RegExp(`\\b${m}\\b`).test(cleaned));
+  const month = monthIndex >= 0 ? monthIndex + 1 : undefined;
+  let day: number | undefined;
+  if (month) {
+    const parts = cleaned.split(/\s+/).filter(Boolean);
+    const mIdx = parts.findIndex((p) => p === MONTHS[month - 1]);
+    if (mIdx > 0) {
+      const candidate = parseInt(parts[mIdx - 1], 10);
+      if (!Number.isNaN(candidate) && candidate >= 1 && candidate <= 31) day = candidate;
+    }
+  }
+  return { month, day, year };
+};
+
+export const formatFullDate = (dateStr?: string): string => {
+  if (!dateStr) return 'Undated';
+  // Strip GEDCOM qualifiers for display
+  const clean = dateStr.replace(/^(ABT\.?|EST\.?|BEF\.?|AFT\.?|CAL\.?|CIR\.?|CIRCA)\s*/i, '').trim();
+  const { month, day, year } = parseGedcomMonthDayYear(dateStr);
+  if (year && month && day) {
+    try {
+      return new Date(year, month - 1, day).toLocaleDateString('en-US', {
+        month: 'long', day: 'numeric', year: 'numeric',
+      });
+    } catch { /* fall through */ }
+  }
+  if (year && month) {
+    const monthName = new Date(year, month - 1, 1).toLocaleDateString('en-US', { month: 'long' });
+    return `${monthName} ${year}`;
+  }
+  if (year) return String(year);
+  return clean || 'Undated';
+};
diff -ruN before/src/utils/formatters.ts after/src/utils/formatters.ts
--- before/src/utils/formatters.ts	1970-01-01 00:00:00.000000000 +0000
+++ after/src/utils/formatters.ts	2026-02-21 02:04:24.823189685 +0000
@@ -0,0 +1,50 @@
+
+import { formatFullDate } from './date';
+import { eventVerb } from '../constants.tsx';
+import { LifeEvent, MediaKind } from '../types';
+
+export const formatEventSentence = (profileName: string, ev: LifeEvent): string => {
+  const dateStr = ev.date ? formatFullDate(ev.date) : '';
+  const placeStr = ev.place ? ev.place.trim() : '';
+  
+  if (ev.type === 'Birth') {
+    let part = '';
+    if (dateStr && placeStr) part = `on ${dateStr}, in ${placeStr}`;
+    else if (dateStr) part = `on ${dateStr}`;
+    else if (placeStr) part = `in ${placeStr}`;
+    return `${profileName} was born${part ? ' ' + part : ''}.`;
+  }
+  
+  if (ev.type === 'Marriage') {
+    const spouse = ev.spouseName || 'Unknown';
+    let part = '';
+    if (placeStr && dateStr) part = `in ${placeStr} on ${dateStr}`;
+    else if (placeStr) part = `in ${placeStr}`;
+    else if (dateStr) part = `on ${dateStr}`;
+    return `${profileName} married ${spouse}${part ? ' ' + part : ''}.`;
+  }
+
+  const verb = eventVerb(ev.type);
+  let part = '';
+  if (dateStr && placeStr) part = `on ${dateStr} in ${placeStr}`;
+  else if (dateStr) part = `on ${dateStr}`;
+  else if (placeStr) part = `in ${placeStr}`;
+  return `${profileName} ${verb}${part ? ' ' + part : ''}.`;
+};
+
+export const inferMediaKind = (fileName: string, fileType?: string): MediaKind => {
+  const lower = fileName.toLowerCase();
+  const t = (fileType || '').toLowerCase();
+  if (t.startsWith('image/') || /\.(jpg|jpeg|png|webp|gif|heic)$/i.test(lower)) return 'photo';
+  if (t.startsWith('video/') || /\.(mp4|mov|m4v|webm)$/i.test(lower)) return 'video';
+  if (t.startsWith('audio/') || /\.(mp3|m4a|wav|aac|ogg|flac)$/i.test(lower)) return 'audio';
+  if (t === 'application/pdf' || /\.pdf$/i.test(lower)) return 'document';
+  if (t.includes('word') || /\.(doc|docx)$/i.test(lower)) return 'document';
+  return 'document';
+};
+
+export const getSurname = (name: string): string => {
+  if (!name) return '';
+  const parts = name.trim().split(/\s+/);
+  return parts.length > 1 ? parts[parts.length - 1] : name;
+};
diff -ruN before/src/utils/gedcom.ts after/src/utils/gedcom.ts
--- before/src/utils/gedcom.ts	1970-01-01 00:00:00.000000000 +0000
+++ after/src/utils/gedcom.ts	2026-02-21 02:04:24.829189685 +0000
@@ -0,0 +1,292 @@
+
+import { Profile, FamilyTree, LifeEvent } from '../types';
+import { getPlaceholderImage } from '../constants';
+
+const tagToLabel: Record<string, string> = {
+  BIRT: 'Birth',
+  BAPM: 'Baptism',
+  BAPT: 'Baptism',
+  CHR:  'Christening',
+  DEAT: 'Death',
+  BURI: 'Burial',
+  CREM: 'Cremation',
+  RESI: 'Residence',
+  EMIG: 'Departure/Emigration',
+  IMMI: 'Arrival/Immigration',
+  CENS: 'Census',
+  MARR: 'Marriage',
+  DIV:  'Divorce',
+  DIVO: 'Divorce',
+  GRAD: 'Graduation',
+  EDUC: 'Education',
+  OCCU: 'Occupation',
+  TITL: 'Title',
+  NATI: 'Nationality',
+  RELI: 'Religion',
+  NATU: 'Naturalization',
+  ADOP: 'Adoption',
+  BARM: 'Bar Mitzvah',
+  BATM: 'Bat Mitzvah',
+  CONF: 'Confirmation',
+  PROB: 'Probate',
+  WILL: 'Will',
+  EVEN: 'Event',
+  FACT: 'Fact',
+  ORDN: 'Ordination',
+  MILI: 'Military Service',
+  RETI: 'Retirement',
+};
+
+const MONTH_ABBR = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'];
+
+export const gedcomDateToSortKey = (dateStr?: string): number => {
+  if (!dateStr) return 9999;
+  const upper = dateStr.toUpperCase()
+    .replace(/ABT\.?|EST\.?|CAL\.?|BEF\.?|AFT\.?|CIR\.?|CIRCA|BET\.?|AND\b/g, '')
+    .trim();
+  const yearMatch = upper.match(/\b(\d{4})\b/);
+  if (!yearMatch) return 9999;
+  const year = parseInt(yearMatch[1], 10);
+  const monthIdx = MONTH_ABBR.findIndex(m => upper.includes(m));
+  const month = monthIdx >= 0 ? monthIdx + 1 : 0;
+  let day = 0;
+  if (month) {
+    const parts = upper.split(/\s+/).filter(Boolean);
+    const mi = parts.findIndex(p => p === MONTH_ABBR[month - 1]);
+    if (mi > 0) {
+      const candidate = parseInt(parts[mi - 1], 10);
+      if (!isNaN(candidate) && candidate >= 1 && candidate <= 31) day = candidate;
+    }
+  }
+  return year + month / 12 + day / 365;
+};
+
+function addOrUpdateMarriage(
+  person: Profile | undefined,
+  spouse: Profile | undefined,
+  date: string,
+  place: string,
+  stamp: string
+) {
+  if (!person) return;
+  const existing = person.timeline.find(e => e.type === 'Marriage' && e.date === date);
+  if (existing) {
+    if (!existing.spouseName) existing.spouseName = spouse?.name ?? 'Unknown';
+    if (place && !existing.place) existing.place = place;
+  } else {
+    person.timeline.push({
+      id: `ev-marr-${stamp}-${Math.random().toString(36).slice(2, 6)}`,
+      type: 'Marriage',
+      date,
+      place,
+      spouseName: spouse?.name ?? 'Unknown',
+      media: [],
+    });
+  }
+}
+
+export const parseGedcom = (
+  text: string,
+  userId: string,
+  maxGenerations = 4
+): { importedProfiles: Profile[]; tree: FamilyTree } => {
+  const importStamp = Date.now().toString();
+  const indis = new Map<string, any>();
+  const fams  = new Map<string, any>();
+
+  let currentIndi:  any = null;
+  let currentFam:   any = null;
+  let currentEvent: any = null;
+  let homeGedId: string | null = null;
+
+  for (const rawLine of text.split(/\r?\n/)) {
+    const line = rawLine.trim();
+    if (!line) continue;
+    const spaceIdx = line.indexOf(' ');
+    if (spaceIdx === -1) continue;
+    const level     = line.slice(0, spaceIdx);
+    const remainder = line.slice(spaceIdx + 1);
+    const spaceIdx2 = remainder.indexOf(' ');
+    const tagOrXref = spaceIdx2 === -1 ? remainder : remainder.slice(0, spaceIdx2);
+    const rest      = spaceIdx2 === -1 ? '' : remainder.slice(spaceIdx2 + 1);
+
+    if (level === '0') {
+      currentEvent = null;
+      if (rest === 'INDI') {
+        const gid = tagOrXref;
+        if (!homeGedId) homeGedId = gid;
+        currentIndi = {
+          gedId: gid, name: 'Unknown', gender: 'U',
+          timeline: [], birthYear: 'Unknown', deathYear: undefined,
+          famc: null as string | null, fams: [] as string[],
+        };
+        indis.set(gid, currentIndi);
+        currentFam = null;
+      } else if (rest === 'FAM') {
+        currentFam = { gedId: tagOrXref, husb: '', wife: '', chil: [] as string[], marrDate: '', marrPlace: '' };
+        fams.set(tagOrXref, currentFam);
+        currentIndi = null;
+      } else {
+        currentIndi = null;
+        currentFam  = null;
+      }
+      continue;
+    }
+
+    if (currentIndi) {
+      if (level === '1') {
+        if (tagOrXref === 'NAME') {
+          currentIndi.name = rest.replace(/\//g, ' ').replace(/\s{2,}/g, ' ').trim() || 'Unknown';
+        } else if (tagOrXref === 'SEX') {
+          const s = rest.trim().toUpperCase();
+          currentIndi.gender = s === 'M' ? 'M' : s === 'F' ? 'F' : 'U';
+        } else if (tagOrXref === 'FAMC') {
+          currentIndi.famc = rest.trim();
+        } else if (tagOrXref === 'FAMS') {
+          currentIndi.fams.push(rest.trim());
+        } else if (tagToLabel[tagOrXref]) {
+          currentEvent = {
+            id: `ev-${importStamp}-${Math.random().toString(36).slice(2, 9)}`,
+            type: tagToLabel[tagOrXref],
+            date: '', place: '', media: [],
+          };
+          currentIndi.timeline.push(currentEvent);
+        } else {
+          currentEvent = null;
+        }
+      } else if (level === '2' && currentEvent) {
+        if (tagOrXref === 'DATE') {
+          currentEvent.date = rest.trim();
+          const y = rest.match(/\b(\d{4})\b/);
+          if (y) {
+            if (currentEvent.type === 'Birth') currentIndi.birthYear = y[1];
+            if (currentEvent.type === 'Death') currentIndi.deathYear = y[1];
+          }
+        } else if (tagOrXref === 'PLAC') {
+          currentEvent.place = rest.trim();
+        } else if (tagOrXref === 'NOTE') {
+          currentEvent.note = rest.trim();
+        } else if (tagOrXref === 'TYPE' && rest.trim()) {
+          currentEvent.subType = rest.trim();
+        }
+      }
+      continue;
+    }
+
+    if (currentFam) {
+      if (level === '1') {
+        if      (tagOrXref === 'HUSB') { currentFam.husb = rest.trim(); currentEvent = null; }
+        else if (tagOrXref === 'WIFE') { currentFam.wife = rest.trim(); currentEvent = null; }
+        else if (tagOrXref === 'CHIL') { currentFam.chil.push(rest.trim()); currentEvent = null; }
+        else if (tagOrXref === 'MARR') { currentEvent = { type: 'MARR' }; }
+        else                           { currentEvent = null; }
+      } else if (level === '2' && currentEvent?.type === 'MARR') {
+        if (tagOrXref === 'DATE')  currentFam.marrDate  = rest.trim();
+        if (tagOrXref === 'PLAC')  currentFam.marrPlace = rest.trim();
+      }
+    }
+  }
+
+  // Generation traversal
+  const generations = new Map<string, number>();
+  const traverseGen = (gedId: string, gen: number, visited = new Set<string>()) => {
+    if (visited.has(gedId) || !indis.has(gedId)) return;
+    visited.add(gedId);
+    generations.set(gedId, gen);
+    const indi = indis.get(gedId)!;
+    if (indi.famc) {
+      const pf = fams.get(indi.famc);
+      if (pf) {
+        if (pf.husb) traverseGen(pf.husb, gen + 1, visited);
+        if (pf.wife) traverseGen(pf.wife, gen + 1, visited);
+      }
+    }
+    for (const famXref of indi.fams) {
+      const sf = fams.get(famXref);
+      if (sf) {
+        for (const childXref of sf.chil) traverseGen(childXref, gen - 1, visited);
+        if (gen === 0) {
+          if (sf.husb && sf.husb !== gedId) traverseGen(sf.husb, 0, visited);
+          if (sf.wife && sf.wife !== gedId) traverseGen(sf.wife, 0, visited);
+        }
+      }
+    }
+  };
+  if (homeGedId) traverseGen(homeGedId, 0);
+
+  // Build profile ID map
+  const profileIdFor: Record<string, string> = {};
+  const filteredIndis: any[] = [];
+  indis.forEach((indi, gedId) => {
+    const gen = generations.get(gedId);
+    if (gen !== undefined && Math.abs(gen) <= maxGenerations) {
+      profileIdFor[gedId] = `imp-${importStamp}-${gedId.replace(/@/g, '')}`;
+      filteredIndis.push(indi);
+    }
+  });
+
+  // Build Profile objects with chronologically sorted timelines
+  const importedProfiles: Profile[] = filteredIndis.map(indi => ({
+    id:          profileIdFor[indi.gedId],
+    userId,
+    name:        indi.name,
+    gender:      indi.gender,
+    birthYear:   indi.birthYear,
+    deathYear:   indi.deathYear,
+    imageUrl:    getPlaceholderImage(indi.gender),
+    summary:     '',
+    isMemorial:  true,
+    timeline:    [...indi.timeline].sort((a: LifeEvent, b: LifeEvent) =>
+                   gedcomDateToSortKey(a.date) - gedcomDateToSortKey(b.date)),
+    memories:    [],
+    sources:     [],
+    parentIds:   [],
+    childIds:    [],
+    spouseIds:   [],
+  }));
+
+  // Link relationships
+  fams.forEach(fam => {
+    const husb     = importedProfiles.find(p => p.id === profileIdFor[fam.husb]);
+    const wife     = importedProfiles.find(p => p.id === profileIdFor[fam.wife]);
+    const children = (fam.chil as string[])
+      .map(xref => importedProfiles.find(p => p.id === profileIdFor[xref]))
+      .filter(Boolean) as Profile[];
+
+    if (husb && wife) {
+      if (!husb.spouseIds.includes(wife.id)) husb.spouseIds.push(wife.id);
+      if (!wife.spouseIds.includes(husb.id)) wife.spouseIds.push(husb.id);
+    }
+    for (const child of children) {
+      if (husb) {
+        if (!child.parentIds.includes(husb.id)) child.parentIds.push(husb.id);
+        if (!husb.childIds.includes(child.id))  husb.childIds.push(child.id);
+      }
+      if (wife) {
+        if (!child.parentIds.includes(wife.id)) child.parentIds.push(wife.id);
+        if (!wife.childIds.includes(child.id))  wife.childIds.push(child.id);
+      }
+    }
+    if (fam.marrDate || fam.marrPlace) {
+      addOrUpdateMarriage(husb, wife, fam.marrDate, fam.marrPlace, importStamp);
+      addOrUpdateMarriage(wife, husb, fam.marrDate, fam.marrPlace, importStamp);
+    }
+  });
+
+  // Final re-sort after marriage events added
+  for (const p of importedProfiles) {
+    p.timeline.sort((a, b) => gedcomDateToSortKey(a.date) - gedcomDateToSortKey(b.date));
+  }
+
+  return {
+    importedProfiles,
+    tree: {
+      id:           `tree-${importStamp}`,
+      userId,
+      name:         'Staged Import Tree',
+      createdAt:    new Date().toISOString(),
+      homePersonId: homeGedId ? (profileIdFor[homeGedId] ?? '') : '',
+      memberIds:    importedProfiles.map(p => p.id),
+    },
+  };
+};
diff -ruN before/src/utils/media.ts after/src/utils/media.ts
--- before/src/utils/media.ts	1970-01-01 00:00:00.000000000 +0000
+++ after/src/utils/media.ts	2026-02-21 02:04:24.835189685 +0000
@@ -0,0 +1,45 @@
+export const compressImage = (file: File): Promise<string> => {
+  return new Promise((resolve, reject) => {
+    if (!file.type.startsWith('image/')) {
+      const reader = new FileReader();
+      reader.onload = (e) => resolve(e.target?.result as string);
+      reader.onerror = reject;
+      reader.readAsDataURL(file);
+      return;
+    }
+
+    const reader = new FileReader();
+    reader.readAsDataURL(file);
+    reader.onload = (event) => {
+      const img = new Image();
+      img.src = event.target?.result as string;
+      img.onload = () => {
+        const canvas = document.createElement('canvas');
+        const MAX_WIDTH = 800;
+        const MAX_HEIGHT = 800;
+        let width = img.width;
+        let height = img.height;
+
+        if (width > height) {
+          if (width > MAX_WIDTH) {
+            height *= MAX_WIDTH / width;
+            width = MAX_WIDTH;
+          }
+        } else {
+          if (height > MAX_HEIGHT) {
+            width *= MAX_HEIGHT / height;
+            height = MAX_HEIGHT;
+          }
+        }
+
+        canvas.width = width;
+        canvas.height = height;
+        const ctx = canvas.getContext('2d');
+        ctx?.drawImage(img, 0, 0, width, height);
+        resolve(canvas.toDataURL('image/jpeg', 0.7));
+      };
+      img.onerror = reject;
+    };
+    reader.onerror = reject;
+  });
+};
diff -ruN before/src/utils/search.ts after/src/utils/search.ts
--- before/src/utils/search.ts	1970-01-01 00:00:00.000000000 +0000
+++ after/src/utils/search.ts	2026-02-21 02:04:24.841189685 +0000
@@ -0,0 +1,40 @@
+import { getSurname } from './formatters';
+
+const getLevenshteinDistance = (a: string, b: string): number => {
+  const matrix: number[][] = [];
+  for (let i = 0; i <= a.length; i++) {
+    matrix[i] = [i];
+  }
+  for (let j = 0; j <= b.length; j++) {
+    matrix[0][j] = j;
+  }
+  for (let i = 1; i <= a.length; i++) {
+    for (let j = 1; j <= b.length; j++) {
+      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
+      matrix[i][j] = Math.min(
+        matrix[i - 1][j] + 1,
+        matrix[i][j - 1] + 1,
+        matrix[i - 1][j - 1] + cost
+      );
+    }
+  }
+  return matrix[a.length][b.length];
+};
+
+export const getFuzzyScore = (target: string, query: string): number => {
+  const str = target.toLowerCase();
+  const q = query.toLowerCase();
+  if (str === q) return 100;
+  if (str.startsWith(q)) return 80;
+  if (str.includes(q)) return 60;
+
+  const surname = getSurname(target).toLowerCase();
+  if (surname.startsWith(q)) return 70;
+
+  if (q.length > 3) {
+    const distance = getLevenshteinDistance(str, q);
+    const threshold = q.length <= 5 ? 1 : 2;
+    if (distance <= threshold) return 40 - distance;
+  }
+  return 0;
+};
diff -ruN before/src/views/CreateMemoryView.tsx after/src/views/CreateMemoryView.tsx
--- before/src/views/CreateMemoryView.tsx	1970-01-01 00:00:00.000000000 +0000
+++ after/src/views/CreateMemoryView.tsx	2026-02-21 02:04:35.952189602 +0000
@@ -0,0 +1,37 @@
+import React from 'react';
+import { ChevronLeft } from 'lucide-react';
+
+const CreateMemoryView: React.FC<{
+  newMemoryInput: string;
+  setNewMemoryInput: (v: string) => void;
+  onBack: () => void;
+  onSave: () => void;
+}> = (props) => {
+  return (
+    <div className="flex flex-col h-full bg-[#f5f2eb]">
+      <header className="pt-16 px-8 pb-6 bg-white border-b flex justify-between items-center">
+        <button onClick={props.onBack} className="text-stone-400 text-[10px] font-bold uppercase">
+          <ChevronLeft size={16} className="inline" /> Back
+        </button>
+        <h2 className="text-xl font-serif">Create Memory</h2>
+        <button onClick={props.onSave} className="bg-stone-900 text-white px-4 py-2 rounded-full text-[10px] font-bold uppercase">
+          Save
+        </button>
+      </header>
+
+      <main className="flex-1 p-8 overflow-y-auto">
+        <div className="bg-white p-6 rounded-[32px] border border-stone-100 space-y-4">
+          <div className="text-[10px] font-bold uppercase text-stone-400 tracking-widest">Memory</div>
+          <textarea
+            value={props.newMemoryInput}
+            onChange={(e) => props.setNewMemoryInput(e.target.value)}
+            className="w-full min-h-[240px] p-4 rounded-2xl border border-stone-200 outline-none"
+            placeholder="Write a memory, story, or anecdote"
+          />
+        </div>
+      </main>
+    </div>
+  );
+};
+
+export default CreateMemoryView;
diff -ruN before/src/views/EditProfileView.tsx after/src/views/EditProfileView.tsx
--- before/src/views/EditProfileView.tsx	1970-01-01 00:00:00.000000000 +0000
+++ after/src/views/EditProfileView.tsx	2026-02-21 02:04:35.962189602 +0000
@@ -0,0 +1,64 @@
+import React from 'react';
+import { ChevronLeft } from 'lucide-react';
+
+const EditProfileView: React.FC<{
+  editName: string;
+  setEditName: (v: string) => void;
+  editGender: string;
+  setEditGender: (v: string) => void;
+  editBirthYear: string;
+  setEditBirthYear: (v: string) => void;
+  editDeathYear: string;
+  setEditDeathYear: (v: string) => void;
+  editImageUrl: string;
+  setEditImageUrl: (v: string) => void;
+
+  onBack: () => void;
+  onSave: () => void;
+}> = (props) => {
+  return (
+    <div className="flex flex-col h-full bg-[#f5f2eb]">
+      <header className="pt-16 px-8 pb-6 bg-white border-b flex justify-between items-center">
+        <button onClick={props.onBack} className="text-stone-400 text-[10px] font-bold uppercase">
+          <ChevronLeft size={16} className="inline" /> Back
+        </button>
+        <h2 className="text-xl font-serif">Edit Profile</h2>
+        <button onClick={props.onSave} className="bg-stone-900 text-white px-4 py-2 rounded-full text-[10px] font-bold uppercase">
+          Save
+        </button>
+      </header>
+
+      <main className="flex-1 p-8 space-y-6 overflow-y-auto">
+        <div className="bg-white p-6 rounded-[32px] border border-stone-100 space-y-4">
+          <label className="block">
+            <div className="text-[10px] font-bold uppercase text-stone-400 tracking-widest mb-2">Full name</div>
+            <input value={props.editName} onChange={(e) => props.setEditName(e.target.value)} className="w-full p-4 rounded-2xl border border-stone-200 outline-none" />
+          </label>
+
+          <label className="block">
+            <div className="text-[10px] font-bold uppercase text-stone-400 tracking-widest mb-2">Gender</div>
+            <input value={props.editGender} onChange={(e) => props.setEditGender(e.target.value)} className="w-full p-4 rounded-2xl border border-stone-200 outline-none" placeholder="M, F, or other" />
+          </label>
+
+          <div className="grid md:grid-cols-2 gap-4">
+            <label className="block">
+              <div className="text-[10px] font-bold uppercase text-stone-400 tracking-widest mb-2">Birth year</div>
+              <input value={props.editBirthYear} onChange={(e) => props.setEditBirthYear(e.target.value)} className="w-full p-4 rounded-2xl border border-stone-200 outline-none" />
+            </label>
+            <label className="block">
+              <div className="text-[10px] font-bold uppercase text-stone-400 tracking-widest mb-2">Death year</div>
+              <input value={props.editDeathYear} onChange={(e) => props.setEditDeathYear(e.target.value)} className="w-full p-4 rounded-2xl border border-stone-200 outline-none" />
+            </label>
+          </div>
+
+          <label className="block">
+            <div className="text-[10px] font-bold uppercase text-stone-400 tracking-widest mb-2">Image URL</div>
+            <input value={props.editImageUrl} onChange={(e) => props.setEditImageUrl(e.target.value)} className="w-full p-4 rounded-2xl border border-stone-200 outline-none" />
+          </label>
+        </div>
+      </main>
+    </div>
+  );
+};
+
+export default EditProfileView;
diff -ruN before/src/views/FamilyCircleView.tsx after/src/views/FamilyCircleView.tsx
--- before/src/views/FamilyCircleView.tsx	1970-01-01 00:00:00.000000000 +0000
+++ after/src/views/FamilyCircleView.tsx	2026-02-21 02:04:35.972189602 +0000
@@ -0,0 +1,68 @@
+import React from 'react';
+import { ChevronLeft } from 'lucide-react';
+import { CirclePost, Profile, User } from '../types';
+import { PostComposer } from '../components/circle/PostComposer';
+import { CircleFeed } from '../components/circle/CircleFeed';
+
+interface FamilyCircleViewProps {
+  user: User;
+  profiles: Profile[];
+  posts: CirclePost[];
+  onBack: () => void;
+  onAddPost: (post: CirclePost) => void;
+  onDeletePost: (id: string) => void;
+  onProfileClick: (profileId: string) => void;
+}
+
+export default function FamilyCircleView({
+  user,
+  profiles,
+  posts,
+  onBack,
+  onAddPost,
+  onDeletePost,
+  onProfileClick
+}: FamilyCircleViewProps) {
+  return (
+    <div className="flex flex-col h-full bg-[#f9f8f6]">
+      {/* Header */}
+      <header className="pt-16 px-8 pb-5 bg-[#f5f2eb] border-b border-stone-200 flex-shrink-0">
+        <div className="flex justify-between items-center">
+          <button
+            onClick={onBack}
+            className="flex items-center gap-2 text-stone-500 hover:text-stone-900 transition-colors"
+          >
+            <ChevronLeft size={18} />
+            <span className="text-[11px] font-bold uppercase tracking-widest">Back</span>
+          </button>
+          <span className="text-[10px] font-bold uppercase tracking-widest text-stone-300">
+            {posts.length} {posts.length === 1 ? 'post' : 'posts'}
+          </span>
+        </div>
+        <div className="mt-4">
+          <h2 className="text-3xl font-serif text-slate-800">Family Circle</h2>
+          <p className="text-stone-400 text-[10px] font-bold uppercase mt-0.5">
+            Shared memories · {profiles.length} {profiles.length === 1 ? 'member' : 'members'}
+          </p>
+        </div>
+      </header>
+
+      {/* Scrollable content */}
+      <main className="flex-1 overflow-y-auto scrollbar-hide p-6 space-y-5 pb-10">
+        <PostComposer
+          profiles={profiles}
+          authorLabel={user.name}
+          userId={user.id}
+          onSubmit={onAddPost}
+        />
+        <CircleFeed
+          posts={posts}
+          profiles={profiles}
+          currentUserId={user.id}
+          onDeletePost={onDeletePost}
+          onProfileClick={onProfileClick}
+        />
+      </main>
+    </div>
+  );
+}
diff -ruN before/src/views/LinkRelativeView.tsx after/src/views/LinkRelativeView.tsx
--- before/src/views/LinkRelativeView.tsx	1970-01-01 00:00:00.000000000 +0000
+++ after/src/views/LinkRelativeView.tsx	2026-02-21 02:04:35.983189602 +0000
@@ -0,0 +1,56 @@
+import React from 'react';
+import { ChevronLeft, Search } from 'lucide-react';
+import { Profile } from '../types';
+
+const LinkRelativeView: React.FC<{
+  linkRole: 'parent' | 'spouse' | 'child' | null;
+  searchQuery: string;
+  setSearchQuery: (v: string) => void;
+  searchResults: Profile[];
+  onBack: () => void;
+  onSelect: (p: Profile) => void;
+}> = (props) => {
+  return (
+    <div className="flex flex-col h-full bg-[#f9f8f6]">
+      <header className="pt-16 px-8 pb-6 bg-[#f5f2eb] border-b border-stone-200">
+        <div className="flex justify-between items-center">
+          <button onClick={props.onBack} className="text-stone-400 text-[10px] font-bold uppercase">
+            <ChevronLeft size={16} className="inline" /> Back
+          </button>
+          <h2 className="text-xl font-serif">Link {props.linkRole ?? ''}</h2>
+          <div />
+        </div>
+
+        <div className="mt-6 flex items-center space-x-3 bg-white rounded-full border border-stone-200 px-4 py-3">
+          <Search size={18} className="text-stone-300" />
+          <input
+            value={props.searchQuery}
+            onChange={(e) => props.setSearchQuery(e.target.value)}
+            placeholder="Search people"
+            className="flex-1 bg-transparent outline-none text-sm"
+          />
+        </div>
+      </header>
+
+      <main className="flex-1 p-8 overflow-y-auto">
+        <div className="grid gap-3">
+          {props.searchResults.map(p => (
+            <button
+              key={p.id}
+              onClick={() => props.onSelect(p)}
+              className="w-full bg-white p-4 rounded-[32px] shadow-sm border border-stone-50 flex items-center space-x-4 hover:shadow-md transition-all"
+            >
+              <img src={p.imageUrl} className="w-14 h-14 rounded-2xl object-cover grayscale" />
+              <div className="text-left flex-1">
+                <h4 className="font-serif text-xl">{p.name}</h4>
+                <p className="text-[10px] text-stone-400 font-black uppercase mt-1">{p.birthYear} — {p.deathYear || '...'}</p>
+              </div>
+            </button>
+          ))}
+        </div>
+      </main>
+    </div>
+  );
+};
+
+export default LinkRelativeView;
diff -ruN before/src/views/ProfileView.tsx after/src/views/ProfileView.tsx
--- before/src/views/ProfileView.tsx	1970-01-01 00:00:00.000000000 +0000
+++ after/src/views/ProfileView.tsx	2026-02-21 02:04:35.992189601 +0000
@@ -0,0 +1,376 @@
+import React from 'react';
+import {
+  ChevronLeft, ChevronRight, PenTool, Sparkles, History, ScrollText, Heart, MapPin,
+  Anchor, Map as MapIcon, Quote, CloudUpload, ExternalLink, Library, Globe, Image as ImageIcon,
+  Settings, Trash2, Users, UserPlus, Camera, Upload
+} from 'lucide-react';
+import { AppView, Profile, MediaItem, LifeEvent, FamilyTree } from '../types';
+import { getEventIcon, getPlaceholderImage } from '../constants';
+import { formatEventSentence, inferMediaKind } from '../utils/formatters';
+import { formatFullDate } from '../utils/date';
+
+type RelSet = { parents: Profile[]; spouses: Profile[]; children: Profile[] }
+
+// Extract year string for the year-chip display
+const getEventYear = (dateStr?: string): string => {
+  if (!dateStr) return 'Unknown';
+  const m = dateStr.match(/\b(\d{4})\b/);
+  return m ? m[1] : 'Unknown';
+};
+
+// Self-contained per-event media uploader
+const EventMediaUploader: React.FC<{
+  eventId: string;
+  onFilesSelected: (eventId: string, files: FileList) => void;
+}> = ({ eventId, onFilesSelected }) => {
+  const inputRef = React.useRef<HTMLInputElement>(null);
+  return (
+    <div className="mt-4 pt-4 border-t border-stone-100">
+      <p className="text-[10px] font-bold uppercase tracking-widest text-stone-400 mb-3">
+        Attach photos, videos, or audio
+      </p>
+      <div className="flex gap-3 flex-wrap">
+        <button
+          onClick={() => { if (inputRef.current) { inputRef.current.accept = 'image/*'; inputRef.current.click(); }}}
+          className="flex items-center gap-2 px-4 py-2.5 rounded-2xl bg-stone-50 border border-stone-100 hover:bg-amber-50 hover:border-amber-200 transition-colors"
+        >
+          <span className="text-base">🖼</span>
+          <span className="text-[11px] font-bold uppercase tracking-widest text-stone-600">Photo</span>
+        </button>
+        <button
+          onClick={() => { if (inputRef.current) { inputRef.current.accept = 'video/*'; inputRef.current.click(); }}}
+          className="flex items-center gap-2 px-4 py-2.5 rounded-2xl bg-stone-50 border border-stone-100 hover:bg-amber-50 hover:border-amber-200 transition-colors"
+        >
+          <span className="text-base">🎬</span>
+          <span className="text-[11px] font-bold uppercase tracking-widest text-stone-600">Video</span>
+        </button>
+        <button
+          onClick={() => { if (inputRef.current) { inputRef.current.accept = 'audio/*'; inputRef.current.click(); }}}
+          className="flex items-center gap-2 px-4 py-2.5 rounded-2xl bg-stone-50 border border-stone-100 hover:bg-amber-50 hover:border-amber-200 transition-colors"
+        >
+          <span className="text-base">🎵</span>
+          <span className="text-[11px] font-bold uppercase tracking-widest text-stone-600">Audio</span>
+        </button>
+      </div>
+      <input
+        ref={inputRef}
+        type="file"
+        multiple
+        className="hidden"
+        onChange={e => { if (e.target.files?.length) { onFilesSelected(eventId, e.target.files); e.target.value = ''; }}}
+      />
+    </div>
+  );
+};;
+
+const ProfileView: React.FC<{
+  activeProfile: Profile;
+  profiles: Profile[];
+  familyTrees: FamilyTree[];
+  selectedTreeId: string | null;
+
+  // navigation
+  onBack: () => void;
+  onEdit: () => void;
+  onLinkRelative: (role: 'parent' | 'spouse' | 'child') => void;
+
+  // mutations
+  onDeleteProfile: () => void;
+  onSetActiveProfile: (id: string) => void;
+
+  // media upload
+  onUploadMediaClick: () => void;
+  onMediaFileChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
+  mediaInputRef: React.RefObject<HTMLInputElement>;
+  onEventMediaUpload: (eventId: string, files: FileList) => void;
+
+  // event attachment
+  attachingToEventId: string | null;
+  setAttachingToEventId: (id: string | null) => void;
+
+  // AI states + actions
+  isAiLoading: boolean;
+  isResearchLoading: boolean;
+  isPhotoLoading: boolean;
+  isGeneratingPortrait: boolean;
+
+  onGenerateSummary: () => void;
+  onResearch: () => void;
+  onGeneratePortrait: () => void;
+
+  // toast helper for inline triggers if needed
+  showToast: (m: string) => void;
+}> = (props) => {
+  const {
+    activeProfile, profiles,
+    onBack, onEdit, onLinkRelative,
+    onDeleteProfile, onSetActiveProfile,
+    onUploadMediaClick, onMediaFileChange, mediaInputRef,
+    attachingToEventId, setAttachingToEventId,
+    isAiLoading, isResearchLoading, isPhotoLoading, isGeneratingPortrait,
+    onGenerateSummary, onResearch, onGeneratePortrait
+  } = props;
+
+  const isPlaceholder = activeProfile.imageUrl.startsWith('data:image/svg+xml');
+  const rels: RelSet = {
+    parents: profiles.filter(p => activeProfile.parentIds.includes(p.id)),
+    spouses: profiles.filter(p => activeProfile.spouseIds.includes(p.id)),
+    children: profiles.filter(p => activeProfile.childIds.includes(p.id))
+  };
+
+  const timeline = [...(activeProfile.timeline || [])].sort((a, b) => {
+    const da = a.date || '';
+    const db = b.date || '';
+    return da.localeCompare(db);
+  });
+
+  // Flatten all media from timeline events for the gallery section
+  const media = timeline.flatMap(ev => ev.media || []) as MediaItem[];
+
+  return (
+    <div className="flex flex-col h-full bg-[#f9f8f6]">
+      <header className="pt-16 px-8 pb-4 bg-[#f5f2eb] flex justify-between items-center">
+        <button onClick={onBack} className="text-stone-400 flex items-center space-x-2">
+          <ChevronLeft size={18} />
+          <span className="text-[10px] font-bold uppercase tracking-widest">Archive</span>
+        </button>
+        <div className="flex items-center space-x-2">
+          <button onClick={onEdit} className="p-2 rounded-full bg-white border border-stone-200 text-stone-400">
+            <PenTool size={16} />
+          </button>
+          <button onClick={onDeleteProfile} className="p-2 rounded-full bg-white border border-stone-200 text-stone-400">
+            <Trash2 size={16} />
+          </button>
+        </div>
+      </header>
+
+      <main className="flex-1 overflow-y-auto px-8 pb-10">
+        <div className="pt-6 pb-8 flex items-start space-x-6">
+          <div className="relative">
+            <img src={activeProfile.imageUrl || getPlaceholderImage(activeProfile.id)} className="w-28 h-28 rounded-[34px] object-cover grayscale border border-stone-100 shadow-sm" />
+            <button
+              onClick={onUploadMediaClick}
+              className="absolute -bottom-2 -right-2 p-2 rounded-full bg-stone-900 text-white shadow"
+              aria-label="Add media"
+            >
+              <Camera size={16} />
+            </button>
+            <input ref={mediaInputRef} type="file" onChange={onMediaFileChange} accept="image/*,video/*" className="hidden" />
+          </div>
+
+          <div className="flex-1">
+            <h2 className="text-4xl font-serif text-slate-900 leading-tight">{activeProfile.name}</h2>
+            <div className="mt-2 text-[10px] font-black uppercase tracking-widest text-stone-400">
+              {activeProfile.birthYear} — {activeProfile.deathYear || '...'}
+            </div>
+            {activeProfile.summary && (
+              <p className="mt-4 text-sm text-stone-600 leading-relaxed">{activeProfile.summary}</p>
+            )}
+          </div>
+        </div>
+
+        <section className="space-y-3 mb-10">
+          <div className="flex items-center justify-between px-2">
+            <h3 className="text-[10px] font-bold uppercase tracking-widest text-stone-400">AI Studio</h3>
+          </div>
+
+          <div className="grid gap-3 md:grid-cols-3">
+            <button
+              onClick={onGenerateSummary}
+              disabled={isAiLoading}
+              className="bg-white p-4 rounded-[32px] border border-stone-50 shadow-sm text-left hover:shadow-md transition-all disabled:opacity-50"
+            >
+              <div className="flex items-center space-x-3">
+                <Sparkles className="text-amber-600" size={18} />
+                <div className="font-black uppercase text-[10px] tracking-widest text-stone-500">
+                  {isAiLoading ? 'Generating...' : 'Generate Summary'}
+                </div>
+              </div>
+              <div className="mt-2 text-sm text-stone-600">Short biography from the profile and timeline.</div>
+            </button>
+
+            <button
+              onClick={onResearch}
+              disabled={isResearchLoading}
+              className="bg-white p-4 rounded-[32px] border border-stone-50 shadow-sm text-left hover:shadow-md transition-all disabled:opacity-50"
+            >
+              <div className="flex items-center space-x-3">
+                <Library className="text-amber-600" size={18} />
+                <div className="font-black uppercase text-[10px] tracking-widest text-stone-500">
+                  {isResearchLoading ? 'Researching...' : 'Historical Context'}
+                </div>
+              </div>
+              <div className="mt-2 text-sm text-stone-600">Add period context based on time and places.</div>
+            </button>
+
+            <button
+              onClick={onGeneratePortrait}
+              disabled={isGeneratingPortrait || isPhotoLoading}
+              className="bg-white p-4 rounded-[32px] border border-stone-50 shadow-sm text-left hover:shadow-md transition-all disabled:opacity-50"
+            >
+              <div className="flex items-center space-x-3">
+                <ImageIcon className="text-amber-600" size={18} />
+                <div className="font-black uppercase text-[10px] tracking-widest text-stone-500">
+                  {(isGeneratingPortrait || isPhotoLoading) ? 'Generating...' : 'Portrait'}
+                </div>
+              </div>
+              <div className="mt-2 text-sm text-stone-600">Generate a respectful AI portrait concept.</div>
+            </button>
+          </div>
+        </section>
+
+        <section className="space-y-3 mb-10">
+          <div className="flex items-center justify-between px-2">
+            <h3 className="text-[10px] font-bold uppercase tracking-widest text-stone-400">Relationships</h3>
+            <div className="flex items-center space-x-2">
+              <button onClick={() => onLinkRelative('parent')} className="text-[10px] font-bold uppercase text-amber-700 flex items-center space-x-1">
+                <UserPlus size={14} /><span>Parent</span>
+              </button>
+              <button onClick={() => onLinkRelative('spouse')} className="text-[10px] font-bold uppercase text-amber-700 flex items-center space-x-1">
+                <UserPlus size={14} /><span>Spouse</span>
+              </button>
+              <button onClick={() => onLinkRelative('child')} className="text-[10px] font-bold uppercase text-amber-700 flex items-center space-x-1">
+                <UserPlus size={14} /><span>Child</span>
+              </button>
+            </div>
+          </div>
+
+          <div className="grid gap-3 md:grid-cols-3">
+            {[{ label: 'Parents', list: rels.parents }, { label: 'Spouses', list: rels.spouses }, { label: 'Children', list: rels.children }].map(group => (
+              <div key={group.label} className="bg-white p-5 rounded-[32px] border border-stone-50 shadow-sm">
+                <div className="text-[10px] font-black uppercase tracking-widest text-stone-400">{group.label}</div>
+                <div className="mt-3 space-y-2">
+                  {group.list.length === 0 ? (
+                    <div className="text-sm text-stone-400 italic">None listed</div>
+                  ) : group.list.map(p => (
+                    <button key={p.id} onClick={() => onSetActiveProfile(p.id)} className="w-full flex items-center space-x-3 p-2 rounded-2xl hover:bg-stone-50 transition-all">
+                      <img src={p.imageUrl} className="w-10 h-10 rounded-2xl object-cover grayscale" />
+                      <div className="text-left flex-1">
+                        <div className="font-serif text-lg">{p.name}</div>
+                        <div className="text-[10px] text-stone-400 font-black uppercase">{p.birthYear} — {p.deathYear || '...'}</div>
+                      </div>
+                      <ChevronRight className="text-stone-200" size={16} />
+                    </button>
+                  ))}
+                </div>
+              </div>
+            ))}
+          </div>
+        </section>
+
+        <section className="space-y-3 mb-10">
+          <div className="flex items-center justify-between px-2">
+            <h3 className="text-[10px] font-bold uppercase tracking-widest text-stone-400">Timeline</h3>
+            <span className="text-[10px] text-stone-300">{timeline.length} events</span>
+          </div>
+
+          <div className="space-y-3">
+            {timeline.length === 0 ? (
+              <div className="bg-white p-6 rounded-[32px] border border-stone-50 shadow-sm text-stone-400 italic">No life events yet.</div>
+            ) : timeline.map((ev, idx) => {
+              const Icon = getEventIcon(ev.type);
+              const isAttaching = attachingToEventId === ev.id;
+              return (
+                <div key={ev.id} className="bg-white rounded-[32px] border border-stone-50 shadow-sm overflow-hidden">
+                  {/* Year chip between events when year changes */}
+                  {idx === 0 || getEventYear(ev.date) !== getEventYear(timeline[idx - 1].date) ? (
+                    <div className="px-5 pt-4 pb-1">
+                      <span className="text-[10px] font-black uppercase tracking-widest text-amber-600">
+                        {getEventYear(ev.date)}
+                      </span>
+                    </div>
+                  ) : null}
+
+                  <div className="p-5">
+                    <div className="flex items-start space-x-4">
+                      <div className="w-10 h-10 rounded-2xl bg-stone-50 flex items-center justify-center flex-shrink-0">
+                        <Icon size={18} className="text-stone-400" />
+                      </div>
+                      <div className="flex-1 min-w-0">
+                        <div className="font-serif text-xl text-slate-900 leading-snug">
+                          {formatEventSentence(activeProfile.name, ev)}
+                        </div>
+                        <div className="mt-1 text-[10px] font-black uppercase tracking-widest text-stone-400">
+                          {ev.date ? formatFullDate(ev.date) : 'Date unknown'}
+                          {ev.place ? ` • ${ev.place}` : ''}
+                        </div>
+                        {(ev as any).note && (
+                          <div className="mt-2 text-sm text-stone-500 italic">{(ev as any).note}</div>
+                        )}
+                        {(ev as any).subType && (
+                          <div className="mt-1 text-[10px] uppercase tracking-widest text-stone-400">{(ev as any).subType}</div>
+                        )}
+
+                        {/* Attached media thumbnails */}
+                        {ev.media?.length > 0 && (
+                          <div className="mt-3 flex flex-wrap gap-2">
+                            {ev.media.map(m => (
+                              <a
+                                key={m.id}
+                                href={m.url}
+                                target="_blank"
+                                rel="noreferrer"
+                                className="inline-flex items-center space-x-1.5 px-3 py-1.5 rounded-full bg-stone-50 border border-stone-100 hover:bg-stone-100 transition-colors"
+                              >
+                                {m.kind === 'photo' && <span className="text-xs">🖼</span>}
+                                {m.kind === 'video' && <span className="text-xs">🎬</span>}
+                                {m.kind === 'audio' && <span className="text-xs">🎵</span>}
+                                {m.kind === 'document' && <span className="text-xs">📄</span>}
+                                <span className="text-[11px] font-bold text-stone-600 max-w-[120px] truncate">{m.name}</span>
+                              </a>
+                            ))}
+                          </div>
+                        )}
+                      </div>
+
+                      {/* Attach button */}
+                      <button
+                        onClick={() => setAttachingToEventId(isAttaching ? null : ev.id)}
+                        className={`flex-shrink-0 px-3 py-1.5 rounded-full text-[10px] font-bold uppercase transition-colors ${
+                          isAttaching
+                            ? 'bg-stone-900 text-white'
+                            : 'bg-stone-50 text-amber-700 border border-stone-100 hover:bg-amber-50'
+                        }`}
+                      >
+                        {isAttaching ? 'Cancel' : '+ Media'}
+                      </button>
+                    </div>
+
+                    {/* Expanded attach panel */}
+                    {isAttaching && (
+                      <EventMediaUploader
+                        eventId={ev.id}
+                        onFilesSelected={props.onEventMediaUpload}
+                      />
+                    )}
+                  </div>
+                </div>
+              );
+            })}
+          </div>
+        </section>
+
+        <section className="space-y-3 mb-10">
+          <div className="flex items-center justify-between px-2">
+            <h3 className="text-[10px] font-bold uppercase tracking-widest text-stone-400">Media</h3>
+          </div>
+
+          {media.length === 0 ? (
+            <div className="bg-white p-6 rounded-[32px] border border-stone-50 shadow-sm text-stone-400 italic">No media yet.</div>
+          ) : (
+            <div className="grid gap-3 md:grid-cols-3">
+              {media.map(m => (
+                <a key={m.id} href={m.url} target="_blank" rel="noreferrer" className="bg-white p-4 rounded-[32px] border border-stone-50 shadow-sm hover:shadow-md transition-all">
+                  <div className="text-[10px] font-black uppercase tracking-widest text-stone-400">{m.kind}</div>
+                  <div className="mt-2 font-serif text-xl text-slate-900">{m.name || 'Untitled'}</div>
+                </a>
+              ))}
+            </div>
+          )}
+        </section>
+      </main>
+    </div>
+  );
+};
+
+export default ProfileView;
diff -ruN before/src/views/SelectHomeView.tsx after/src/views/SelectHomeView.tsx
--- before/src/views/SelectHomeView.tsx	1970-01-01 00:00:00.000000000 +0000
+++ after/src/views/SelectHomeView.tsx	2026-02-21 02:04:36.003189601 +0000
@@ -0,0 +1,93 @@
+import React, { useMemo, useState } from 'react';
+import { ChevronLeft, Search, Check } from 'lucide-react';
+import { Profile } from '../types';
+
+type PendingImport = { importedProfiles: Profile[]; tree: any } | null;
+
+const SelectHomeView: React.FC<{
+  pendingImport: PendingImport;
+  onBack: () => void;
+  onChooseHome: (p: Profile) => void;
+}> = ({ pendingImport, onBack, onChooseHome }) => {
+  const [q, setQ] = useState('');
+
+  const candidates = useMemo(() => {
+    const list = pendingImport?.importedProfiles || [];
+    const query = q.trim().toLowerCase();
+    if (!query) return list.slice(0, 80);
+    return list
+      .filter(p => (p.name || '').toLowerCase().includes(query))
+      .slice(0, 80);
+  }, [pendingImport, q]);
+
+  if (!pendingImport) {
+    return (
+      <div className="flex flex-col h-full bg-[#f9f8f6]">
+        <header className="pt-16 px-8 pb-6 bg-[#f5f2eb] border-b border-stone-200">
+          <button onClick={onBack} className="flex items-center space-x-2 text-stone-500">
+            <ChevronLeft size={18} />
+            <span className="text-[11px] font-bold uppercase tracking-widest">Back</span>
+          </button>
+        </header>
+        <main className="p-8">
+          <p className="font-serif text-stone-600 italic">No import is pending.</p>
+        </main>
+      </div>
+    );
+  }
+
+  return (
+    <div className="flex flex-col h-full bg-[#f9f8f6]">
+      <header className="pt-16 px-8 pb-6 bg-[#f5f2eb] border-b border-stone-200">
+        <div className="flex items-center justify-between">
+          <button onClick={onBack} className="flex items-center space-x-2 text-stone-500">
+            <ChevronLeft size={18} />
+            <span className="text-[11px] font-bold uppercase tracking-widest">Back</span>
+          </button>
+          <div className="text-right">
+            <h2 className="text-2xl font-serif text-slate-800">Select Home Person</h2>
+            <p className="text-stone-400 text-[10px] font-bold uppercase">
+              {pendingImport.importedProfiles.length} imported profiles
+            </p>
+          </div>
+        </div>
+
+        <div className="mt-6 flex items-center space-x-3 bg-white rounded-full border border-stone-200 px-4 py-3">
+          <Search size={18} className="text-stone-300" />
+          <input
+            value={q}
+            onChange={(e) => setQ(e.target.value)}
+            placeholder="Search imported people"
+            className="flex-1 bg-transparent outline-none text-sm text-slate-900 placeholder:text-stone-400"
+          />
+        </div>
+      </header>
+
+      <main className="flex-1 p-8 overflow-y-auto">
+        <div className="grid gap-3">
+          {candidates.map(p => (
+            <button
+              key={p.id}
+              onClick={() => onChooseHome(p)}
+              className="w-full bg-white p-4 rounded-[32px] shadow-sm border border-stone-50 flex items-center space-x-4 hover:shadow-md transition-all"
+            >
+              <img src={p.imageUrl} className="w-14 h-14 rounded-2xl object-cover grayscale" />
+              <div className="text-left flex-1">
+                <h4 className="font-serif text-xl">{p.name}</h4>
+                <p className="text-[10px] text-stone-400 font-black uppercase mt-1">
+                  {p.birthYear} — {p.deathYear || '...'}
+                </p>
+              </div>
+              <div className="flex items-center space-x-2 text-amber-700">
+                <Check size={18} />
+                <span className="text-[10px] font-bold uppercase">Make home</span>
+              </div>
+            </button>
+          ))}
+        </div>
+      </main>
+    </div>
+  );
+};
+
+export default SelectHomeView;
diff -ruN before/src/views/SplashView.tsx after/src/views/SplashView.tsx
--- before/src/views/SplashView.tsx	1970-01-01 00:00:00.000000000 +0000
+++ after/src/views/SplashView.tsx	2026-02-21 02:04:36.013189601 +0000
@@ -0,0 +1,14 @@
+import React from 'react';
+
+const SplashView: React.FC = () => {
+  return (
+    <div className="flex flex-col items-center justify-center h-full bg-[#dccdb9] text-[#1c1917]">
+      <div className="animate-fade-in-up text-center space-y-4">
+        <h1 className="text-6xl font-serif">Eternal</h1>
+        <p className="text-xs tracking-widest uppercase opacity-60">Ancestry Preservation</p>
+      </div>
+    </div>
+  );
+};
+
+export default SplashView;
diff -ruN before/src/views/TreeView.tsx after/src/views/TreeView.tsx
--- before/src/views/TreeView.tsx	1970-01-01 00:00:00.000000000 +0000
+++ after/src/views/TreeView.tsx	2026-02-21 02:04:36.025189601 +0000
@@ -0,0 +1,72 @@
+import React, { useMemo } from 'react';
+import { ChevronLeft, ChevronRight, Home } from 'lucide-react';
+import { FamilyTree, Profile } from '../types';
+
+const TreeView: React.FC<{
+  tree: FamilyTree;
+  profiles: Profile[];
+  onBack: () => void;
+  onOpenProfile: (id: string) => void;
+}> = ({ tree, profiles, onBack, onOpenProfile }) => {
+  const members = useMemo(() => {
+    const map = new Map(profiles.map(p => [p.id, p]));
+    return tree.memberIds.map(id => map.get(id)).filter(Boolean) as Profile[];
+  }, [tree, profiles]);
+
+  const home = profiles.find(p => p.id === tree.homePersonId) || null;
+
+  return (
+    <div className="flex flex-col h-full bg-[#f9f8f6]">
+      <header className="pt-16 px-8 pb-6 bg-[#f5f2eb] border-b border-stone-200">
+        <div className="flex items-center justify-between">
+          <button onClick={onBack} className="flex items-center space-x-2 text-stone-500">
+            <ChevronLeft size={18} />
+            <span className="text-[11px] font-bold uppercase tracking-widest">Back</span>
+          </button>
+          <div className="text-right">
+            <h2 className="text-2xl font-serif text-slate-800">{tree.name}</h2>
+            <p className="text-stone-400 text-[10px] font-bold uppercase">{tree.memberIds.length} members</p>
+          </div>
+        </div>
+      </header>
+
+      <main className="flex-1 p-8 overflow-y-auto space-y-6">
+        {home && (
+          <div className="bg-white p-5 rounded-[32px] border border-stone-50 shadow-sm flex items-center space-x-4">
+            <Home className="text-amber-700" size={18} />
+            <img src={home.imageUrl} className="w-12 h-12 rounded-2xl object-cover grayscale" />
+            <div className="flex-1 text-left">
+              <div className="text-[10px] font-black uppercase text-stone-400">Home person</div>
+              <div className="font-serif text-xl">{home.name}</div>
+            </div>
+            <button onClick={() => onOpenProfile(home.id)} className="p-2 rounded-full hover:bg-stone-50">
+              <ChevronRight className="text-stone-300" size={18} />
+            </button>
+          </div>
+        )}
+
+        <section className="space-y-3">
+          <div className="text-[10px] font-bold uppercase tracking-widest text-stone-400">Members</div>
+          <div className="grid gap-3">
+            {members.map(p => (
+              <button
+                key={p.id}
+                onClick={() => onOpenProfile(p.id)}
+                className="w-full bg-white p-4 rounded-[32px] shadow-sm border border-stone-50 flex items-center space-x-4 hover:shadow-md transition-all"
+              >
+                <img src={p.imageUrl} className="w-14 h-14 rounded-2xl object-cover grayscale" />
+                <div className="text-left flex-1">
+                  <h4 className="font-serif text-xl">{p.name}</h4>
+                  <p className="text-[10px] text-stone-400 font-black uppercase mt-1">{p.birthYear} — {p.deathYear || '...'}</p>
+                </div>
+                <ChevronRight className="text-stone-200" size={18} />
+              </button>
+            ))}
+          </div>
+        </section>
+      </main>
+    </div>
+  );
+};
+
+export default TreeView;
diff -ruN before/src/views/TreesView.tsx after/src/views/TreesView.tsx
--- before/src/views/TreesView.tsx	1970-01-01 00:00:00.000000000 +0000
+++ after/src/views/TreesView.tsx	2026-02-21 02:04:36.036189601 +0000
@@ -0,0 +1,58 @@
+import React from 'react';
+import { ChevronLeft, ChevronRight, GitBranch } from 'lucide-react';
+import { FamilyTree } from '../types';
+
+const TreesView: React.FC<{
+  trees: FamilyTree[];
+  selectedTreeId: string | null;
+  onBack: () => void;
+  onSelectTree: (id: string) => void;
+  onOpenTree: (id: string) => void;
+}> = ({ trees, selectedTreeId, onBack, onSelectTree, onOpenTree }) => {
+  return (
+    <div className="flex flex-col h-full bg-[#f9f8f6]">
+      <header className="pt-16 px-8 pb-6 bg-[#f5f2eb] border-b border-stone-200">
+        <div className="flex items-center justify-between">
+          <button onClick={onBack} className="flex items-center space-x-2 text-stone-500">
+            <ChevronLeft size={18} />
+            <span className="text-[11px] font-bold uppercase tracking-widest">Back</span>
+          </button>
+          <div className="text-right">
+            <h2 className="text-2xl font-serif text-slate-800">Trees</h2>
+            <p className="text-stone-400 text-[10px] font-bold uppercase">{trees.length} total</p>
+          </div>
+        </div>
+      </header>
+
+      <main className="flex-1 p-8 overflow-y-auto">
+        {trees.length === 0 ? (
+          <div className="text-center space-y-6 mt-10">
+            <GitBranch size={48} className="mx-auto text-stone-200" />
+            <p className="font-serif text-stone-500 italic">No trees yet.</p>
+          </div>
+        ) : (
+          <div className="grid gap-3">
+            {trees.map(t => (
+              <div key={t.id} className="w-full bg-white p-4 rounded-[32px] shadow-sm border border-stone-50 flex items-center space-x-4">
+                <button
+                  onClick={() => onSelectTree(t.id)}
+                  className={`w-5 h-5 rounded-full border ${selectedTreeId === t.id ? 'bg-stone-900 border-stone-900' : 'border-stone-300'}`}
+                  aria-label="Select tree"
+                />
+                <div className="text-left flex-1">
+                  <h4 className="font-serif text-xl">{t.name}</h4>
+                  <p className="text-[10px] text-stone-400 font-black uppercase mt-1">{t.memberIds.length} members</p>
+                </div>
+                <button onClick={() => onOpenTree(t.id)} className="p-2 rounded-full hover:bg-stone-50">
+                  <ChevronRight className="text-stone-300" size={18} />
+                </button>
+              </div>
+            ))}
+          </div>
+        )}
+      </main>
+    </div>
+  );
+};
+
+export default TreesView;
diff -ruN before/supabaseClient.ts after/supabaseClient.ts
--- before/supabaseClient.ts	2026-02-21 02:03:34.190190063 +0000
+++ after/supabaseClient.ts	1970-01-01 00:00:00.000000000 +0000
@@ -1,20 +0,0 @@
-import { createClient } from '@supabase/supabase-js';
-import type { Database } from './database.types';
-
-const supabaseUrl = import.meta.env.VITE_SUPABASE_URL as string | undefined;
-const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY as string | undefined;
-
-if (!supabaseUrl || supabaseUrl.trim() === '') {
-  throw new Error(
-    '[supabaseClient] Missing env var: VITE_SUPABASE_URL\n' +
-    'Add it to .env.local or your Vercel project settings.'
-  );
-}
-if (!supabaseAnonKey || supabaseAnonKey.trim() === '') {
-  throw new Error(
-    '[supabaseClient] Missing env var: VITE_SUPABASE_ANON_KEY\n' +
-    'Add it to .env.local or your Vercel project settings.'
-  );
-}
-
-export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey);
diff -ruN before/treeRepo.ts after/treeRepo.ts
--- before/treeRepo.ts	2026-02-21 02:03:34.219190063 +0000
+++ after/treeRepo.ts	1970-01-01 00:00:00.000000000 +0000
@@ -1,56 +0,0 @@
-// ---------------------------------------------------------------------------
-// repos/treeRepo.ts
-// All queries rely on RLS for user scoping; auth.uid() is evaluated
-// server-side so no user_id filter is needed client-side. We still pass
-// user_id explicitly on INSERT because RLS WITH CHECK requires it to match
-// auth.uid() and the client sets it directly.
-// ---------------------------------------------------------------------------
-
-import { supabase } from '../lib/supabaseClient';
-import { rowToTree, treeToInsert } from '../lib/mappers';
-import type { FamilyTree } from '../types';
-
-/**
- * Persist a new tree. Typically called once per GEDCOM import.
- * Throws on Supabase error so the caller can surface it via toast.
- */
-export async function createTree(tree: FamilyTree): Promise<FamilyTree> {
-  const { data, error } = await supabase
-    .from('trees')
-    .insert(treeToInsert(tree))
-    .select()
-    .single();
-
-  if (error) throw new Error(`createTree: ${error.message}`);
-  return rowToTree(data);
-}
-
-/**
- * Return all trees belonging to the authenticated user.
- * RLS ensures only the current user's rows are returned.
- */
-export async function listTrees(): Promise<FamilyTree[]> {
-  const { data, error } = await supabase
-    .from('trees')
-    .select('*')
-    .order('created_at', { ascending: false });
-
-  if (error) throw new Error(`listTrees: ${error.message}`);
-  return (data ?? []).map(rowToTree);
-}
-
-/**
- * Update the home_person_id and member_ids after the user picks a home person.
- */
-export async function updateTree(
-  id: string,
-  patch: { homePersonId?: string; memberIds?: string[]; name?: string }
-): Promise<void> {
-  const update: Record<string, unknown> = {};
-  if (patch.homePersonId !== undefined) update.home_person_id = patch.homePersonId;
-  if (patch.memberIds !== undefined)    update.member_ids = patch.memberIds;
-  if (patch.name !== undefined)         update.name = patch.name;
-
-  const { error } = await supabase.from('trees').update(update).eq('id', id);
-  if (error) throw new Error(`updateTree: ${error.message}`);
-}
diff -ruN before/tsconfig.json after/tsconfig.json
--- before/tsconfig.json	2026-02-21 02:03:34.232190062 +0000
+++ after/tsconfig.json	2026-02-21 02:07:19.499188381 +0000
@@ -4,15 +4,9 @@
     "experimentalDecorators": true,
     "useDefineForClassFields": false,
     "module": "ESNext",
-    "lib": [
-      "ES2022",
-      "DOM",
-      "DOM.Iterable"
-    ],
+    "lib": ["ES2022", "DOM", "DOM.Iterable"],
     "skipLibCheck": true,
-    "types": [
-      "node"
-    ],
+    "types": ["node"],
     "moduleResolution": "bundler",
     "isolatedModules": true,
     "moduleDetection": "force",
@@ -20,9 +14,7 @@
     "jsx": "react-jsx",
     "baseUrl": ".",
     "paths": {
-      "@/*": [
-        "src/*"
-      ]
+      "@/*": ["src/*"]
     },
     "allowImportingTsExtensions": true,
     "noEmit": true
diff -ruN before/types.ts after/types.ts
--- before/types.ts	2026-02-21 02:03:34.246190062 +0000
+++ after/types.ts	1970-01-01 00:00:00.000000000 +0000
@@ -1,101 +0,0 @@
-
-export interface User {
-  id: string;
-  email: string;
-  name: string;
-  createdAt: string;
-}
-
-export type MediaKind = 'photo' | 'video' | 'audio' | 'document';
-
-export interface MediaItem {
-  id: string;
-  name: string;
-  kind: MediaKind;
-  url: string;
-  mime?: string;
-  size?: number;
-  createdAt: string;
-}
-
-export interface LifeEvent {
-  id: string;
-  type: string;
-  date: string;
-  place: string;
-  spouseName?: string;
-  media: MediaItem[];
-}
-
-export interface Memory {
-  id: string;
-  type: 'story' | 'note';
-  content: string;
-  timestamp: string;
-}
-
-export interface Profile {
-  id: string;
-  userId: string;
-  name: string;
-  gender?: 'M' | 'F' | 'U';
-  birthYear: string;
-  deathYear?: string;
-  imageUrl: string;
-  summary: string;
-  historicalContext?: {
-    text: string;
-    sources: any[];
-  };
-  timeline: LifeEvent[];
-  memories: Memory[];
-  sources: string[];
-  isMemorial?: boolean;
-  // Relationships
-  parentIds: string[];
-  childIds: string[];
-  spouseIds: string[];
-}
-
-export interface FamilyTree {
-  id: string;
-  userId: string;
-  name: string;
-  createdAt: string;
-  homePersonId: string;
-  memberIds: string[];
-}
-
-export type AttachmentKind = 'photo' | 'video' | 'audio' | 'document';
-
-export interface CircleAttachment {
-  id: string;
-  kind: AttachmentKind;
-  name: string;
-  dataUrl: string;
-  size?: number;
-}
-
-export interface CirclePost {
-  id: string;
-  userId: string;
-  createdAt: string;
-  authorLabel: string;
-  body: string;
-  attachments: CircleAttachment[];
-  taggedProfileIds: string[];
-}
-
-export enum AppView {
-  SPLASH = 'splash',
-  LOGIN = 'login',
-  HOME = 'home',
-  TREES = 'trees',
-  TREE_VIEW = 'tree_view',
-  SELECT_HOME = 'select_home',
-  PROFILE = 'profile',
-  EDIT_PROFILE = 'edit_profile',
-  LINK_RELATIVE = 'link_relative',
-  CREATE_MEMORY = 'create_memory',
-  FAMILY_CIRCLE = 'family_circle'
-}
diff -ruN before/useArchiveStore.ts after/useArchiveStore.ts
--- before/useArchiveStore.ts	2026-02-21 02:03:34.261190062 +0000
+++ after/useArchiveStore.ts	1970-01-01 00:00:00.000000000 +0000
@@ -1,259 +0,0 @@
-// ---------------------------------------------------------------------------
-// hooks/useArchiveStore.ts  (Supabase-backed, localStorage removed)
-//
-// Public API is intentionally identical to the old hook so no component or
-// sub-hook (useGedcomImport, useProfileEditor, useMediaAttach) needs to change.
-//
-// Key design decisions
-// ─────────────────────
-// 1. State is still held in React useState — Supabase is the source of truth
-//    but we keep a local in-memory cache so the UI stays synchronous.
-//
-// 2. setProfiles / setFamilyTrees are *augmented* dispatchers: when called
-//    with a new value they (a) update React state immediately for instant UI
-//    feedback, and (b) fire-and-forget persist the diff to Supabase.
-//
-// 3. addCirclePost / deleteCirclePost follow the same optimistic pattern.
-//
-// 4. All repo errors are caught and logged; a stored `error` field lets
-//    consumers surface them if they choose.
-// ---------------------------------------------------------------------------
-
-import {
-  useCallback,
-  useEffect,
-  useMemo,
-  useRef,
-  useState,
-} from 'react';
-import type { Dispatch, SetStateAction } from 'react';
-
-import type { CirclePost, FamilyTree, Profile, User } from '../types';
-import { listTrees, createTree, updateTree } from '../repos/treeRepo';
-import {
-  listProfiles,
-  upsertProfiles,
-  deleteProfile as deleteProfileRepo,
-} from '../repos/profileRepo';
-import {
-  listPosts,
-  createPost,
-  deletePost as deletePostRepo,
-} from '../repos/postRepo';
-
-// ── Types ────────────────────────────────────────────────────────────────────
-
-type SetState<T> = Dispatch<SetStateAction<T>>;
-
-// ── Hook ─────────────────────────────────────────────────────────────────────
-
-export const useArchiveStore = (user: User | null) => {
-  // ── Local state (in-memory cache of Supabase data) ─────────────────────────
-  const [profiles, setProfilesRaw]       = useState<Profile[]>([]);
-  const [familyTrees, setFamilyTreesRaw] = useState<FamilyTree[]>([]);
-  const [circlePosts, setCirclePostsRaw] = useState<CirclePost[]>([]);
-
-  const [activeProfileId,  setActiveProfileId]  = useState<string | null>(null);
-  const [selectedTreeId,   setSelectedTreeId]   = useState<string | null>(null);
-  const [treeViewId,       setTreeViewId]       = useState<string | null>(null);
-
-  const [isLoading, setIsLoading] = useState(false);
-  const [error, setError]         = useState<string | null>(null);
-
-  // ── Initial data load ───────────────────────────────────────────────────────
-  useEffect(() => {
-    if (!user) {
-      setProfilesRaw([]);
-      setFamilyTreesRaw([]);
-      setCirclePostsRaw([]);
-      setActiveProfileId(null);
-      setSelectedTreeId(null);
-      setTreeViewId(null);
-      return;
-    }
-
-    let cancelled = false;
-    setIsLoading(true);
-    setError(null);
-
-    Promise.all([listTrees(), listProfiles(), listPosts()])
-      .then(([trees, profs, posts]) => {
-        if (cancelled) return;
-        setFamilyTreesRaw(trees);
-        setProfilesRaw(profs);
-        setCirclePostsRaw(posts);
-      })
-      .catch((err: unknown) => {
-        if (cancelled) return;
-        const msg = err instanceof Error ? err.message : String(err);
-        console.error('[useArchiveStore] initial load failed:', msg);
-        setError(msg);
-      })
-      .finally(() => { if (!cancelled) setIsLoading(false); });
-
-    return () => { cancelled = true; };
-  }, [user]);
-
-  // ── Augmented setProfiles ───────────────────────────────────────────────────
-  // Matches the React Dispatch<SetStateAction<Profile[]>> signature exactly
-  // so useProfileEditor, useGedcomImport, useMediaAttach work unchanged.
-  // After each state update we diff against the previous array and upsert
-  // any new or modified profiles to Supabase (fire-and-forget).
-  const prevProfilesRef = useRef<Profile[]>([]);
-
-  const setProfiles: SetState<Profile[]> = useCallback(
-    (valueOrUpdater) => {
-      setProfilesRaw((prev) => {
-        const next =
-          typeof valueOrUpdater === 'function'
-            ? (valueOrUpdater as (p: Profile[]) => Profile[])(prev)
-            : valueOrUpdater;
-
-        const prevById = new Map(prev.map((p) => [p.id, p]));
-        const toUpsert = next.filter((p) => {
-          const old = prevById.get(p.id);
-          return !old || JSON.stringify(old) !== JSON.stringify(p);
-        });
-
-        if (toUpsert.length > 0) {
-          upsertProfiles(toUpsert).catch((err: unknown) => {
-            console.error('[useArchiveStore] upsertProfiles failed:', err);
-          });
-        }
-
-        prevProfilesRef.current = next;
-        return next;
-      });
-    },
-    []
-  );
-
-  // ── Augmented setFamilyTrees ────────────────────────────────────────────────
-  // New trees are created in Supabase; updates to existing trees (e.g.
-  // homePersonId set by chooseHome) are sent via updateTree.
-  const setFamilyTrees: SetState<FamilyTree[]> = useCallback(
-    (valueOrUpdater) => {
-      setFamilyTreesRaw((prev) => {
-        const next =
-          typeof valueOrUpdater === 'function'
-            ? (valueOrUpdater as (t: FamilyTree[]) => FamilyTree[])(prev)
-            : valueOrUpdater;
-
-        const prevIds = new Set(prev.map((t) => t.id));
-
-        next.forEach((tree) => {
-          if (!prevIds.has(tree.id)) {
-            // Brand new tree.
-            createTree(tree).catch((err: unknown) => {
-              console.error('[useArchiveStore] createTree failed:', err);
-            });
-          } else {
-            const old = prev.find((t) => t.id === tree.id);
-            if (old && JSON.stringify(old) !== JSON.stringify(tree)) {
-              updateTree(tree.id, {
-                homePersonId: tree.homePersonId,
-                memberIds: tree.memberIds,
-                name: tree.name,
-              }).catch((err: unknown) => {
-                console.error('[useArchiveStore] updateTree failed:', err);
-              });
-            }
-          }
-        });
-
-        return next;
-      });
-    },
-    []
-  );
-
-  // ── Circle posts ────────────────────────────────────────────────────────────
-
-  const addCirclePost = useCallback((post: CirclePost) => {
-    // Optimistic update — roll back on failure.
-    setCirclePostsRaw((prev) => [post, ...prev]);
-    createPost(post).catch((err: unknown) => {
-      console.error('[useArchiveStore] createPost failed:', err);
-      setCirclePostsRaw((prev) => prev.filter((p) => p.id !== post.id));
-    });
-  }, []);
-
-  const deleteCirclePost = useCallback((id: string) => {
-    setCirclePostsRaw((prev) => prev.filter((p) => p.id !== id));
-    deletePostRepo(id).catch((err: unknown) => {
-      console.error('[useArchiveStore] deletePost failed:', err);
-    });
-  }, []);
-
-  const updateCirclePost = useCallback((id: string, patch: Partial<CirclePost>) => {
-    // Posts are not edited in the current UI; kept for API compatibility.
-    setCirclePostsRaw((prev) =>
-      prev.map((p) => (p.id === id ? { ...p, ...patch } : p))
-    );
-  }, []);
-
-  // ── Derived state ────────────────────────────────────────────────────────────
-
-  const activeProfile = useMemo(
-    () => profiles.find((p) => p.id === activeProfileId) ?? null,
-    [profiles, activeProfileId]
-  );
-
-  const selectedTree = useMemo(
-    () => familyTrees.find((t) => t.id === selectedTreeId) ?? null,
-    [familyTrees, selectedTreeId]
-  );
-
-  const selectedTreeForView = useMemo(
-    () => familyTrees.find((t) => t.id === treeViewId) ?? null,
-    [familyTrees, treeViewId]
-  );
-
-  // ── clearAll ────────────────────────────────────────────────────────────────
-  // Clears local cache only — Supabase data is preserved for next login.
-  const clearAll = useCallback(() => {
-    setProfilesRaw([]);
-    setFamilyTreesRaw([]);
-    setCirclePostsRaw([]);
-    setActiveProfileId(null);
-    setSelectedTreeId(null);
-    setTreeViewId(null);
-    prevProfilesRef.current = [];
-  }, []);
-
-  // ── deleteProfileById ───────────────────────────────────────────────────────
-  // useProfileEditor calls setProfiles(prev => prev.filter(…)) for the
-  // optimistic state update. Call this alongside it to persist the deletion.
-  const deleteProfileById = useCallback((profileId: string) => {
-    deleteProfileRepo(profileId).catch((err: unknown) => {
-      console.error('[useArchiveStore] deleteProfile failed:', err);
-    });
-  }, []);
-
-  // ── Return (identical surface to old hook + optional extras) ─────────────────
-  return {
-    profiles,      setProfiles,
-    familyTrees,   setFamilyTrees,
-    circlePosts,
-
-    activeProfileId,  setActiveProfileId,
-    selectedTreeId,   setSelectedTreeId,
-    treeViewId,       setTreeViewId,
-
-    activeProfile,
-    selectedTree,
-    selectedTreeForView,
-
-    addCirclePost,
-    deleteCirclePost,
-    updateCirclePost,
-    clearAll,
-
-    // New — call alongside setProfiles(prev => prev.filter(…)) when deleting.
-    deleteProfileById,
-
-    // New — optional loading/error state for UI feedback.
-    isLoading,
-    error,
-  };
-};
diff -ruN before/useGedcomImport.ts after/useGedcomImport.ts
--- before/useGedcomImport.ts	2026-02-21 02:03:34.275190062 +0000
+++ after/useGedcomImport.ts	1970-01-01 00:00:00.000000000 +0000
@@ -1,97 +0,0 @@
-import { useRef, useState } from 'react';
-import { AppView, FamilyTree, Profile, User } from '../types';
-import { parseGedcom } from '../utils/gedcom';
-import { assertAuthenticated, AuthenticationError } from '../utils/assertAuthenticated';
-
-export const useGedcomImport = (args: {
-  user: User | null;
-  setView: (v: AppView) => void;
-  setProfiles: React.Dispatch<React.SetStateAction<Profile[]>>;
-  setFamilyTrees: React.Dispatch<React.SetStateAction<FamilyTree[]>>;
-  setSelectedTreeId: (id: string | null) => void;
-  setActiveProfileId: (id: string | null) => void;
-  toast: (m: string) => void;
-}) => {
-  const { user, setView, setProfiles, setFamilyTrees, setSelectedTreeId, setActiveProfileId, toast } = args;
-
-  const gedFileInputRef = useRef<HTMLInputElement>(null);
-  const [pendingImport, setPendingImport] = useState<{ importedProfiles: Profile[]; tree: FamilyTree } | null>(null);
-
-  const handleGedcomUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
-    // ── Auth guard ────────────────────────────────────────────────────────────
-    // This is a hard gate, not just a UI hide. Even if someone triggers the
-    // file input programmatically (e.g. via browser DevTools or a script),
-    // no file data will be read and no state will change without a session.
-    try {
-      assertAuthenticated(user, 'GEDCOM upload');
-    } catch (err) {
-      e.target.value = '';
-      if (err instanceof AuthenticationError) {
-        toast('Please sign in to import a family archive.');
-      }
-      return;
-    }
-
-    const f = e.target.files?.[0];
-    if (!f) {
-      e.target.value = '';
-      return;
-    }
-
-    const reader = new FileReader();
-    reader.onload = (event) => {
-      const text = event.target?.result;
-      if (typeof text === 'string') {
-        try {
-          // user is guaranteed non-null here because assertAuthenticated passed.
-          const result = parseGedcom(text, user.id, 4);
-          setPendingImport(result);
-          setView(AppView.SELECT_HOME);
-          toast(`Loaded ${result.importedProfiles.length} family members`);
-        } catch (err) {
-          console.error(err);
-          toast('Error parsing GEDCOM');
-        }
-      }
-    };
-    reader.readAsText(f);
-    e.target.value = '';
-  };
-
-  const chooseHome = (selected: Profile) => {
-    // ── Auth guard ────────────────────────────────────────────────────────────
-    // chooseHome is the second step of the import flow. Guard it independently
-    // so that even a stale pending import cannot be committed without a session.
-    try {
-      assertAuthenticated(user, 'GEDCOM home selection');
-    } catch (err) {
-      if (err instanceof AuthenticationError) {
-        toast('Please sign in to complete the import.');
-      }
-      return;
-    }
-
-    if (!pendingImport) return;
-
-    setProfiles((prev) => {
-      const existingIds = new Set(prev.map((p) => p.id));
-      const newProfiles = pendingImport.importedProfiles.filter((p) => !existingIds.has(p.id));
-      return [...prev, ...newProfiles];
-    });
-
-    const updatedTree: FamilyTree = {
-      ...pendingImport.tree,
-      homePersonId: selected.id,
-      name: `The ${selected.name} Archive`
-    };
-
-    setFamilyTrees((prev) => [updatedTree, ...prev]);
-    setSelectedTreeId(updatedTree.id);
-    setActiveProfileId(selected.id);
-    setPendingImport(null);
-    setView(AppView.HOME);
-    toast('Archive successfully imported');
-  };
-
-  return { gedFileInputRef, pendingImport, setPendingImport, handleGedcomUpload, chooseHome };
-};
diff -ruN before/useMediaAttach.ts after/useMediaAttach.ts
--- before/useMediaAttach.ts	2026-02-21 02:03:34.290190062 +0000
+++ after/useMediaAttach.ts	1970-01-01 00:00:00.000000000 +0000
@@ -1,189 +0,0 @@
-// hooks/useMediaAttach.ts
-//
-// Handles profile photo uploads and event media attachments.
-// Every handler calls assertAuthenticated before touching any state, so
-// a user without a Supabase session cannot attach files even if a file
-// input is triggered programmatically.
-
-import { useState } from 'react';
-import { AppView, MediaItem, Profile } from '../types';
-import type { User } from '../types';
-import { compressImage } from '../utils/media';
-import { inferMediaKind } from '../utils/formatters';
-import { assertAuthenticated, AuthenticationError } from '../utils/assertAuthenticated';
-
-export const useMediaAttach = (args: {
-  user: User | null;
-  activeProfileId: string | null;
-  view: AppView;
-  attachingToEventId: string | null;
-  setAttachingToEventId: (id: string | null) => void;
-  setProfiles: React.Dispatch<React.SetStateAction<Profile[]>>;
-  setEditImageUrl: (v: string) => void;
-  toast: (m: string) => void;
-}) => {
-  const {
-    user,
-    activeProfileId,
-    view,
-    attachingToEventId,
-    setAttachingToEventId,
-    setProfiles,
-    setEditImageUrl,
-    toast,
-  } = args;
-
-  const [isPhotoLoading, setIsPhotoLoading] = useState(false);
-
-  // ── handleProfilePhotoUpload ─────────────────────────────────────────────────
-
-  const handleProfilePhotoUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
-    try {
-      assertAuthenticated(user, 'profile photo upload');
-    } catch (err) {
-      e.target.value = '';
-      if (err instanceof AuthenticationError) {
-        toast('Please sign in to upload photos.');
-      }
-      return;
-    }
-
-    const file = e.target.files?.[0];
-    if (!file || !activeProfileId) { e.target.value = ''; return; }
-
-    setIsPhotoLoading(true);
-    try {
-      const base64 = await compressImage(file);
-      if (view === AppView.EDIT_PROFILE) setEditImageUrl(base64);
-      else setProfiles((prev) => prev.map((p) => (p.id === activeProfileId ? { ...p, imageUrl: base64 } : p)));
-      toast('Photo updated');
-    } catch (err) {
-      console.error(err);
-      toast('Error processing photo');
-    } finally {
-      setIsPhotoLoading(false);
-      e.target.value = '';
-    }
-  };
-
-  // ── handleLifecycleFileUpload ────────────────────────────────────────────────
-
-  const handleLifecycleFileUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
-    try {
-      assertAuthenticated(user, 'event media upload');
-    } catch (err) {
-      e.target.value = '';
-      if (err instanceof AuthenticationError) {
-        toast('Please sign in to attach media.');
-      }
-      return;
-    }
-
-    const files = e.target.files;
-    if (!files || files.length === 0 || !activeProfileId || !attachingToEventId) { e.target.value = ''; return; }
-
-    toast('Processing...');
-    try {
-      const newMediaItems: MediaItem[] = await Promise.all(
-        Array.from(files).map(async (file: File) => {
-          const kind = inferMediaKind(file.name, file.type);
-          let url = '';
-          if (kind === 'photo') url = await compressImage(file);
-          else {
-            const reader = new FileReader();
-            url = await new Promise((resolve) => {
-              reader.onload = (ev) => resolve(ev.target?.result as string);
-              reader.readAsDataURL(file);
-            });
-          }
-          return { id: `m-${Date.now()}-${Math.random()}`, name: file.name, kind, url, createdAt: new Date().toISOString() };
-        })
-      );
-
-      setProfiles((prev) =>
-        prev.map((p) =>
-          p.id === activeProfileId
-            ? {
-                ...p,
-                timeline: (p.timeline || []).map((ev: any) =>
-                  ev.id === attachingToEventId ? { ...ev, media: [...(ev.media || []), ...newMediaItems] } : ev
-                ),
-              }
-            : p
-        )
-      );
-      toast(`Attached ${newMediaItems.length} files`);
-    } catch (err) {
-      console.error(err);
-      toast('Upload error');
-    } finally {
-      setAttachingToEventId(null);
-      e.target.value = '';
-    }
-  };
-
-  // ── handleEventMediaUpload ───────────────────────────────────────────────────
-
-  const handleEventMediaUpload = async (eventId: string, files: FileList) => {
-    try {
-      assertAuthenticated(user, 'event media upload');
-    } catch (err) {
-      if (err instanceof AuthenticationError) {
-        toast('Please sign in to attach media.');
-      }
-      return;
-    }
-
-    if (!activeProfileId || !files.length) return;
-
-    toast('Processing...');
-    try {
-      const newMediaItems: MediaItem[] = await Promise.all(
-        Array.from(files).map(async (file: File) => {
-          const kind = inferMediaKind(file.name, file.type);
-          let url = '';
-          if (kind === 'photo') {
-            url = await compressImage(file);
-          } else {
-            url = await new Promise<string>((resolve, reject) => {
-              const reader = new FileReader();
-              reader.onload = (ev) => resolve(ev.target?.result as string);
-              reader.onerror = reject;
-              reader.readAsDataURL(file);
-            });
-          }
-          return {
-            id: `m-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`,
-            name: file.name,
-            kind,
-            url,
-            mime: file.type,
-            size: file.size,
-            createdAt: new Date().toISOString(),
-          };
-        })
-      );
-
-      setProfiles((prev) =>
-        prev.map((p) =>
-          p.id !== activeProfileId
-            ? p
-            : {
-                ...p,
-                timeline: p.timeline.map((ev) =>
-                  ev.id !== eventId
-                    ? ev
-                    : { ...ev, media: [...(ev.media || []), ...newMediaItems] }
-                ),
-              }
-        )
-      );
-      toast(`Attached ${newMediaItems.length} file${newMediaItems.length !== 1 ? 's' : ''}`);
-    } catch (err) {
-      console.error(err);
-      toast('Upload error');
-    }
-  };
-
-  return { isPhotoLoading, handleProfilePhotoUpload, handleLifecycleFileUpload, handleEventMediaUpload };
-};
diff -ruN before/useSession.ts after/useSession.ts
--- before/useSession.ts	2026-02-21 02:03:34.319190062 +0000
+++ after/useSession.ts	1970-01-01 00:00:00.000000000 +0000
@@ -1,84 +0,0 @@
-// hooks/useSession.ts
-//
-// Session management backed entirely by Supabase Auth.
-// localStorage is NOT used for session persistence — the Supabase client
-// handles token storage internally via its own secure mechanism.
-//
-// Behaviour:
-//   • On mount: calls supabase.auth.getSession() to rehydrate any existing
-//     token, then subscribes to onAuthStateChange for all future events.
-//   • SIGNED_IN  → map Supabase user to our User type → go to HOME
-//   • SIGNED_OUT → clear user state → go to LOGIN
-//   • Initial state is SPLASH (shown during the async getSession call).
-
-import { useEffect, useState } from 'react';
-import type { Session } from '@supabase/supabase-js';
-import { AppView } from '../types';
-import type { User } from '../types';
-import { supabase } from '../lib/supabaseClient';
-
-/** Map a Supabase session to our lightweight User type. */
-function sessionToUser(session: Session): User {
-  const { id, email, user_metadata } = session.user;
-  return {
-    id,
-    email: email ?? '',
-    // Prefer the display_name set during sign-up; fall back to the email prefix.
-    name: (user_metadata?.display_name as string | undefined)
-      ?? (email?.split('@')[0] ?? 'User'),
-    createdAt: session.user.created_at,
-  };
-}
-
-export const useSession = () => {
-  const [view, setView] = useState<AppView>(AppView.SPLASH);
-  const [user, setUser] = useState<User | null>(null);
-
-  useEffect(() => {
-    // 1. Rehydrate immediately from any existing token in storage.
-    supabase.auth.getSession().then(({ data: { session } }) => {
-      if (session) {
-        setUser(sessionToUser(session));
-        setView(AppView.HOME);
-      } else {
-        // No session — advance past splash to the login screen.
-        setView(AppView.LOGIN);
-      }
-    });
-
-    // 2. Subscribe to all future auth state changes (sign-in, sign-out,
-    //    token refresh, password recovery, etc.).
-    const { data: { subscription } } = supabase.auth.onAuthStateChange(
-      (_event, session) => {
-        if (session) {
-          setUser(sessionToUser(session));
-          setView(AppView.HOME);
-        } else {
-          setUser(null);
-          setView(AppView.LOGIN);
-        }
-      }
-    );
-
-    return () => subscription.unsubscribe();
-  }, []);
-
-  const login = (u: User) => {
-    // Called by Auth.tsx after a successful Supabase sign-in/sign-up.
-    // onAuthStateChange will also fire, so this is intentionally a no-op for
-    // state — we keep it in the public API so Auth.tsx has a consistent call
-    // signature and the view transition happens exactly once here.
-    setUser(u);
-    setView(AppView.HOME);
-  };
-
-  const logout = async () => {
-    await supabase.auth.signOut();
-    // onAuthStateChange fires SIGNED_OUT and clears state, but set immediately
-    // for instant UI feedback.
-    setUser(null);
-    setView(AppView.LOGIN);
-  };
-
-  return { view, setView, user, login, logout };
-};
diff -ruN before/utils/date.ts after/utils/date.ts
--- before/utils/date.ts	2026-02-21 02:03:34.334190062 +0000
+++ after/utils/date.ts	1970-01-01 00:00:00.000000000 +0000
@@ -1,45 +0,0 @@
-
-import { MONTHS } from '../constants.tsx';
-import { gedcomDateToSortKey } from './gedcom';
-
-// Re-export for backward compatibility
-export const parseGedcomDate = gedcomDateToSortKey;
-
-export const parseGedcomMonthDayYear = (dateStr?: string) => {
-  if (!dateStr) return {};
-  const cleaned = dateStr.toUpperCase().replace(/ABT\.?|EST\.?|BEF\.?|AFT\.?|BET\.?|AND\b|CAL\.?/g, '').trim();
-  const yearMatch = cleaned.match(/\b(\d{4})\b/);
-  const year = yearMatch ? parseInt(yearMatch[1], 10) : undefined;
-  const monthIndex = MONTHS.findIndex((m) => new RegExp(`\\b${m}\\b`).test(cleaned));
-  const month = monthIndex >= 0 ? monthIndex + 1 : undefined;
-  let day: number | undefined;
-  if (month) {
-    const parts = cleaned.split(/\s+/).filter(Boolean);
-    const mIdx = parts.findIndex((p) => p === MONTHS[month - 1]);
-    if (mIdx > 0) {
-      const candidate = parseInt(parts[mIdx - 1], 10);
-      if (!Number.isNaN(candidate) && candidate >= 1 && candidate <= 31) day = candidate;
-    }
-  }
-  return { month, day, year };
-};
-
-export const formatFullDate = (dateStr?: string): string => {
-  if (!dateStr) return 'Undated';
-  // Strip GEDCOM qualifiers for display
-  const clean = dateStr.replace(/^(ABT\.?|EST\.?|BEF\.?|AFT\.?|CAL\.?|CIR\.?|CIRCA)\s*/i, '').trim();
-  const { month, day, year } = parseGedcomMonthDayYear(dateStr);
-  if (year && month && day) {
-    try {
-      return new Date(year, month - 1, day).toLocaleDateString('en-US', {
-        month: 'long', day: 'numeric', year: 'numeric',
-      });
-    } catch { /* fall through */ }
-  }
-  if (year && month) {
-    const monthName = new Date(year, month - 1, 1).toLocaleDateString('en-US', { month: 'long' });
-    return `${monthName} ${year}`;
-  }
-  if (year) return String(year);
-  return clean || 'Undated';
-};
diff -ruN before/utils/formatters.ts after/utils/formatters.ts
--- before/utils/formatters.ts	2026-02-21 02:03:34.350190062 +0000
+++ after/utils/formatters.ts	1970-01-01 00:00:00.000000000 +0000
@@ -1,50 +0,0 @@
-
-import { formatFullDate } from './date';
-import { eventVerb } from '../constants.tsx';
-import { LifeEvent, MediaKind } from '../types';
-
-export const formatEventSentence = (profileName: string, ev: LifeEvent): string => {
-  const dateStr = ev.date ? formatFullDate(ev.date) : '';
-  const placeStr = ev.place ? ev.place.trim() : '';
-  
-  if (ev.type === 'Birth') {
-    let part = '';
-    if (dateStr && placeStr) part = `on ${dateStr}, in ${placeStr}`;
-    else if (dateStr) part = `on ${dateStr}`;
-    else if (placeStr) part = `in ${placeStr}`;
-    return `${profileName} was born${part ? ' ' + part : ''}.`;
-  }
-  
-  if (ev.type === 'Marriage') {
-    const spouse = ev.spouseName || 'Unknown';
-    let part = '';
-    if (placeStr && dateStr) part = `in ${placeStr} on ${dateStr}`;
-    else if (placeStr) part = `in ${placeStr}`;
-    else if (dateStr) part = `on ${dateStr}`;
-    return `${profileName} married ${spouse}${part ? ' ' + part : ''}.`;
-  }
-
-  const verb = eventVerb(ev.type);
-  let part = '';
-  if (dateStr && placeStr) part = `on ${dateStr} in ${placeStr}`;
-  else if (dateStr) part = `on ${dateStr}`;
-  else if (placeStr) part = `in ${placeStr}`;
-  return `${profileName} ${verb}${part ? ' ' + part : ''}.`;
-};
-
-export const inferMediaKind = (fileName: string, fileType?: string): MediaKind => {
-  const lower = fileName.toLowerCase();
-  const t = (fileType || '').toLowerCase();
-  if (t.startsWith('image/') || /\.(jpg|jpeg|png|webp|gif|heic)$/i.test(lower)) return 'photo';
-  if (t.startsWith('video/') || /\.(mp4|mov|m4v|webm)$/i.test(lower)) return 'video';
-  if (t.startsWith('audio/') || /\.(mp3|m4a|wav|aac|ogg|flac)$/i.test(lower)) return 'audio';
-  if (t === 'application/pdf' || /\.pdf$/i.test(lower)) return 'document';
-  if (t.includes('word') || /\.(doc|docx)$/i.test(lower)) return 'document';
-  return 'document';
-};
-
-export const getSurname = (name: string): string => {
-  if (!name) return '';
-  const parts = name.trim().split(/\s+/);
-  return parts.length > 1 ? parts[parts.length - 1] : name;
-};
diff -ruN before/utils/gedcom.ts after/utils/gedcom.ts
--- before/utils/gedcom.ts	2026-02-21 02:03:34.364190062 +0000
+++ after/utils/gedcom.ts	1970-01-01 00:00:00.000000000 +0000
@@ -1,292 +0,0 @@
-
-import { Profile, FamilyTree, LifeEvent } from '../types';
-import { getPlaceholderImage } from '../constants';
-
-const tagToLabel: Record<string, string> = {
-  BIRT: 'Birth',
-  BAPM: 'Baptism',
-  BAPT: 'Baptism',
-  CHR:  'Christening',
-  DEAT: 'Death',
-  BURI: 'Burial',
-  CREM: 'Cremation',
-  RESI: 'Residence',
-  EMIG: 'Departure/Emigration',
-  IMMI: 'Arrival/Immigration',
-  CENS: 'Census',
-  MARR: 'Marriage',
-  DIV:  'Divorce',
-  DIVO: 'Divorce',
-  GRAD: 'Graduation',
-  EDUC: 'Education',
-  OCCU: 'Occupation',
-  TITL: 'Title',
-  NATI: 'Nationality',
-  RELI: 'Religion',
-  NATU: 'Naturalization',
-  ADOP: 'Adoption',
-  BARM: 'Bar Mitzvah',
-  BATM: 'Bat Mitzvah',
-  CONF: 'Confirmation',
-  PROB: 'Probate',
-  WILL: 'Will',
-  EVEN: 'Event',
-  FACT: 'Fact',
-  ORDN: 'Ordination',
-  MILI: 'Military Service',
-  RETI: 'Retirement',
-};
-
-const MONTH_ABBR = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'];
-
-export const gedcomDateToSortKey = (dateStr?: string): number => {
-  if (!dateStr) return 9999;
-  const upper = dateStr.toUpperCase()
-    .replace(/ABT\.?|EST\.?|CAL\.?|BEF\.?|AFT\.?|CIR\.?|CIRCA|BET\.?|AND\b/g, '')
-    .trim();
-  const yearMatch = upper.match(/\b(\d{4})\b/);
-  if (!yearMatch) return 9999;
-  const year = parseInt(yearMatch[1], 10);
-  const monthIdx = MONTH_ABBR.findIndex(m => upper.includes(m));
-  const month = monthIdx >= 0 ? monthIdx + 1 : 0;
-  let day = 0;
-  if (month) {
-    const parts = upper.split(/\s+/).filter(Boolean);
-    const mi = parts.findIndex(p => p === MONTH_ABBR[month - 1]);
-    if (mi > 0) {
-      const candidate = parseInt(parts[mi - 1], 10);
-      if (!isNaN(candidate) && candidate >= 1 && candidate <= 31) day = candidate;
-    }
-  }
-  return year + month / 12 + day / 365;
-};
-
-function addOrUpdateMarriage(
-  person: Profile | undefined,
-  spouse: Profile | undefined,
-  date: string,
-  place: string,
-  stamp: string
-) {
-  if (!person) return;
-  const existing = person.timeline.find(e => e.type === 'Marriage' && e.date === date);
-  if (existing) {
-    if (!existing.spouseName) existing.spouseName = spouse?.name ?? 'Unknown';
-    if (place && !existing.place) existing.place = place;
-  } else {
-    person.timeline.push({
-      id: `ev-marr-${stamp}-${Math.random().toString(36).slice(2, 6)}`,
-      type: 'Marriage',
-      date,
-      place,
-      spouseName: spouse?.name ?? 'Unknown',
-      media: [],
-    });
-  }
-}
-
-export const parseGedcom = (
-  text: string,
-  userId: string,
-  maxGenerations = 4
-): { importedProfiles: Profile[]; tree: FamilyTree } => {
-  const importStamp = Date.now().toString();
-  const indis = new Map<string, any>();
-  const fams  = new Map<string, any>();
-
-  let currentIndi:  any = null;
-  let currentFam:   any = null;
-  let currentEvent: any = null;
-  let homeGedId: string | null = null;
-
-  for (const rawLine of text.split(/\r?\n/)) {
-    const line = rawLine.trim();
-    if (!line) continue;
-    const spaceIdx = line.indexOf(' ');
-    if (spaceIdx === -1) continue;
-    const level     = line.slice(0, spaceIdx);
-    const remainder = line.slice(spaceIdx + 1);
-    const spaceIdx2 = remainder.indexOf(' ');
-    const tagOrXref = spaceIdx2 === -1 ? remainder : remainder.slice(0, spaceIdx2);
-    const rest      = spaceIdx2 === -1 ? '' : remainder.slice(spaceIdx2 + 1);
-
-    if (level === '0') {
-      currentEvent = null;
-      if (rest === 'INDI') {
-        const gid = tagOrXref;
-        if (!homeGedId) homeGedId = gid;
-        currentIndi = {
-          gedId: gid, name: 'Unknown', gender: 'U',
-          timeline: [], birthYear: 'Unknown', deathYear: undefined,
-          famc: null as string | null, fams: [] as string[],
-        };
-        indis.set(gid, currentIndi);
-        currentFam = null;
-      } else if (rest === 'FAM') {
-        currentFam = { gedId: tagOrXref, husb: '', wife: '', chil: [] as string[], marrDate: '', marrPlace: '' };
-        fams.set(tagOrXref, currentFam);
-        currentIndi = null;
-      } else {
-        currentIndi = null;
-        currentFam  = null;
-      }
-      continue;
-    }
-
-    if (currentIndi) {
-      if (level === '1') {
-        if (tagOrXref === 'NAME') {
-          currentIndi.name = rest.replace(/\//g, ' ').replace(/\s{2,}/g, ' ').trim() || 'Unknown';
-        } else if (tagOrXref === 'SEX') {
-          const s = rest.trim().toUpperCase();
-          currentIndi.gender = s === 'M' ? 'M' : s === 'F' ? 'F' : 'U';
-        } else if (tagOrXref === 'FAMC') {
-          currentIndi.famc = rest.trim();
-        } else if (tagOrXref === 'FAMS') {
-          currentIndi.fams.push(rest.trim());
-        } else if (tagToLabel[tagOrXref]) {
-          currentEvent = {
-            id: `ev-${importStamp}-${Math.random().toString(36).slice(2, 9)}`,
-            type: tagToLabel[tagOrXref],
-            date: '', place: '', media: [],
-          };
-          currentIndi.timeline.push(currentEvent);
-        } else {
-          currentEvent = null;
-        }
-      } else if (level === '2' && currentEvent) {
-        if (tagOrXref === 'DATE') {
-          currentEvent.date = rest.trim();
-          const y = rest.match(/\b(\d{4})\b/);
-          if (y) {
-            if (currentEvent.type === 'Birth') currentIndi.birthYear = y[1];
-            if (currentEvent.type === 'Death') currentIndi.deathYear = y[1];
-          }
-        } else if (tagOrXref === 'PLAC') {
-          currentEvent.place = rest.trim();
-        } else if (tagOrXref === 'NOTE') {
-          currentEvent.note = rest.trim();
-        } else if (tagOrXref === 'TYPE' && rest.trim()) {
-          currentEvent.subType = rest.trim();
-        }
-      }
-      continue;
-    }
-
-    if (currentFam) {
-      if (level === '1') {
-        if      (tagOrXref === 'HUSB') { currentFam.husb = rest.trim(); currentEvent = null; }
-        else if (tagOrXref === 'WIFE') { currentFam.wife = rest.trim(); currentEvent = null; }
-        else if (tagOrXref === 'CHIL') { currentFam.chil.push(rest.trim()); currentEvent = null; }
-        else if (tagOrXref === 'MARR') { currentEvent = { type: 'MARR' }; }
-        else                           { currentEvent = null; }
-      } else if (level === '2' && currentEvent?.type === 'MARR') {
-        if (tagOrXref === 'DATE')  currentFam.marrDate  = rest.trim();
-        if (tagOrXref === 'PLAC')  currentFam.marrPlace = rest.trim();
-      }
-    }
-  }
-
-  // Generation traversal
-  const generations = new Map<string, number>();
-  const traverseGen = (gedId: string, gen: number, visited = new Set<string>()) => {
-    if (visited.has(gedId) || !indis.has(gedId)) return;
-    visited.add(gedId);
-    generations.set(gedId, gen);
-    const indi = indis.get(gedId)!;
-    if (indi.famc) {
-      const pf = fams.get(indi.famc);
-      if (pf) {
-        if (pf.husb) traverseGen(pf.husb, gen + 1, visited);
-        if (pf.wife) traverseGen(pf.wife, gen + 1, visited);
-      }
-    }
-    for (const famXref of indi.fams) {
-      const sf = fams.get(famXref);
-      if (sf) {
-        for (const childXref of sf.chil) traverseGen(childXref, gen - 1, visited);
-        if (gen === 0) {
-          if (sf.husb && sf.husb !== gedId) traverseGen(sf.husb, 0, visited);
-          if (sf.wife && sf.wife !== gedId) traverseGen(sf.wife, 0, visited);
-        }
-      }
-    }
-  };
-  if (homeGedId) traverseGen(homeGedId, 0);
-
-  // Build profile ID map
-  const profileIdFor: Record<string, string> = {};
-  const filteredIndis: any[] = [];
-  indis.forEach((indi, gedId) => {
-    const gen = generations.get(gedId);
-    if (gen !== undefined && Math.abs(gen) <= maxGenerations) {
-      profileIdFor[gedId] = `imp-${importStamp}-${gedId.replace(/@/g, '')}`;
-      filteredIndis.push(indi);
-    }
-  });
-
-  // Build Profile objects with chronologically sorted timelines
-  const importedProfiles: Profile[] = filteredIndis.map(indi => ({
-    id:          profileIdFor[indi.gedId],
-    userId,
-    name:        indi.name,
-    gender:      indi.gender,
-    birthYear:   indi.birthYear,
-    deathYear:   indi.deathYear,
-    imageUrl:    getPlaceholderImage(indi.gender),
-    summary:     '',
-    isMemorial:  true,
-    timeline:    [...indi.timeline].sort((a: LifeEvent, b: LifeEvent) =>
-                   gedcomDateToSortKey(a.date) - gedcomDateToSortKey(b.date)),
-    memories:    [],
-    sources:     [],
-    parentIds:   [],
-    childIds:    [],
-    spouseIds:   [],
-  }));
-
-  // Link relationships
-  fams.forEach(fam => {
-    const husb     = importedProfiles.find(p => p.id === profileIdFor[fam.husb]);
-    const wife     = importedProfiles.find(p => p.id === profileIdFor[fam.wife]);
-    const children = (fam.chil as string[])
-      .map(xref => importedProfiles.find(p => p.id === profileIdFor[xref]))
-      .filter(Boolean) as Profile[];
-
-    if (husb && wife) {
-      if (!husb.spouseIds.includes(wife.id)) husb.spouseIds.push(wife.id);
-      if (!wife.spouseIds.includes(husb.id)) wife.spouseIds.push(husb.id);
-    }
-    for (const child of children) {
-      if (husb) {
-        if (!child.parentIds.includes(husb.id)) child.parentIds.push(husb.id);
-        if (!husb.childIds.includes(child.id))  husb.childIds.push(child.id);
-      }
-      if (wife) {
-        if (!child.parentIds.includes(wife.id)) child.parentIds.push(wife.id);
-        if (!wife.childIds.includes(child.id))  wife.childIds.push(child.id);
-      }
-    }
-    if (fam.marrDate || fam.marrPlace) {
-      addOrUpdateMarriage(husb, wife, fam.marrDate, fam.marrPlace, importStamp);
-      addOrUpdateMarriage(wife, husb, fam.marrDate, fam.marrPlace, importStamp);
-    }
-  });
-
-  // Final re-sort after marriage events added
-  for (const p of importedProfiles) {
-    p.timeline.sort((a, b) => gedcomDateToSortKey(a.date) - gedcomDateToSortKey(b.date));
-  }
-
-  return {
-    importedProfiles,
-    tree: {
-      id:           `tree-${importStamp}`,
-      userId,
-      name:         'Staged Import Tree',
-      createdAt:    new Date().toISOString(),
-      homePersonId: homeGedId ? (profileIdFor[homeGedId] ?? '') : '',
-      memberIds:    importedProfiles.map(p => p.id),
-    },
-  };
-};
diff -ruN before/utils/media.ts after/utils/media.ts
--- before/utils/media.ts	2026-02-21 02:03:34.377190062 +0000
+++ after/utils/media.ts	1970-01-01 00:00:00.000000000 +0000
@@ -1,45 +0,0 @@
-export const compressImage = (file: File): Promise<string> => {
-  return new Promise((resolve, reject) => {
-    if (!file.type.startsWith('image/')) {
-      const reader = new FileReader();
-      reader.onload = (e) => resolve(e.target?.result as string);
-      reader.onerror = reject;
-      reader.readAsDataURL(file);
-      return;
-    }
-
-    const reader = new FileReader();
-    reader.readAsDataURL(file);
-    reader.onload = (event) => {
-      const img = new Image();
-      img.src = event.target?.result as string;
-      img.onload = () => {
-        const canvas = document.createElement('canvas');
-        const MAX_WIDTH = 800;
-        const MAX_HEIGHT = 800;
-        let width = img.width;
-        let height = img.height;
-
-        if (width > height) {
-          if (width > MAX_WIDTH) {
-            height *= MAX_WIDTH / width;
-            width = MAX_WIDTH;
-          }
-        } else {
-          if (height > MAX_HEIGHT) {
-            width *= MAX_HEIGHT / height;
-            height = MAX_HEIGHT;
-          }
-        }
-
-        canvas.width = width;
-        canvas.height = height;
-        const ctx = canvas.getContext('2d');
-        ctx?.drawImage(img, 0, 0, width, height);
-        resolve(canvas.toDataURL('image/jpeg', 0.7));
-      };
-      img.onerror = reject;
-    };
-    reader.onerror = reject;
-  });
-};
diff -ruN before/utils/search.ts after/utils/search.ts
--- before/utils/search.ts	2026-02-21 02:03:34.392190061 +0000
+++ after/utils/search.ts	1970-01-01 00:00:00.000000000 +0000
@@ -1,40 +0,0 @@
-import { getSurname } from './formatters';
-
-const getLevenshteinDistance = (a: string, b: string): number => {
-  const matrix: number[][] = [];
-  for (let i = 0; i <= a.length; i++) {
-    matrix[i] = [i];
-  }
-  for (let j = 0; j <= b.length; j++) {
-    matrix[0][j] = j;
-  }
-  for (let i = 1; i <= a.length; i++) {
-    for (let j = 1; j <= b.length; j++) {
-      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
-      matrix[i][j] = Math.min(
-        matrix[i - 1][j] + 1,
-        matrix[i][j - 1] + 1,
-        matrix[i - 1][j - 1] + cost
-      );
-    }
-  }
-  return matrix[a.length][b.length];
-};
-
-export const getFuzzyScore = (target: string, query: string): number => {
-  const str = target.toLowerCase();
-  const q = query.toLowerCase();
-  if (str === q) return 100;
-  if (str.startsWith(q)) return 80;
-  if (str.includes(q)) return 60;
-
-  const surname = getSurname(target).toLowerCase();
-  if (surname.startsWith(q)) return 70;
-
-  if (q.length > 3) {
-    const distance = getLevenshteinDistance(str, q);
-    const threshold = q.length <= 5 ? 1 : 2;
-    if (distance <= threshold) return 40 - distance;
-  }
-  return 0;
-};
diff -ruN before/vercel.json after/vercel.json
--- before/vercel.json	2026-02-21 02:03:34.406190061 +0000
+++ after/vercel.json	2026-02-21 02:07:13.118188428 +0000
@@ -1,13 +1,8 @@
 {
-  "buildCommand": "vite build",
+  "buildCommand": "npm run build",
   "devCommand": "vite --port 5173",
   "outputDirectory": "dist",
   "framework": null,
-  "functions": {
-    "api/**/*.ts": {
-      "runtime": "nodejs20.x"
-    }
-  },
   "rewrites": [
     { "source": "/api/(.*)", "destination": "/api/$1" },
     { "source": "/(.*)",     "destination": "/index.html" }
diff -ruN before/views/CreateMemoryView.tsx after/views/CreateMemoryView.tsx
--- before/views/CreateMemoryView.tsx	2026-02-21 02:03:34.420190061 +0000
+++ after/views/CreateMemoryView.tsx	1970-01-01 00:00:00.000000000 +0000
@@ -1,37 +0,0 @@
-import React from 'react';
-import { ChevronLeft } from 'lucide-react';
-
-const CreateMemoryView: React.FC<{
-  newMemoryInput: string;
-  setNewMemoryInput: (v: string) => void;
-  onBack: () => void;
-  onSave: () => void;
-}> = (props) => {
-  return (
-    <div className="flex flex-col h-full bg-[#f5f2eb]">
-      <header className="pt-16 px-8 pb-6 bg-white border-b flex justify-between items-center">
-        <button onClick={props.onBack} className="text-stone-400 text-[10px] font-bold uppercase">
-          <ChevronLeft size={16} className="inline" /> Back
-        </button>
-        <h2 className="text-xl font-serif">Create Memory</h2>
-        <button onClick={props.onSave} className="bg-stone-900 text-white px-4 py-2 rounded-full text-[10px] font-bold uppercase">
-          Save
-        </button>
-      </header>
-
-      <main className="flex-1 p-8 overflow-y-auto">
-        <div className="bg-white p-6 rounded-[32px] border border-stone-100 space-y-4">
-          <div className="text-[10px] font-bold uppercase text-stone-400 tracking-widest">Memory</div>
-          <textarea
-            value={props.newMemoryInput}
-            onChange={(e) => props.setNewMemoryInput(e.target.value)}
-            className="w-full min-h-[240px] p-4 rounded-2xl border border-stone-200 outline-none"
-            placeholder="Write a memory, story, or anecdote"
-          />
-        </div>
-      </main>
-    </div>
-  );
-};
-
-export default CreateMemoryView;
diff -ruN before/views/EditProfileView.tsx after/views/EditProfileView.tsx
--- before/views/EditProfileView.tsx	2026-02-21 02:03:34.435190061 +0000
+++ after/views/EditProfileView.tsx	1970-01-01 00:00:00.000000000 +0000
@@ -1,64 +0,0 @@
-import React from 'react';
-import { ChevronLeft } from 'lucide-react';
-
-const EditProfileView: React.FC<{
-  editName: string;
-  setEditName: (v: string) => void;
-  editGender: string;
-  setEditGender: (v: string) => void;
-  editBirthYear: string;
-  setEditBirthYear: (v: string) => void;
-  editDeathYear: string;
-  setEditDeathYear: (v: string) => void;
-  editImageUrl: string;
-  setEditImageUrl: (v: string) => void;
-
-  onBack: () => void;
-  onSave: () => void;
-}> = (props) => {
-  return (
-    <div className="flex flex-col h-full bg-[#f5f2eb]">
-      <header className="pt-16 px-8 pb-6 bg-white border-b flex justify-between items-center">
-        <button onClick={props.onBack} className="text-stone-400 text-[10px] font-bold uppercase">
-          <ChevronLeft size={16} className="inline" /> Back
-        </button>
-        <h2 className="text-xl font-serif">Edit Profile</h2>
-        <button onClick={props.onSave} className="bg-stone-900 text-white px-4 py-2 rounded-full text-[10px] font-bold uppercase">
-          Save
-        </button>
-      </header>
-
-      <main className="flex-1 p-8 space-y-6 overflow-y-auto">
-        <div className="bg-white p-6 rounded-[32px] border border-stone-100 space-y-4">
-          <label className="block">
-            <div className="text-[10px] font-bold uppercase text-stone-400 tracking-widest mb-2">Full name</div>
-            <input value={props.editName} onChange={(e) => props.setEditName(e.target.value)} className="w-full p-4 rounded-2xl border border-stone-200 outline-none" />
-          </label>
-
-          <label className="block">
-            <div className="text-[10px] font-bold uppercase text-stone-400 tracking-widest mb-2">Gender</div>
-            <input value={props.editGender} onChange={(e) => props.setEditGender(e.target.value)} className="w-full p-4 rounded-2xl border border-stone-200 outline-none" placeholder="M, F, or other" />
-          </label>
-
-          <div className="grid md:grid-cols-2 gap-4">
-            <label className="block">
-              <div className="text-[10px] font-bold uppercase text-stone-400 tracking-widest mb-2">Birth year</div>
-              <input value={props.editBirthYear} onChange={(e) => props.setEditBirthYear(e.target.value)} className="w-full p-4 rounded-2xl border border-stone-200 outline-none" />
-            </label>
-            <label className="block">
-              <div className="text-[10px] font-bold uppercase text-stone-400 tracking-widest mb-2">Death year</div>
-              <input value={props.editDeathYear} onChange={(e) => props.setEditDeathYear(e.target.value)} className="w-full p-4 rounded-2xl border border-stone-200 outline-none" />
-            </label>
-          </div>
-
-          <label className="block">
-            <div className="text-[10px] font-bold uppercase text-stone-400 tracking-widest mb-2">Image URL</div>
-            <input value={props.editImageUrl} onChange={(e) => props.setEditImageUrl(e.target.value)} className="w-full p-4 rounded-2xl border border-stone-200 outline-none" />
-          </label>
-        </div>
-      </main>
-    </div>
-  );
-};
-
-export default EditProfileView;
diff -ruN before/views/FamilyCircleView.tsx after/views/FamilyCircleView.tsx
--- before/views/FamilyCircleView.tsx	2026-02-21 02:03:34.449190061 +0000
+++ after/views/FamilyCircleView.tsx	1970-01-01 00:00:00.000000000 +0000
@@ -1,68 +0,0 @@
-import React from 'react';
-import { ChevronLeft } from 'lucide-react';
-import { CirclePost, Profile, User } from '../types';
-import { PostComposer } from '../components/circle/PostComposer';
-import { CircleFeed } from '../components/circle/CircleFeed';
-
-interface FamilyCircleViewProps {
-  user: User;
-  profiles: Profile[];
-  posts: CirclePost[];
-  onBack: () => void;
-  onAddPost: (post: CirclePost) => void;
-  onDeletePost: (id: string) => void;
-  onProfileClick: (profileId: string) => void;
-}
-
-export default function FamilyCircleView({
-  user,
-  profiles,
-  posts,
-  onBack,
-  onAddPost,
-  onDeletePost,
-  onProfileClick
-}: FamilyCircleViewProps) {
-  return (
-    <div className="flex flex-col h-full bg-[#f9f8f6]">
-      {/* Header */}
-      <header className="pt-16 px-8 pb-5 bg-[#f5f2eb] border-b border-stone-200 flex-shrink-0">
-        <div className="flex justify-between items-center">
-          <button
-            onClick={onBack}
-            className="flex items-center gap-2 text-stone-500 hover:text-stone-900 transition-colors"
-          >
-            <ChevronLeft size={18} />
-            <span className="text-[11px] font-bold uppercase tracking-widest">Back</span>
-          </button>
-          <span className="text-[10px] font-bold uppercase tracking-widest text-stone-300">
-            {posts.length} {posts.length === 1 ? 'post' : 'posts'}
-          </span>
-        </div>
-        <div className="mt-4">
-          <h2 className="text-3xl font-serif text-slate-800">Family Circle</h2>
-          <p className="text-stone-400 text-[10px] font-bold uppercase mt-0.5">
-            Shared memories · {profiles.length} {profiles.length === 1 ? 'member' : 'members'}
-          </p>
-        </div>
-      </header>
-
-      {/* Scrollable content */}
-      <main className="flex-1 overflow-y-auto scrollbar-hide p-6 space-y-5 pb-10">
-        <PostComposer
-          profiles={profiles}
-          authorLabel={user.name}
-          userId={user.id}
-          onSubmit={onAddPost}
-        />
-        <CircleFeed
-          posts={posts}
-          profiles={profiles}
-          currentUserId={user.id}
-          onDeletePost={onDeletePost}
-          onProfileClick={onProfileClick}
-        />
-      </main>
-    </div>
-  );
-}
diff -ruN before/views/LinkRelativeView.tsx after/views/LinkRelativeView.tsx
--- before/views/LinkRelativeView.tsx	2026-02-21 02:03:34.465190061 +0000
+++ after/views/LinkRelativeView.tsx	1970-01-01 00:00:00.000000000 +0000
@@ -1,56 +0,0 @@
-import React from 'react';
-import { ChevronLeft, Search } from 'lucide-react';
-import { Profile } from '../types';
-
-const LinkRelativeView: React.FC<{
-  linkRole: 'parent' | 'spouse' | 'child' | null;
-  searchQuery: string;
-  setSearchQuery: (v: string) => void;
-  searchResults: Profile[];
-  onBack: () => void;
-  onSelect: (p: Profile) => void;
-}> = (props) => {
-  return (
-    <div className="flex flex-col h-full bg-[#f9f8f6]">
-      <header className="pt-16 px-8 pb-6 bg-[#f5f2eb] border-b border-stone-200">
-        <div className="flex justify-between items-center">
-          <button onClick={props.onBack} className="text-stone-400 text-[10px] font-bold uppercase">
-            <ChevronLeft size={16} className="inline" /> Back
-          </button>
-          <h2 className="text-xl font-serif">Link {props.linkRole ?? ''}</h2>
-          <div />
-        </div>
-
-        <div className="mt-6 flex items-center space-x-3 bg-white rounded-full border border-stone-200 px-4 py-3">
-          <Search size={18} className="text-stone-300" />
-          <input
-            value={props.searchQuery}
-            onChange={(e) => props.setSearchQuery(e.target.value)}
-            placeholder="Search people"
-            className="flex-1 bg-transparent outline-none text-sm"
-          />
-        </div>
-      </header>
-
-      <main className="flex-1 p-8 overflow-y-auto">
-        <div className="grid gap-3">
-          {props.searchResults.map(p => (
-            <button
-              key={p.id}
-              onClick={() => props.onSelect(p)}
-              className="w-full bg-white p-4 rounded-[32px] shadow-sm border border-stone-50 flex items-center space-x-4 hover:shadow-md transition-all"
-            >
-              <img src={p.imageUrl} className="w-14 h-14 rounded-2xl object-cover grayscale" />
-              <div className="text-left flex-1">
-                <h4 className="font-serif text-xl">{p.name}</h4>
-                <p className="text-[10px] text-stone-400 font-black uppercase mt-1">{p.birthYear} — {p.deathYear || '...'}</p>
-              </div>
-            </button>
-          ))}
-        </div>
-      </main>
-    </div>
-  );
-};
-
-export default LinkRelativeView;
diff -ruN before/views/ProfileView.tsx after/views/ProfileView.tsx
--- before/views/ProfileView.tsx	2026-02-21 02:03:34.479190061 +0000
+++ after/views/ProfileView.tsx	1970-01-01 00:00:00.000000000 +0000
@@ -1,376 +0,0 @@
-import React from 'react';
-import {
-  ChevronLeft, ChevronRight, PenTool, Sparkles, History, ScrollText, Heart, MapPin,
-  Anchor, Map as MapIcon, Quote, CloudUpload, ExternalLink, Library, Globe, Image as ImageIcon,
-  Settings, Trash2, Users, UserPlus, Camera, Upload
-} from 'lucide-react';
-import { AppView, Profile, MediaItem, LifeEvent, FamilyTree } from '../types';
-import { getEventIcon, getPlaceholderImage } from '../constants';
-import { formatEventSentence, inferMediaKind } from '../utils/formatters';
-import { formatFullDate } from '../utils/date';
-
-type RelSet = { parents: Profile[]; spouses: Profile[]; children: Profile[] }
-
-// Extract year string for the year-chip display
-const getEventYear = (dateStr?: string): string => {
-  if (!dateStr) return 'Unknown';
-  const m = dateStr.match(/\b(\d{4})\b/);
-  return m ? m[1] : 'Unknown';
-};
-
-// Self-contained per-event media uploader
-const EventMediaUploader: React.FC<{
-  eventId: string;
-  onFilesSelected: (eventId: string, files: FileList) => void;
-}> = ({ eventId, onFilesSelected }) => {
-  const inputRef = React.useRef<HTMLInputElement>(null);
-  return (
-    <div className="mt-4 pt-4 border-t border-stone-100">
-      <p className="text-[10px] font-bold uppercase tracking-widest text-stone-400 mb-3">
-        Attach photos, videos, or audio
-      </p>
-      <div className="flex gap-3 flex-wrap">
-        <button
-          onClick={() => { if (inputRef.current) { inputRef.current.accept = 'image/*'; inputRef.current.click(); }}}
-          className="flex items-center gap-2 px-4 py-2.5 rounded-2xl bg-stone-50 border border-stone-100 hover:bg-amber-50 hover:border-amber-200 transition-colors"
-        >
-          <span className="text-base">🖼</span>
-          <span className="text-[11px] font-bold uppercase tracking-widest text-stone-600">Photo</span>
-        </button>
-        <button
-          onClick={() => { if (inputRef.current) { inputRef.current.accept = 'video/*'; inputRef.current.click(); }}}
-          className="flex items-center gap-2 px-4 py-2.5 rounded-2xl bg-stone-50 border border-stone-100 hover:bg-amber-50 hover:border-amber-200 transition-colors"
-        >
-          <span className="text-base">🎬</span>
-          <span className="text-[11px] font-bold uppercase tracking-widest text-stone-600">Video</span>
-        </button>
-        <button
-          onClick={() => { if (inputRef.current) { inputRef.current.accept = 'audio/*'; inputRef.current.click(); }}}
-          className="flex items-center gap-2 px-4 py-2.5 rounded-2xl bg-stone-50 border border-stone-100 hover:bg-amber-50 hover:border-amber-200 transition-colors"
-        >
-          <span className="text-base">🎵</span>
-          <span className="text-[11px] font-bold uppercase tracking-widest text-stone-600">Audio</span>
-        </button>
-      </div>
-      <input
-        ref={inputRef}
-        type="file"
-        multiple
-        className="hidden"
-        onChange={e => { if (e.target.files?.length) { onFilesSelected(eventId, e.target.files); e.target.value = ''; }}}
-      />
-    </div>
-  );
-};;
-
-const ProfileView: React.FC<{
-  activeProfile: Profile;
-  profiles: Profile[];
-  familyTrees: FamilyTree[];
-  selectedTreeId: string | null;
-
-  // navigation
-  onBack: () => void;
-  onEdit: () => void;
-  onLinkRelative: (role: 'parent' | 'spouse' | 'child') => void;
-
-  // mutations
-  onDeleteProfile: () => void;
-  onSetActiveProfile: (id: string) => void;
-
-  // media upload
-  onUploadMediaClick: () => void;
-  onMediaFileChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
-  mediaInputRef: React.RefObject<HTMLInputElement>;
-  onEventMediaUpload: (eventId: string, files: FileList) => void;
-
-  // event attachment
-  attachingToEventId: string | null;
-  setAttachingToEventId: (id: string | null) => void;
-
-  // AI states + actions
-  isAiLoading: boolean;
-  isResearchLoading: boolean;
-  isPhotoLoading: boolean;
-  isGeneratingPortrait: boolean;
-
-  onGenerateSummary: () => void;
-  onResearch: () => void;
-  onGeneratePortrait: () => void;
-
-  // toast helper for inline triggers if needed
-  showToast: (m: string) => void;
-}> = (props) => {
-  const {
-    activeProfile, profiles,
-    onBack, onEdit, onLinkRelative,
-    onDeleteProfile, onSetActiveProfile,
-    onUploadMediaClick, onMediaFileChange, mediaInputRef,
-    attachingToEventId, setAttachingToEventId,
-    isAiLoading, isResearchLoading, isPhotoLoading, isGeneratingPortrait,
-    onGenerateSummary, onResearch, onGeneratePortrait
-  } = props;
-
-  const isPlaceholder = activeProfile.imageUrl.startsWith('data:image/svg+xml');
-  const rels: RelSet = {
-    parents: profiles.filter(p => activeProfile.parentIds.includes(p.id)),
-    spouses: profiles.filter(p => activeProfile.spouseIds.includes(p.id)),
-    children: profiles.filter(p => activeProfile.childIds.includes(p.id))
-  };
-
-  const timeline = [...(activeProfile.timeline || [])].sort((a, b) => {
-    const da = a.date || '';
-    const db = b.date || '';
-    return da.localeCompare(db);
-  });
-
-  // Flatten all media from timeline events for the gallery section
-  const media = timeline.flatMap(ev => ev.media || []) as MediaItem[];
-
-  return (
-    <div className="flex flex-col h-full bg-[#f9f8f6]">
-      <header className="pt-16 px-8 pb-4 bg-[#f5f2eb] flex justify-between items-center">
-        <button onClick={onBack} className="text-stone-400 flex items-center space-x-2">
-          <ChevronLeft size={18} />
-          <span className="text-[10px] font-bold uppercase tracking-widest">Archive</span>
-        </button>
-        <div className="flex items-center space-x-2">
-          <button onClick={onEdit} className="p-2 rounded-full bg-white border border-stone-200 text-stone-400">
-            <PenTool size={16} />
-          </button>
-          <button onClick={onDeleteProfile} className="p-2 rounded-full bg-white border border-stone-200 text-stone-400">
-            <Trash2 size={16} />
-          </button>
-        </div>
-      </header>
-
-      <main className="flex-1 overflow-y-auto px-8 pb-10">
-        <div className="pt-6 pb-8 flex items-start space-x-6">
-          <div className="relative">
-            <img src={activeProfile.imageUrl || getPlaceholderImage(activeProfile.id)} className="w-28 h-28 rounded-[34px] object-cover grayscale border border-stone-100 shadow-sm" />
-            <button
-              onClick={onUploadMediaClick}
-              className="absolute -bottom-2 -right-2 p-2 rounded-full bg-stone-900 text-white shadow"
-              aria-label="Add media"
-            >
-              <Camera size={16} />
-            </button>
-            <input ref={mediaInputRef} type="file" onChange={onMediaFileChange} accept="image/*,video/*" className="hidden" />
-          </div>
-
-          <div className="flex-1">
-            <h2 className="text-4xl font-serif text-slate-900 leading-tight">{activeProfile.name}</h2>
-            <div className="mt-2 text-[10px] font-black uppercase tracking-widest text-stone-400">
-              {activeProfile.birthYear} — {activeProfile.deathYear || '...'}
-            </div>
-            {activeProfile.summary && (
-              <p className="mt-4 text-sm text-stone-600 leading-relaxed">{activeProfile.summary}</p>
-            )}
-          </div>
-        </div>
-
-        <section className="space-y-3 mb-10">
-          <div className="flex items-center justify-between px-2">
-            <h3 className="text-[10px] font-bold uppercase tracking-widest text-stone-400">AI Studio</h3>
-          </div>
-
-          <div className="grid gap-3 md:grid-cols-3">
-            <button
-              onClick={onGenerateSummary}
-              disabled={isAiLoading}
-              className="bg-white p-4 rounded-[32px] border border-stone-50 shadow-sm text-left hover:shadow-md transition-all disabled:opacity-50"
-            >
-              <div className="flex items-center space-x-3">
-                <Sparkles className="text-amber-600" size={18} />
-                <div className="font-black uppercase text-[10px] tracking-widest text-stone-500">
-                  {isAiLoading ? 'Generating...' : 'Generate Summary'}
-                </div>
-              </div>
-              <div className="mt-2 text-sm text-stone-600">Short biography from the profile and timeline.</div>
-            </button>
-
-            <button
-              onClick={onResearch}
-              disabled={isResearchLoading}
-              className="bg-white p-4 rounded-[32px] border border-stone-50 shadow-sm text-left hover:shadow-md transition-all disabled:opacity-50"
-            >
-              <div className="flex items-center space-x-3">
-                <Library className="text-amber-600" size={18} />
-                <div className="font-black uppercase text-[10px] tracking-widest text-stone-500">
-                  {isResearchLoading ? 'Researching...' : 'Historical Context'}
-                </div>
-              </div>
-              <div className="mt-2 text-sm text-stone-600">Add period context based on time and places.</div>
-            </button>
-
-            <button
-              onClick={onGeneratePortrait}
-              disabled={isGeneratingPortrait || isPhotoLoading}
-              className="bg-white p-4 rounded-[32px] border border-stone-50 shadow-sm text-left hover:shadow-md transition-all disabled:opacity-50"
-            >
-              <div className="flex items-center space-x-3">
-                <ImageIcon className="text-amber-600" size={18} />
-                <div className="font-black uppercase text-[10px] tracking-widest text-stone-500">
-                  {(isGeneratingPortrait || isPhotoLoading) ? 'Generating...' : 'Portrait'}
-                </div>
-              </div>
-              <div className="mt-2 text-sm text-stone-600">Generate a respectful AI portrait concept.</div>
-            </button>
-          </div>
-        </section>
-
-        <section className="space-y-3 mb-10">
-          <div className="flex items-center justify-between px-2">
-            <h3 className="text-[10px] font-bold uppercase tracking-widest text-stone-400">Relationships</h3>
-            <div className="flex items-center space-x-2">
-              <button onClick={() => onLinkRelative('parent')} className="text-[10px] font-bold uppercase text-amber-700 flex items-center space-x-1">
-                <UserPlus size={14} /><span>Parent</span>
-              </button>
-              <button onClick={() => onLinkRelative('spouse')} className="text-[10px] font-bold uppercase text-amber-700 flex items-center space-x-1">
-                <UserPlus size={14} /><span>Spouse</span>
-              </button>
-              <button onClick={() => onLinkRelative('child')} className="text-[10px] font-bold uppercase text-amber-700 flex items-center space-x-1">
-                <UserPlus size={14} /><span>Child</span>
-              </button>
-            </div>
-          </div>
-
-          <div className="grid gap-3 md:grid-cols-3">
-            {[{ label: 'Parents', list: rels.parents }, { label: 'Spouses', list: rels.spouses }, { label: 'Children', list: rels.children }].map(group => (
-              <div key={group.label} className="bg-white p-5 rounded-[32px] border border-stone-50 shadow-sm">
-                <div className="text-[10px] font-black uppercase tracking-widest text-stone-400">{group.label}</div>
-                <div className="mt-3 space-y-2">
-                  {group.list.length === 0 ? (
-                    <div className="text-sm text-stone-400 italic">None listed</div>
-                  ) : group.list.map(p => (
-                    <button key={p.id} onClick={() => onSetActiveProfile(p.id)} className="w-full flex items-center space-x-3 p-2 rounded-2xl hover:bg-stone-50 transition-all">
-                      <img src={p.imageUrl} className="w-10 h-10 rounded-2xl object-cover grayscale" />
-                      <div className="text-left flex-1">
-                        <div className="font-serif text-lg">{p.name}</div>
-                        <div className="text-[10px] text-stone-400 font-black uppercase">{p.birthYear} — {p.deathYear || '...'}</div>
-                      </div>
-                      <ChevronRight className="text-stone-200" size={16} />
-                    </button>
-                  ))}
-                </div>
-              </div>
-            ))}
-          </div>
-        </section>
-
-        <section className="space-y-3 mb-10">
-          <div className="flex items-center justify-between px-2">
-            <h3 className="text-[10px] font-bold uppercase tracking-widest text-stone-400">Timeline</h3>
-            <span className="text-[10px] text-stone-300">{timeline.length} events</span>
-          </div>
-
-          <div className="space-y-3">
-            {timeline.length === 0 ? (
-              <div className="bg-white p-6 rounded-[32px] border border-stone-50 shadow-sm text-stone-400 italic">No life events yet.</div>
-            ) : timeline.map((ev, idx) => {
-              const Icon = getEventIcon(ev.type);
-              const isAttaching = attachingToEventId === ev.id;
-              return (
-                <div key={ev.id} className="bg-white rounded-[32px] border border-stone-50 shadow-sm overflow-hidden">
-                  {/* Year chip between events when year changes */}
-                  {idx === 0 || getEventYear(ev.date) !== getEventYear(timeline[idx - 1].date) ? (
-                    <div className="px-5 pt-4 pb-1">
-                      <span className="text-[10px] font-black uppercase tracking-widest text-amber-600">
-                        {getEventYear(ev.date)}
-                      </span>
-                    </div>
-                  ) : null}
-
-                  <div className="p-5">
-                    <div className="flex items-start space-x-4">
-                      <div className="w-10 h-10 rounded-2xl bg-stone-50 flex items-center justify-center flex-shrink-0">
-                        <Icon size={18} className="text-stone-400" />
-                      </div>
-                      <div className="flex-1 min-w-0">
-                        <div className="font-serif text-xl text-slate-900 leading-snug">
-                          {formatEventSentence(activeProfile.name, ev)}
-                        </div>
-                        <div className="mt-1 text-[10px] font-black uppercase tracking-widest text-stone-400">
-                          {ev.date ? formatFullDate(ev.date) : 'Date unknown'}
-                          {ev.place ? ` • ${ev.place}` : ''}
-                        </div>
-                        {(ev as any).note && (
-                          <div className="mt-2 text-sm text-stone-500 italic">{(ev as any).note}</div>
-                        )}
-                        {(ev as any).subType && (
-                          <div className="mt-1 text-[10px] uppercase tracking-widest text-stone-400">{(ev as any).subType}</div>
-                        )}
-
-                        {/* Attached media thumbnails */}
-                        {ev.media?.length > 0 && (
-                          <div className="mt-3 flex flex-wrap gap-2">
-                            {ev.media.map(m => (
-                              <a
-                                key={m.id}
-                                href={m.url}
-                                target="_blank"
-                                rel="noreferrer"
-                                className="inline-flex items-center space-x-1.5 px-3 py-1.5 rounded-full bg-stone-50 border border-stone-100 hover:bg-stone-100 transition-colors"
-                              >
-                                {m.kind === 'photo' && <span className="text-xs">🖼</span>}
-                                {m.kind === 'video' && <span className="text-xs">🎬</span>}
-                                {m.kind === 'audio' && <span className="text-xs">🎵</span>}
-                                {m.kind === 'document' && <span className="text-xs">📄</span>}
-                                <span className="text-[11px] font-bold text-stone-600 max-w-[120px] truncate">{m.name}</span>
-                              </a>
-                            ))}
-                          </div>
-                        )}
-                      </div>
-
-                      {/* Attach button */}
-                      <button
-                        onClick={() => setAttachingToEventId(isAttaching ? null : ev.id)}
-                        className={`flex-shrink-0 px-3 py-1.5 rounded-full text-[10px] font-bold uppercase transition-colors ${
-                          isAttaching
-                            ? 'bg-stone-900 text-white'
-                            : 'bg-stone-50 text-amber-700 border border-stone-100 hover:bg-amber-50'
-                        }`}
-                      >
-                        {isAttaching ? 'Cancel' : '+ Media'}
-                      </button>
-                    </div>
-
-                    {/* Expanded attach panel */}
-                    {isAttaching && (
-                      <EventMediaUploader
-                        eventId={ev.id}
-                        onFilesSelected={props.onEventMediaUpload}
-                      />
-                    )}
-                  </div>
-                </div>
-              );
-            })}
-          </div>
-        </section>
-
-        <section className="space-y-3 mb-10">
-          <div className="flex items-center justify-between px-2">
-            <h3 className="text-[10px] font-bold uppercase tracking-widest text-stone-400">Media</h3>
-          </div>
-
-          {media.length === 0 ? (
-            <div className="bg-white p-6 rounded-[32px] border border-stone-50 shadow-sm text-stone-400 italic">No media yet.</div>
-          ) : (
-            <div className="grid gap-3 md:grid-cols-3">
-              {media.map(m => (
-                <a key={m.id} href={m.url} target="_blank" rel="noreferrer" className="bg-white p-4 rounded-[32px] border border-stone-50 shadow-sm hover:shadow-md transition-all">
-                  <div className="text-[10px] font-black uppercase tracking-widest text-stone-400">{m.kind}</div>
-                  <div className="mt-2 font-serif text-xl text-slate-900">{m.name || 'Untitled'}</div>
-                </a>
-              ))}
-            </div>
-          )}
-        </section>
-      </main>
-    </div>
-  );
-};
-
-export default ProfileView;
diff -ruN before/views/SelectHomeView.tsx after/views/SelectHomeView.tsx
--- before/views/SelectHomeView.tsx	2026-02-21 02:03:34.494190061 +0000
+++ after/views/SelectHomeView.tsx	1970-01-01 00:00:00.000000000 +0000
@@ -1,93 +0,0 @@
-import React, { useMemo, useState } from 'react';
-import { ChevronLeft, Search, Check } from 'lucide-react';
-import { Profile } from '../types';
-
-type PendingImport = { importedProfiles: Profile[]; tree: any } | null;
-
-const SelectHomeView: React.FC<{
-  pendingImport: PendingImport;
-  onBack: () => void;
-  onChooseHome: (p: Profile) => void;
-}> = ({ pendingImport, onBack, onChooseHome }) => {
-  const [q, setQ] = useState('');
-
-  const candidates = useMemo(() => {
-    const list = pendingImport?.importedProfiles || [];
-    const query = q.trim().toLowerCase();
-    if (!query) return list.slice(0, 80);
-    return list
-      .filter(p => (p.name || '').toLowerCase().includes(query))
-      .slice(0, 80);
-  }, [pendingImport, q]);
-
-  if (!pendingImport) {
-    return (
-      <div className="flex flex-col h-full bg-[#f9f8f6]">
-        <header className="pt-16 px-8 pb-6 bg-[#f5f2eb] border-b border-stone-200">
-          <button onClick={onBack} className="flex items-center space-x-2 text-stone-500">
-            <ChevronLeft size={18} />
-            <span className="text-[11px] font-bold uppercase tracking-widest">Back</span>
-          </button>
-        </header>
-        <main className="p-8">
-          <p className="font-serif text-stone-600 italic">No import is pending.</p>
-        </main>
-      </div>
-    );
-  }
-
-  return (
-    <div className="flex flex-col h-full bg-[#f9f8f6]">
-      <header className="pt-16 px-8 pb-6 bg-[#f5f2eb] border-b border-stone-200">
-        <div className="flex items-center justify-between">
-          <button onClick={onBack} className="flex items-center space-x-2 text-stone-500">
-            <ChevronLeft size={18} />
-            <span className="text-[11px] font-bold uppercase tracking-widest">Back</span>
-          </button>
-          <div className="text-right">
-            <h2 className="text-2xl font-serif text-slate-800">Select Home Person</h2>
-            <p className="text-stone-400 text-[10px] font-bold uppercase">
-              {pendingImport.importedProfiles.length} imported profiles
-            </p>
-          </div>
-        </div>
-
-        <div className="mt-6 flex items-center space-x-3 bg-white rounded-full border border-stone-200 px-4 py-3">
-          <Search size={18} className="text-stone-300" />
-          <input
-            value={q}
-            onChange={(e) => setQ(e.target.value)}
-            placeholder="Search imported people"
-            className="flex-1 bg-transparent outline-none text-sm text-slate-900 placeholder:text-stone-400"
-          />
-        </div>
-      </header>
-
-      <main className="flex-1 p-8 overflow-y-auto">
-        <div className="grid gap-3">
-          {candidates.map(p => (
-            <button
-              key={p.id}
-              onClick={() => onChooseHome(p)}
-              className="w-full bg-white p-4 rounded-[32px] shadow-sm border border-stone-50 flex items-center space-x-4 hover:shadow-md transition-all"
-            >
-              <img src={p.imageUrl} className="w-14 h-14 rounded-2xl object-cover grayscale" />
-              <div className="text-left flex-1">
-                <h4 className="font-serif text-xl">{p.name}</h4>
-                <p className="text-[10px] text-stone-400 font-black uppercase mt-1">
-                  {p.birthYear} — {p.deathYear || '...'}
-                </p>
-              </div>
-              <div className="flex items-center space-x-2 text-amber-700">
-                <Check size={18} />
-                <span className="text-[10px] font-bold uppercase">Make home</span>
-              </div>
-            </button>
-          ))}
-        </div>
-      </main>
-    </div>
-  );
-};
-
-export default SelectHomeView;
diff -ruN before/views/SplashView.tsx after/views/SplashView.tsx
--- before/views/SplashView.tsx	2026-02-21 02:03:34.509190061 +0000
+++ after/views/SplashView.tsx	1970-01-01 00:00:00.000000000 +0000
@@ -1,14 +0,0 @@
-import React from 'react';
-
-const SplashView: React.FC = () => {
-  return (
-    <div className="flex flex-col items-center justify-center h-full bg-[#dccdb9] text-[#1c1917]">
-      <div className="animate-fade-in-up text-center space-y-4">
-        <h1 className="text-6xl font-serif">Eternal</h1>
-        <p className="text-xs tracking-widest uppercase opacity-60">Ancestry Preservation</p>
-      </div>
-    </div>
-  );
-};
-
-export default SplashView;
diff -ruN before/views/TreeView.tsx after/views/TreeView.tsx
--- before/views/TreeView.tsx	2026-02-21 02:03:34.527190060 +0000
+++ after/views/TreeView.tsx	1970-01-01 00:00:00.000000000 +0000
@@ -1,72 +0,0 @@
-import React, { useMemo } from 'react';
-import { ChevronLeft, ChevronRight, Home } from 'lucide-react';
-import { FamilyTree, Profile } from '../types';
-
-const TreeView: React.FC<{
-  tree: FamilyTree;
-  profiles: Profile[];
-  onBack: () => void;
-  onOpenProfile: (id: string) => void;
-}> = ({ tree, profiles, onBack, onOpenProfile }) => {
-  const members = useMemo(() => {
-    const map = new Map(profiles.map(p => [p.id, p]));
-    return tree.memberIds.map(id => map.get(id)).filter(Boolean) as Profile[];
-  }, [tree, profiles]);
-
-  const home = profiles.find(p => p.id === tree.homePersonId) || null;
-
-  return (
-    <div className="flex flex-col h-full bg-[#f9f8f6]">
-      <header className="pt-16 px-8 pb-6 bg-[#f5f2eb] border-b border-stone-200">
-        <div className="flex items-center justify-between">
-          <button onClick={onBack} className="flex items-center space-x-2 text-stone-500">
-            <ChevronLeft size={18} />
-            <span className="text-[11px] font-bold uppercase tracking-widest">Back</span>
-          </button>
-          <div className="text-right">
-            <h2 className="text-2xl font-serif text-slate-800">{tree.name}</h2>
-            <p className="text-stone-400 text-[10px] font-bold uppercase">{tree.memberIds.length} members</p>
-          </div>
-        </div>
-      </header>
-
-      <main className="flex-1 p-8 overflow-y-auto space-y-6">
-        {home && (
-          <div className="bg-white p-5 rounded-[32px] border border-stone-50 shadow-sm flex items-center space-x-4">
-            <Home className="text-amber-700" size={18} />
-            <img src={home.imageUrl} className="w-12 h-12 rounded-2xl object-cover grayscale" />
-            <div className="flex-1 text-left">
-              <div className="text-[10px] font-black uppercase text-stone-400">Home person</div>
-              <div className="font-serif text-xl">{home.name}</div>
-            </div>
-            <button onClick={() => onOpenProfile(home.id)} className="p-2 rounded-full hover:bg-stone-50">
-              <ChevronRight className="text-stone-300" size={18} />
-            </button>
-          </div>
-        )}
-
-        <section className="space-y-3">
-          <div className="text-[10px] font-bold uppercase tracking-widest text-stone-400">Members</div>
-          <div className="grid gap-3">
-            {members.map(p => (
-              <button
-                key={p.id}
-                onClick={() => onOpenProfile(p.id)}
-                className="w-full bg-white p-4 rounded-[32px] shadow-sm border border-stone-50 flex items-center space-x-4 hover:shadow-md transition-all"
-              >
-                <img src={p.imageUrl} className="w-14 h-14 rounded-2xl object-cover grayscale" />
-                <div className="text-left flex-1">
-                  <h4 className="font-serif text-xl">{p.name}</h4>
-                  <p className="text-[10px] text-stone-400 font-black uppercase mt-1">{p.birthYear} — {p.deathYear || '...'}</p>
-                </div>
-                <ChevronRight className="text-stone-200" size={18} />
-              </button>
-            ))}
-          </div>
-        </section>
-      </main>
-    </div>
-  );
-};
-
-export default TreeView;
diff -ruN before/views/TreesView.tsx after/views/TreesView.tsx
--- before/views/TreesView.tsx	2026-02-21 02:03:34.542190060 +0000
+++ after/views/TreesView.tsx	1970-01-01 00:00:00.000000000 +0000
@@ -1,58 +0,0 @@
-import React from 'react';
-import { ChevronLeft, ChevronRight, GitBranch } from 'lucide-react';
-import { FamilyTree } from '../types';
-
-const TreesView: React.FC<{
-  trees: FamilyTree[];
-  selectedTreeId: string | null;
-  onBack: () => void;
-  onSelectTree: (id: string) => void;
-  onOpenTree: (id: string) => void;
-}> = ({ trees, selectedTreeId, onBack, onSelectTree, onOpenTree }) => {
-  return (
-    <div className="flex flex-col h-full bg-[#f9f8f6]">
-      <header className="pt-16 px-8 pb-6 bg-[#f5f2eb] border-b border-stone-200">
-        <div className="flex items-center justify-between">
-          <button onClick={onBack} className="flex items-center space-x-2 text-stone-500">
-            <ChevronLeft size={18} />
-            <span className="text-[11px] font-bold uppercase tracking-widest">Back</span>
-          </button>
-          <div className="text-right">
-            <h2 className="text-2xl font-serif text-slate-800">Trees</h2>
-            <p className="text-stone-400 text-[10px] font-bold uppercase">{trees.length} total</p>
-          </div>
-        </div>
-      </header>
-
-      <main className="flex-1 p-8 overflow-y-auto">
-        {trees.length === 0 ? (
-          <div className="text-center space-y-6 mt-10">
-            <GitBranch size={48} className="mx-auto text-stone-200" />
-            <p className="font-serif text-stone-500 italic">No trees yet.</p>
-          </div>
-        ) : (
-          <div className="grid gap-3">
-            {trees.map(t => (
-              <div key={t.id} className="w-full bg-white p-4 rounded-[32px] shadow-sm border border-stone-50 flex items-center space-x-4">
-                <button
-                  onClick={() => onSelectTree(t.id)}
-                  className={`w-5 h-5 rounded-full border ${selectedTreeId === t.id ? 'bg-stone-900 border-stone-900' : 'border-stone-300'}`}
-                  aria-label="Select tree"
-                />
-                <div className="text-left flex-1">
-                  <h4 className="font-serif text-xl">{t.name}</h4>
-                  <p className="text-[10px] text-stone-400 font-black uppercase mt-1">{t.memberIds.length} members</p>
-                </div>
-                <button onClick={() => onOpenTree(t.id)} className="p-2 rounded-full hover:bg-stone-50">
-                  <ChevronRight className="text-stone-300" size={18} />
-                </button>
-              </div>
-            ))}
-          </div>
-        )}
-      </main>
-    </div>
-  );
-};
-
-export default TreesView;
diff -ruN before/vite.config.ts after/vite.config.ts
--- before/vite.config.ts	2026-02-21 02:03:34.557190060 +0000
+++ after/vite.config.ts	2026-02-21 02:07:24.361188344 +0000
@@ -3,21 +3,10 @@
 import react from '@vitejs/plugin-react';
 
 // GEMINI_API_KEY is intentionally NOT forwarded to the client bundle.
-// It lives only in Vercel env vars and is read by /api/gemini.ts at runtime.
-//
-// ── Local development ─────────────────────────────────────────────────────────
-// Do NOT run `vite` directly. Use `npm run dev` which calls `vercel dev`.
-// vercel dev:
-//   1. Reads vercel.json devCommand and starts Vite on port 5173 as a subprocess
-//   2. Runs api/gemini.ts in a local Node runtime on port 3000
-//   3. Routes /api/* to the function runtime, everything else to Vite
-//      — identical topology to production, zero CORS configuration needed.
+// It is read only by /api/gemini.ts at runtime on the server.
 export default defineConfig({
   root: '.',
   server: {
-    // 5173 is Vite's own default. vercel dev owns :3000 and proxies to this port.
-    // Use strictPort so the process fails fast if 5173 is taken, rather than
-    // silently incrementing and breaking vercel dev's proxy target.
     port: 5173,
     host: '0.0.0.0',
     strictPort: true,
@@ -25,7 +14,6 @@
   plugins: [react()],
   resolve: {
     alias: {
-      // '@/' maps to src/ — usable in both app code and tests.
       '@': path.resolve(__dirname, 'src'),
     },
   },
diff -ruN before/vitest.config.ts after/vitest.config.ts
--- before/vitest.config.ts	2026-02-21 02:03:34.573190060 +0000
+++ after/vitest.config.ts	2026-02-21 02:07:27.713188319 +0000
@@ -3,8 +3,6 @@
 
 export default defineConfig({
   test: {
-    // Only look for tests inside src/ — keeps api/ (Node serverless) out of the
-    // browser-environment test runner.
     include: ['src/**/*.test.ts', 'src/**/*.test.tsx', 'src/**/*.spec.ts'],
     environment: 'node',
   },
